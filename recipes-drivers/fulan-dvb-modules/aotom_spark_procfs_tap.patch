diff -Naur a/e2_proc/e2_proc_main.c b/e2_proc/e2_proc_main.c
--- a/e2_proc/e2_proc_main.c	2017-05-01 20:31:14.714295282 +0200
+++ b/e2_proc/e2_proc_main.c	2017-05-02 14:21:10.571613575 +0200
@@ -118,6 +118,8 @@
  *  |           |
  *  |           --------- led0_pattern
  *  |           |
+ *  |           --------- led1_pattern
+ *  |           |
  *  |           --------- led_pattern_speed
  *  |           |
  *  |           |
@@ -205,6 +207,10 @@
  *  |           --------- dst_width   |
  *  |           |                     |
  *  |           --------- dst_height /
+ *  |
+ *  ---------- power
+ *  |           |
+ *  |           --------- standbyled
  *
  */
 
@@ -447,6 +453,10 @@
 {
 	{cProcEntry, "progress"                                                         , NULL, NULL, NULL, NULL, ""},
 
+#if defined(SPARK) || defined(SPARK7162)
+	{cProcEntry, "vfd"                                                              , NULL, NULL, NULL, NULL, ""},
+#endif
+
 	{cProcEntry, "bus/nim_sockets"                                                  , NULL, NULL, NULL, NULL, ""},
 	{cProcDir  , "stb"                                                              , NULL, NULL, NULL, NULL, ""},
 	{cProcDir  , "stb/audio"                                                        , NULL, NULL, NULL, NULL, ""},
@@ -507,11 +517,35 @@
 	{cProcEntry, "stb/fp/lnb_sense1"                                                , NULL, NULL, NULL, NULL, ""},
 	{cProcEntry, "stb/fp/lnb_sense2"                                                , NULL, NULL, NULL, NULL, ""},
 	{cProcEntry, "stb/fp/led0_pattern"                                              , NULL, NULL, default_write_proc, NULL, ""},
+	{cProcEntry, "stb/fp/led1_pattern"                                              , NULL, NULL, default_write_proc, NULL, ""},
 	{cProcEntry, "stb/fp/led_pattern_speed"                                         , NULL, NULL, default_write_proc, NULL, ""},
 	{cProcEntry, "stb/fp/version"                                                   , NULL, zero_read, NULL, NULL, ""},
 	{cProcEntry, "stb/fp/wakeup_time"                                               , NULL, wakeup_time_read, wakeup_time_write, NULL, ""},
 	{cProcEntry, "stb/fp/was_timer_wakeup"                                          , NULL, NULL, NULL, NULL, ""},
 	{cProcEntry, "stb/fp/rtc"                                                       , NULL, zero_read, default_write_proc, NULL, ""},
+	{cProcEntry, "stb/fp/rtc_offset"                                                , NULL, zero_read, default_write_proc, NULL, ""},
+#if defined(SPARK) || defined(SPARK7162)
+	{cProcEntry, "stb/fp/aotom"                                                     , NULL, NULL, NULL, NULL, ""},
+	{cProcDir  , "stb/lcd"                                                          , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/scroll_delay"                                             , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/show_symbols"                                             , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_network"                                           , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_usb"                                               , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_hdd"                                               , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_hddprogress"                                       , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_signal"                                            , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_timeshift"                                         , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_tv"                                                , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_recording"                                         , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_record_1"                                          , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_record_2"                                          , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_smartcard"                                         , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_parent_rating"                                     , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/symbol_play"                                              , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/lcd/oled_brightness"                                          , NULL, NULL, NULL, NULL, ""},
+	{cProcDir  , "stb/power"                                                        , NULL, NULL, NULL, NULL, ""},
+	{cProcEntry, "stb/power/standbyled"                                             , NULL, NULL, NULL, NULL, ""},
+#endif
 
 	{cProcDir  , "stb/tsmux"                                                        , NULL, NULL, NULL, NULL, ""},
 	{cProcEntry, "stb/tsmux/input0"                                                 , NULL, NULL, NULL, NULL, ""},
diff -Naur a/frontcontroller/aotom/aotom_gpio.h b/frontcontroller/aotom/aotom_gpio.h
--- a/frontcontroller/aotom/aotom_gpio.h	2017-05-01 20:31:14.714295282 +0200
+++ b/frontcontroller/aotom/aotom_gpio.h	2017-05-02 14:19:36.516095782 +0200
@@ -1,25 +1,25 @@
 #ifndef __AOTOM_GPIO_H__
 #define __AOTOM_GPIO_H__
 
-#define PIO_BITS                			8
+#define PIO_BITS                            8
 
-#define GPIO_SIMULATE_I2C_SCL_PORT			2
-#define GPIO_SIMULATE_I2C_SCL_BIT			0
+#define GPIO_SIMULATE_I2C_SCL_PORT          2
+#define GPIO_SIMULATE_I2C_SCL_BIT           0
 
-#define GPIO_SIMULATE_I2C_SDA_PORT			2
-#define GPIO_SIMULATE_I2C_SDA_BIT			1
+#define GPIO_SIMULATE_I2C_SDA_PORT          2
+#define GPIO_SIMULATE_I2C_SDA_BIT           1
 
-#define GPIO_I2C_FIRST_SCL_PORT				2
-#define GPIO_I2C_FIRST_SCL_BIT				2
+#define GPIO_I2C_FIRST_SCL_PORT             2
+#define GPIO_I2C_FIRST_SCL_BIT              2
 
-#define GPIO_I2C_FIRST_SDA_PORT				2
-#define GPIO_I2C_FIRST_SDA_BIT				3
+#define GPIO_I2C_FIRST_SDA_PORT             2
+#define GPIO_I2C_FIRST_SDA_BIT              3
 
-#define GPIO_I2C_SECOND_SCL_PORT			2
-#define GPIO_I2C_SECOND_SCL_BIT				5
+#define GPIO_I2C_SECOND_SCL_PORT            2
+#define GPIO_I2C_SECOND_SCL_BIT             5
 
-#define GPIO_I2C_SECOND_SDA_PORT			2
-#define GPIO_I2C_SECOND_SDA_BIT				6
+#define GPIO_I2C_SECOND_SDA_PORT            2
+#define GPIO_I2C_SECOND_SDA_BIT             6
 
 typedef struct YWLIB_ListHead_s
 {
@@ -29,43 +29,43 @@
 /*Error Define*/
 enum
 {
-    YWGPIO_ERROR_INIT  = YW_MODULE_SET_ID(YWHAL_MODULE_GPIO_ID),
-    YWGPIO_ERROR_TERM,
-    YWGPIO_ERROR_OPEN,
-    YWGPIO_ERROR_CLOSE,
-    YWGPIO_ERROR_READ,
-    YWGPIO_ERROR_WRITE,
-    YWGPIO_ERROR_CONFIG,
-    YWGPIO_ERROR_CTROL,
-    YWGPIO_ERROR_BUSY
+	YWGPIO_ERROR_INIT  = YW_MODULE_SET_ID(YWHAL_MODULE_GPIO_ID),
+	YWGPIO_ERROR_TERM,
+	YWGPIO_ERROR_OPEN,
+	YWGPIO_ERROR_CLOSE,
+	YWGPIO_ERROR_READ,
+	YWGPIO_ERROR_WRITE,
+	YWGPIO_ERROR_CONFIG,
+	YWGPIO_ERROR_CTROL,
+	YWGPIO_ERROR_BUSY
 };
 
 typedef enum YWGPIO_IOMode_e
 {
-    YWGPIO_IO_MODE_NOT_SPECIFIED,
-    YWGPIO_IO_MODE_BIDIRECTIONAL,
-    YWGPIO_IO_MODE_OUTPUT,
-    YWGPIO_IO_MODE_INPUT,
-    YWGPIO_IO_MODE_ALTERNATE_OUTPUT,
-    YWGPIO_IO_MODE_ALTERNATE_BIDIRECTIONAL,
-    YWGPIO_IO_MODE_BIDIRECTIONAL_HIGH,            /*4th bit remains HIGH*/
-    YWGPIO_IO_MODE_OUTPUT_HIGH                    /*4th bit remains HIGH*/
-}YWGPIO_IOMode_T;
+	YWGPIO_IO_MODE_NOT_SPECIFIED,
+	YWGPIO_IO_MODE_BIDIRECTIONAL,
+	YWGPIO_IO_MODE_OUTPUT,
+	YWGPIO_IO_MODE_INPUT,
+	YWGPIO_IO_MODE_ALTERNATE_OUTPUT,
+	YWGPIO_IO_MODE_ALTERNATE_BIDIRECTIONAL,
+	YWGPIO_IO_MODE_BIDIRECTIONAL_HIGH,            /*4th bit remains HIGH*/
+	YWGPIO_IO_MODE_OUTPUT_HIGH                    /*4th bit remains HIGH*/
+} YWGPIO_IOMode_T;
 
 typedef enum YWGPIO_WorkMode_e
 {
-    YWGPIO_WORK_MODE_PRIMARY,   /* Configure for primary functionality */
-    YWGPIO_WORK_MODE_SECONDARY  /* Configure for GPIO functionality */
+	YWGPIO_WORK_MODE_PRIMARY,   /* Configure for primary functionality */
+	YWGPIO_WORK_MODE_SECONDARY  /* Configure for GPIO functionality */
 } YWGPIO_WorkMode_T;
 
 typedef enum YWGPIO_InterruptMode_e
 {
-    YWGPIO_INT_NONE          = 0,
-    YWGPIO_INT_HIGH          = 1,
-    YWGPIO_INT_LOW           = 2,
-    YWGPIO_INT_RAISING_EDGE  = 4,
-    YWGPIO_INT_FALLING_EDGE  = 8,
-    YWGPIO_INT_VERGE         = 16
+	YWGPIO_INT_NONE          = 0,
+	YWGPIO_INT_HIGH          = 1,
+	YWGPIO_INT_LOW           = 2,
+	YWGPIO_INT_RAISING_EDGE  = 4,
+	YWGPIO_INT_FALLING_EDGE  = 8,
+	YWGPIO_INT_VERGE         = 16
 } YWGPIO_InterruptMode_T;
 
 typedef U32 YWGPIO_Handle_T;
@@ -73,42 +73,41 @@
 
 typedef struct YWGPIO_GpioDeviceList_s
 {
-    YWLIB_ListHead_T     YWGPIO_GpioList;
-    U32                  GpioIndex;
-    void				 *PrivateData;
+	YWLIB_ListHead_T     YWGPIO_GpioList;
+	U32                  GpioIndex;
+	void                 *PrivateData;
 } YWGPIO_GpioDeviceList_T;
 
 typedef struct YWGPIO_Feature_s
 {
-    U32                  GpioNum;
-    YWLIB_ListHead_T     *GpioListHead;
+	U32                  GpioNum;
+	YWLIB_ListHead_T     *GpioListHead;
 } YWGPIO_Feature_T;
 
 typedef struct YWGPIO_OpenParams_s
 {
-    U32                 GpioIndex;
-    YWGPIO_IOMode_T     IoMode;
-    YWGPIO_WorkMode_T   WorkMode;
-    void 				*PrivateData;
+	U32                 GpioIndex;
+	YWGPIO_IOMode_T     IoMode;
+	YWGPIO_WorkMode_T   WorkMode;
+	void                *PrivateData;
 } YWGPIO_OpenParams_T;
 
-
 typedef void (* YWGPIO_ISRFunc_T)(YWGPIO_Handle_T GpioHandle);
 
 YW_ErrorType_T YWGPIO_Init(void);
 YW_ErrorType_T YWGPIO_Term(void);
-YW_ErrorType_T YWGPIO_GetFeature( YWGPIO_Feature_T *GpioFeature);
-YW_ErrorType_T YWGPIO_Open ( YWGPIO_Handle_T * pGpioHandle, YWGPIO_OpenParams_T *GpioOpenParams);
-YW_ErrorType_T YWGPIO_Close( YWGPIO_Handle_T GpioHandle);
-YW_ErrorType_T YWGPIO_SetIoMode ( YWGPIO_Handle_T GpioHandle, YWGPIO_IOMode_T IoMode );
-YW_ErrorType_T YWGPIO_SetWorkMode ( YWGPIO_Handle_T GpioHandle, YWGPIO_WorkMode_T WorkMode );
-
-YW_ErrorType_T YWGPIO_Read ( YWGPIO_Handle_T GpioHandle,U8* PioValue );
-YW_ErrorType_T YWGPIO_Write ( YWGPIO_Handle_T GpioHandle,U8 PioValue );
-YW_ErrorType_T YWGPIO_RegisterISR( YWGPIO_Handle_T GpioHandle, YWGPIO_ISRFunc_T  ISR,U32 Priority);
-YW_ErrorType_T YWGPIO_UnRegisterISR( YWGPIO_Handle_T GpioHandle);
-YW_ErrorType_T YWGPIO_EnableInterrupt( YWGPIO_Handle_T GpioHandle,YWGPIO_InterruptMode_T INTMode);
-YW_ErrorType_T YWGPIO_DisableInterrupt( YWGPIO_Handle_T GpioHandle);
-U32 YWGpioO_GetVersion( S8 *pchVer, U32 nSize  );
+YW_ErrorType_T YWGPIO_GetFeature(YWGPIO_Feature_T *GpioFeature);
+YW_ErrorType_T YWGPIO_Open(YWGPIO_Handle_T *pGpioHandle, YWGPIO_OpenParams_T *GpioOpenParams);
+YW_ErrorType_T YWGPIO_Close(YWGPIO_Handle_T GpioHandle);
+YW_ErrorType_T YWGPIO_SetIoMode(YWGPIO_Handle_T GpioHandle, YWGPIO_IOMode_T IoMode);
+YW_ErrorType_T YWGPIO_SetWorkMode(YWGPIO_Handle_T GpioHandle, YWGPIO_WorkMode_T WorkMode);
+
+YW_ErrorType_T YWGPIO_Read(YWGPIO_Handle_T GpioHandle, U8 *PioValue);
+YW_ErrorType_T YWGPIO_Write(YWGPIO_Handle_T GpioHandle, U8 PioValue);
+YW_ErrorType_T YWGPIO_RegisterISR(YWGPIO_Handle_T GpioHandle, YWGPIO_ISRFunc_T  ISR, U32 Priority);
+YW_ErrorType_T YWGPIO_UnRegisterISR(YWGPIO_Handle_T GpioHandle);
+YW_ErrorType_T YWGPIO_EnableInterrupt(YWGPIO_Handle_T GpioHandle, YWGPIO_InterruptMode_T INTMode);
+YW_ErrorType_T YWGPIO_DisableInterrupt(YWGPIO_Handle_T GpioHandle);
+U32 YWGpioO_GetVersion(S8 *pchVer, U32 nSize);
 
 #endif /* __AOTOM_GPIO_H__ */
diff -Naur a/frontcontroller/aotom/aotom_i2csoft.c b/frontcontroller/aotom/aotom_i2csoft.c
--- a/frontcontroller/aotom/aotom_i2csoft.c	2017-05-01 20:31:14.714295282 +0200
+++ b/frontcontroller/aotom/aotom_i2csoft.c	2017-05-02 14:19:36.516095782 +0200
@@ -51,12 +51,11 @@
 #define YWOSTRACE(x)
 #endif
 
-
-#define YWOS_WAIT_INFINITY		(0xFFFFFFFF)
-#define YWI2CSOFT_MAX_DEVICE	4
-#define YWI2CSOFT_MAX_HANDLE	16
-#define YWI2C_NUM_SOFT_I2C		1
-#define MAX_DEVICE_NAME			15
+#define YWOS_WAIT_INFINITY      (0xFFFFFFFF)
+#define YWI2CSOFT_MAX_DEVICE    4
+#define YWI2CSOFT_MAX_HANDLE    16
+#define YWI2C_NUM_SOFT_I2C      1
+#define MAX_DEVICE_NAME         15
 
 #define  I2C_DELAY              iic_delay(1)
 #define  I2C_TRISTATE
@@ -64,69 +63,63 @@
 
 typedef U32 YWOS_ClockMsec_T;
 typedef struct semaphore YWOS_SemaphoreID_T;
-typedef char I2CDeviceName_T[MAX_DEVICE_NAME+1];
+typedef char I2CDeviceName_T[MAX_DEVICE_NAME + 1];
 
 YWI2CSoft_Handle_t          g_SoftHandle;
 
 typedef struct YWI2CSoft_OpenParam_s
 {
-    BOOL        IsOpen;
-    U8          SlaveAddr;
+	BOOL        IsOpen;
+	U8          SlaveAddr;
 } YWI2CSoft_OpenParam_t;
 
 typedef struct YWI2CSoft_Device_s
 {
-    char                I2CName[16];
-    BOOL                IsInit;
-
-    U32                 Speed;
-    U8                  SlaveAddr;
+	char                I2CName[16];
+	BOOL                IsInit;
 
-    YWGPIO_Handle_T     SDAHandle;
-    YWGPIO_Handle_T     SCLHandle;
+	U32                 Speed;
+	U8                  SlaveAddr;
 
-    YWI2CSoft_OpenParam_t OpenParam[YWI2CSOFT_MAX_HANDLE];
+	YWGPIO_Handle_T     SDAHandle;
+	YWGPIO_Handle_T     SCLHandle;
 
-    YWOS_SemaphoreID_T  SoftI2cLock;
+	YWI2CSoft_OpenParam_t OpenParam[YWI2CSOFT_MAX_HANDLE];
 
+	YWOS_SemaphoreID_T  SoftI2cLock;
 
 } YWI2CSoft_Device_t;
 
-
 static YWI2CSoft_Device_t  I2CSoftDevice[YWI2CSOFT_MAX_DEVICE] =
 {
-    {"\0",FALSE,0,0,(YWGPIO_Handle_T)NULL,(YWGPIO_Handle_T)NULL},
-    {"\0",FALSE,0,0,(YWGPIO_Handle_T)NULL,(YWGPIO_Handle_T)NULL},
-    {"\0",FALSE,0,0,(YWGPIO_Handle_T)NULL,(YWGPIO_Handle_T)NULL},
-    {"\0",FALSE,0,0,(YWGPIO_Handle_T)NULL,(YWGPIO_Handle_T)NULL}
+	{"\0", FALSE, 0, 0, (YWGPIO_Handle_T)NULL, (YWGPIO_Handle_T)NULL},
+	{"\0", FALSE, 0, 0, (YWGPIO_Handle_T)NULL, (YWGPIO_Handle_T)NULL},
+	{"\0", FALSE, 0, 0, (YWGPIO_Handle_T)NULL, (YWGPIO_Handle_T)NULL},
+	{"\0", FALSE, 0, 0, (YWGPIO_Handle_T)NULL, (YWGPIO_Handle_T)NULL}
 };
 
-
 typedef struct YWI2C_SoftParam_s
 {
-    BOOL    IsMasterMode;
-    U32     SDAGpio;
-    U32     SCLGpio;
-
-    YWGPIO_Handle_T     SDAHandle;
-    YWGPIO_Handle_T     SCLHandle;
+	BOOL    IsMasterMode;
+	U32     SDAGpio;
+	U32     SCLGpio;
 
-    U32     SDARegBase;
-    U32     SCLRegBase;
+	YWGPIO_Handle_T     SDAHandle;
+	YWGPIO_Handle_T     SCLHandle;
 
-    U32     Speed; //hz
-    U8      SlaveAddr; //hz
+	U32     SDARegBase;
+	U32     SCLRegBase;
 
+	U32     Speed; //hz
+	U8      SlaveAddr; //hz
 
-}YWI2C_SoftParam_t;
-
+} YWI2C_SoftParam_t;
 
 static void iic_delay(int micros)
 {
-    udelay(micros * 2);
+	udelay(micros * 2);
 }
 
-
 /*=====================================================================*/
 /*                         Public Functions                            */
 /*=====================================================================*/
@@ -134,213 +127,191 @@
 /*-----------------------------------------------------------------------
  * Initialization
  */
-static void i2csoft_sendstop(YWGPIO_Handle_T SCL,YWGPIO_Handle_T SDA);
+static void i2csoft_sendstop(YWGPIO_Handle_T SCL, YWGPIO_Handle_T SDA);
 
-S32 YWLIB_Strcmp(S8 * str1, S8 *str2)
+S32 YWLIB_Strcmp(S8 *str1, S8 *str2)
 {
-    int iValue = 0;
-
-    if (str1 != NULL && str2 != NULL)
-    {
-        iValue = strcmp((char *)str1, (char *)str2);
-    }
-    return iValue;
+	int iValue = 0;
+	if (str1 != NULL && str2 != NULL)
+	{
+		iValue = strcmp((char *)str1, (char *)str2);
+	}
+	return iValue;
 }
 
-S8* YWLIB_Strcpy(S8 * pDstStr, const S8 *pSrcStr)
+S8 *YWLIB_Strcpy(S8 *pDstStr, const S8 *pSrcStr)
 {
-    S8 *pDest = NULL;
-    if (pDstStr != NULL && pSrcStr != NULL)
-    {
-        pDest = (S8 *)strcpy((char *)pDstStr, (char *)pSrcStr);
-    }
-    return pDest;
+	S8 *pDest = NULL;
+	if (pDstStr != NULL && pSrcStr != NULL)
+	{
+		pDest = (S8 *)strcpy((char *)pDstStr, (char *)pSrcStr);
+	}
+	return pDest;
 }
 
-void * YWLIB_Memset( void *s, int c, U32 n)
+void *YWLIB_Memset(void *s, int c, U32 n)
 {
-    if (s == NULL)
-    {
-        return s;
-    }
-
-    return memset(s, c, n);
+	if (s == NULL)
+	{
+		return s;
+	}
+	return memset(s, c, n);
 }
 
-YW_ErrorType_T YWOS_SemaphoreCreate( S8* Name, U32 Count,
-                                            YWOS_SemaphoreID_T* SemaphoreID )
+YW_ErrorType_T YWOS_SemaphoreCreate(S8 *Name, U32 Count, YWOS_SemaphoreID_T *SemaphoreID)
 {
-    Name = Name;
-    Count = Count;
-    SemaphoreID = SemaphoreID;
-    return YW_NO_ERROR;
+	Name = Name;
+	Count = Count;
+	SemaphoreID = SemaphoreID;
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T YWOS_SemaphoreWait( YWOS_SemaphoreID_T  SemaphoreID , YWOS_ClockMsec_T TimeOut )
+YW_ErrorType_T YWOS_SemaphoreWait(YWOS_SemaphoreID_T  SemaphoreID , YWOS_ClockMsec_T TimeOut)
 {
-    SemaphoreID = SemaphoreID;
-    TimeOut = TimeOut;
-    return YW_NO_ERROR;
+	SemaphoreID = SemaphoreID;
+	TimeOut = TimeOut;
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T YWOS_SemaphoreSend(  YWOS_SemaphoreID_T  SemaphoreID )
+YW_ErrorType_T YWOS_SemaphoreSend(YWOS_SemaphoreID_T  SemaphoreID)
 {
-    SemaphoreID = SemaphoreID;
-    return YW_NO_ERROR;
+	SemaphoreID = SemaphoreID;
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T YWOS_SemaphoreDelete(  YWOS_SemaphoreID_T  SemaphoreID )
+YW_ErrorType_T YWOS_SemaphoreDelete(YWOS_SemaphoreID_T  SemaphoreID)
 {
-    SemaphoreID = SemaphoreID;
-    return YW_NO_ERROR;
+	SemaphoreID = SemaphoreID;
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T YWGPIO_Open(YWGPIO_Handle_T * pGpioHandle,
-                                YWGPIO_OpenParams_T*GpioOpenParams)
+YW_ErrorType_T YWGPIO_Open(YWGPIO_Handle_T *pGpioHandle, YWGPIO_OpenParams_T *GpioOpenParams)
 {
 	struct stpio_pin *pPio = NULL;
-
-    pPio = stpio_request_pin(GpioOpenParams->GpioIndex / PIO_BITS,
-                                GpioOpenParams->GpioIndex % PIO_BITS,
-                                "LED", STPIO_OUT);
-    //printk("pPio = 0x%x\n", (int)pPio);
-
-    if (pPio)
-    {
-        (*pGpioHandle) = (YWGPIO_Handle_T)pPio;
-    }
-    return YW_NO_ERROR;
+	pPio = stpio_request_pin(GpioOpenParams->GpioIndex / PIO_BITS,
+				 GpioOpenParams->GpioIndex % PIO_BITS,
+				 "LED", STPIO_OUT);
+	//printk("pPio = 0x%x\n", (int)pPio);
+	if (pPio)
+	{
+		(*pGpioHandle) = (YWGPIO_Handle_T)pPio;
+	}
+	return YW_NO_ERROR;
 }
 
 YW_ErrorType_T YWGPIO_Close(YWGPIO_Handle_T GpioHandle)
 {
 	struct stpio_pin *pPio = (struct stpio_pin *)GpioHandle;
-    stpio_free_pin(pPio);
-    return YW_NO_ERROR;
+	stpio_free_pin(pPio);
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T YWGPIO_Write (YWGPIO_Handle_T GpioHandle, U8 PioValue)
+YW_ErrorType_T YWGPIO_Write(YWGPIO_Handle_T GpioHandle, U8 PioValue)
 {
 	struct stpio_pin *pPio = (struct stpio_pin *)GpioHandle;
-
-    stpio_set_pin(pPio, PioValue);
-
-    return YW_NO_ERROR;
+	stpio_set_pin(pPio, PioValue);
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T YWGPIO_Read (YWGPIO_Handle_T GpioHandle, U8* pPioValue)
+YW_ErrorType_T YWGPIO_Read(YWGPIO_Handle_T GpioHandle, U8 *pPioValue)
 {
 	struct stpio_pin *pPio = (struct stpio_pin *)GpioHandle;
-
-    (*pPioValue) = stpio_get_pin(pPio);
-
-    return YW_NO_ERROR;
+	(*pPioValue) = stpio_get_pin(pPio);
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T YWGPIO_SetIoMode(YWGPIO_Handle_T GpioHandle,
-                                        YWGPIO_IOMode_T IoMode)
+YW_ErrorType_T YWGPIO_SetIoMode(YWGPIO_Handle_T GpioHandle, YWGPIO_IOMode_T IoMode)
 {
 	struct stpio_pin *pPio = (struct stpio_pin *)GpioHandle;
-
-    switch (IoMode)
-    {
-        case YWGPIO_IO_MODE_INPUT:
-            stpio_configure_pin(pPio, STPIO_IN);
-            break;
-        case YWGPIO_IO_MODE_OUTPUT:
-            stpio_configure_pin(pPio, STPIO_OUT);
-            break;
-        case YWGPIO_IO_MODE_BIDIRECTIONAL:
-            stpio_configure_pin(pPio, STPIO_BIDIR);
-            break;
-        default:
-
-            break;
-    }
-    return YW_NO_ERROR;
+	switch (IoMode)
+	{
+		case YWGPIO_IO_MODE_INPUT:
+			stpio_configure_pin(pPio, STPIO_IN);
+			break;
+		case YWGPIO_IO_MODE_OUTPUT:
+			stpio_configure_pin(pPio, STPIO_OUT);
+			break;
+		case YWGPIO_IO_MODE_BIDIRECTIONAL:
+			stpio_configure_pin(pPio, STPIO_BIDIR);
+			break;
+		default:
+			break;
+	}
+	return YW_NO_ERROR;
 }
 
 static BOOL IsI2CAlreadyInitialised(char *Name)
 {
-    int     i;
-    BOOL    IsInited = FALSE;
-
-    for(i=0;i<YWI2CSOFT_MAX_DEVICE;i++)
-    {
-        if(YWLIB_Strcmp((S8 *)Name, (S8 *)I2CSoftDevice[i].I2CName)==0)
-        {
-            if(I2CSoftDevice[i].IsInit)
-            {
-                IsInited = TRUE;
-                break;
-            }
-        }
-    }
-    return IsInited;
-}
-
-static BOOL CheckI2cParam(YWI2CSoft_Handle_t Handle,U32 *DeviceIndex,U32 *HandleIndex)
-{
-    int                     i,j;
-    BOOL                    FindHandle = FALSE;
-
-    for(i=0;i<YWI2CSOFT_MAX_DEVICE;i++)
-    {
-        if((I2CSoftDevice[i].IsInit))
-        {
-            for(j=0;j<YWI2CSOFT_MAX_HANDLE;j++)
-            {
-                //printk("Handle=0x%x &I2CSoftDevice[i].OpenParam[j]=0x%x\n",Handle,&I2CSoftDevice[i].OpenParam[j]);
-                if(((YWI2CSoft_Handle_t)&I2CSoftDevice[i].OpenParam[j]) == Handle)
-                {
-                    FindHandle = TRUE;
-                    break;
-                }
-            }
-            if(FindHandle)
-            {
-                break;
-            }
-        }
-    }
-
-    if(FindHandle)
-    {
-        *DeviceIndex = i;
-        *HandleIndex = j;
-    }
-    else
-    {
-        *DeviceIndex = YWI2CSOFT_MAX_DEVICE;
-        *HandleIndex = YWI2CSOFT_MAX_HANDLE;
-    }
-
-    return FindHandle;
+	int     i;
+	BOOL    IsInited = FALSE;
+	for (i = 0; i < YWI2CSOFT_MAX_DEVICE; i++)
+	{
+		if (YWLIB_Strcmp((S8 *)Name, (S8 *)I2CSoftDevice[i].I2CName) == 0)
+		{
+			if (I2CSoftDevice[i].IsInit)
+			{
+				IsInited = TRUE;
+				break;
+			}
+		}
+	}
+	return IsInited;
+}
 
+static BOOL CheckI2cParam(YWI2CSoft_Handle_t Handle, U32 *DeviceIndex, U32 *HandleIndex)
+{
+	int                     i, j;
+	BOOL                    FindHandle = FALSE;
+	for (i = 0; i < YWI2CSOFT_MAX_DEVICE; i++)
+	{
+		if ((I2CSoftDevice[i].IsInit))
+		{
+			for (j = 0; j < YWI2CSOFT_MAX_HANDLE; j++)
+			{
+				//printk("Handle=0x%x &I2CSoftDevice[i].OpenParam[j]=0x%x\n",Handle,&I2CSoftDevice[i].OpenParam[j]);
+				if (((YWI2CSoft_Handle_t)&I2CSoftDevice[i].OpenParam[j]) == Handle)
+				{
+					FindHandle = TRUE;
+					break;
+				}
+			}
+			if (FindHandle)
+			{
+				break;
+			}
+		}
+	}
+	if (FindHandle)
+	{
+		*DeviceIndex = i;
+		*HandleIndex = j;
+	}
+	else
+	{
+		*DeviceIndex = YWI2CSOFT_MAX_DEVICE;
+		*HandleIndex = YWI2CSOFT_MAX_HANDLE;
+	}
+	return FindHandle;
 }
 
 static void i2csoft_lock(U32 DeviceIndex)
 {
-    YWOS_SemaphoreWait(I2CSoftDevice[DeviceIndex].SoftI2cLock, YWOS_WAIT_INFINITY);
+	YWOS_SemaphoreWait(I2CSoftDevice[DeviceIndex].SoftI2cLock, YWOS_WAIT_INFINITY);
 }
 
-
 static void i2csoft_unlock(U32 DeviceIndex)
 {
-    YWOS_SemaphoreSend(I2CSoftDevice[DeviceIndex].SoftI2cLock);
+	YWOS_SemaphoreSend(I2CSoftDevice[DeviceIndex].SoftI2cLock);
 }
 
-
-
-static void i2csoft_reset(YWGPIO_Handle_T SCL,YWGPIO_Handle_T SDA)
+static void i2csoft_reset(YWGPIO_Handle_T SCL, YWGPIO_Handle_T SDA)
 {
 	int j;
-
 	YWGPIO_Write(SCL, 1); //I2C_SCL(1);
 	YWGPIO_Write(SDA, 1); //I2C_SDA(1);
-
 	//I2C_TRISTATE;
-	for(j = 0; j < 9; j++) {
+	for (j = 0; j < 9; j++)
+	{
 		YWGPIO_Write(SCL, 0); //I2C_SCL(0);
 		I2C_DELAY;
 		I2C_DELAY;
@@ -350,18 +321,14 @@
 	}
 	i2csoft_sendstop(SCL, SDA);
 	I2C_TRISTATE;
-
 }
 
-
-
-
-static void i2csoft_sendstart(YWGPIO_Handle_T SCL,YWGPIO_Handle_T SDA)
+static void i2csoft_sendstart(YWGPIO_Handle_T SCL, YWGPIO_Handle_T SDA)
 {
 	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_OUTPUT);
-    YWGPIO_Write(SDA, 1); //I2C_SDA(1);
+	YWGPIO_Write(SDA, 1); //I2C_SDA(1);
 	iic_delay(1);
-    YWGPIO_Write(SCL, 1); //I2C_SCL(1);
+	YWGPIO_Write(SCL, 1); //I2C_SCL(1);
 	iic_delay(5);
 	YWGPIO_Write(SDA, 0); //I2C_SDA(0);
 	iic_delay(5);
@@ -369,750 +336,630 @@
 	iic_delay(2);
 }
 
-static void i2csoft_sendstop(YWGPIO_Handle_T SCL,YWGPIO_Handle_T SDA)
+static void i2csoft_sendstop(YWGPIO_Handle_T SCL, YWGPIO_Handle_T SDA)
 {
 	YWGPIO_Write(SCL, 0); //I2C_SCL(0);
 	iic_delay(2);
 	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_OUTPUT);
-    YWGPIO_Write(SDA, 0); //I2C_SDA(0);
-    iic_delay(1);
-    YWGPIO_Write(SCL, 1); //I2C_SCL(1);
-    iic_delay(5);
-    YWGPIO_Write(SDA, 1); //I2C_SDA(1);
-    iic_delay(4);
+	YWGPIO_Write(SDA, 0); //I2C_SDA(0);
+	iic_delay(1);
+	YWGPIO_Write(SCL, 1); //I2C_SCL(1);
+	iic_delay(5);
+	YWGPIO_Write(SDA, 1); //I2C_SDA(1);
+	iic_delay(4);
 }
 
-static void i2csoft_sendack(YWGPIO_Handle_T SCL,YWGPIO_Handle_T SDA,int ack)
+static void i2csoft_sendack(YWGPIO_Handle_T SCL, YWGPIO_Handle_T SDA, int ack)
 {
 	YWGPIO_Write(SCL, 0); //I2C_SCL(0);
-    iic_delay(3);
+	iic_delay(3);
 	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_OUTPUT);
-
-    if(ack)
-	    YWGPIO_Write(SDA, 1); //I2C_SDA(1);
-    else
-	    YWGPIO_Write(SDA, 0); //I2C_SDA(0);
-
-    iic_delay(3);
+	if (ack)
+		YWGPIO_Write(SDA, 1); //I2C_SDA(1);
+	else
+		YWGPIO_Write(SDA, 0); //I2C_SDA(0);
+	iic_delay(3);
 	YWGPIO_Write(SCL, 1); //I2C_SCL(1);
-    iic_delay(5);
+	iic_delay(5);
 	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_BIDIRECTIONAL);
 	YWGPIO_Write(SCL, 0); //I2C_SCL(0);
-    iic_delay(2);
-
+	iic_delay(2);
 }
-static int i2csoft_writebyte(YWGPIO_Handle_T SCL,YWGPIO_Handle_T SDA,U8 data)
+static int i2csoft_writebyte(YWGPIO_Handle_T SCL, YWGPIO_Handle_T SDA, U8 data)
 {
-    int j;
-    U8 nack;
+	int j;
+	U8 nack;
 	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_OUTPUT);
-    for(j = 0; j < 8; j++)
-    {
-        YWGPIO_Write(SCL, 0); //I2C_SCL(0);
-        iic_delay(1);
-        if(data & 0x80)
-            YWGPIO_Write(SDA, 1); //I2C_SDA(1);
-        else
-            YWGPIO_Write(SDA, 0); //I2C_SDA(0);
-        iic_delay(1);
-        YWGPIO_Write(SCL, 1); //I2C_SCL(1);
-        iic_delay(5);
-        //I2C_SCL(0);
-
-        data <<= 1;
-    }
-
-    /*
-    * Look for an <ACK>(negative logic) and return it.
-    */
+	for (j = 0; j < 8; j++)
+	{
+		YWGPIO_Write(SCL, 0); //I2C_SCL(0);
+		iic_delay(1);
+		if (data & 0x80)
+			YWGPIO_Write(SDA, 1); //I2C_SDA(1);
+		else
+			YWGPIO_Write(SDA, 0); //I2C_SDA(0);
+		iic_delay(1);
+		YWGPIO_Write(SCL, 1); //I2C_SCL(1);
+		iic_delay(5);
+		//I2C_SCL(0);
+		data <<= 1;
+	}
+	/*
+	* Look for an <ACK>(negative logic) and return it.
+	*/
 	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_BIDIRECTIONAL);
-    YWGPIO_Write(SCL, 0); //I2C_SCL(0);
-    iic_delay(2);
-    YWGPIO_Write(SDA, 1); //I2C_SDA(1);
-    iic_delay(2);
-    YWGPIO_Write(SCL, 1); //I2C_SCL(1);
-    YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_INPUT);
-    iic_delay(3);
-    YWGPIO_Read(SDA, &nack);    //nack = I2C_READ();
-
+	YWGPIO_Write(SCL, 0); //I2C_SCL(0);
+	iic_delay(2);
+	YWGPIO_Write(SDA, 1); //I2C_SDA(1);
+	iic_delay(2);
+	YWGPIO_Write(SCL, 1); //I2C_SCL(1);
+	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_INPUT);
+	iic_delay(3);
+	YWGPIO_Read(SDA, &nack);    //nack = I2C_READ();
 	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_BIDIRECTIONAL);
-
-    YWGPIO_Write(SCL, 0); //2C_SCL(0);
-    iic_delay(2);
-
-    return(nack);	/* not a nack is an ack */
+	YWGPIO_Write(SCL, 0); //2C_SCL(0);
+	iic_delay(2);
+	return (nack);  /* not a nack is an ack */
 }
 
-static U8 i2csoft_readbyte(YWGPIO_Handle_T SCL,YWGPIO_Handle_T SDA,int ack)
+static U8 i2csoft_readbyte(YWGPIO_Handle_T SCL, YWGPIO_Handle_T SDA, int ack)
 {
 	U8  data;
 	int  j;
-    U8  Value;
-
+	U8  Value;
 	data = 0;
-    YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_BIDIRECTIONAL);
-    YWGPIO_Write(SDA, 1); //I2C_SDA(1);
-
-    YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_INPUT);
-    //printk("!!!!:");
-	for(j = 0; j < 8; j++)
-    {
-        iic_delay(1);
+	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_BIDIRECTIONAL);
+	YWGPIO_Write(SDA, 1); //I2C_SDA(1);
+	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_INPUT);
+	//printk("!!!!:");
+	for (j = 0; j < 8; j++)
+	{
+		iic_delay(1);
 		YWGPIO_Write(SCL, 0); //I2C_SCL(0);
-        iic_delay(5);
+		iic_delay(5);
 		YWGPIO_Write(SCL, 1); //I2C_SCL(1);
-        iic_delay(3);
-        //Value = I2C_READ();
-        YWGPIO_Read(SDA, &Value);
-        iic_delay(2);
-        data = data<<1;
-        data = data|Value;
-        //printk("%d ",Value);
-        //iic_delay(100000);
-
-        //I2C_SCL(0);
+		iic_delay(3);
+		//Value = I2C_READ();
+		YWGPIO_Read(SDA, &Value);
+		iic_delay(2);
+		data = data << 1;
+		data = data | Value;
+		//printk("%d ",Value);
+		//iic_delay(100000);
+		//I2C_SCL(0);
 	}
-    //printk("\n");
-    YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_BIDIRECTIONAL);
-    YWGPIO_Write(SCL, 0); //I2C_SCL(0);
-    iic_delay(2);
-
-    //YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_OUTPUT);
-
-	i2csoft_sendack(SCL,SDA,ack);
-	return(data);
+	//printk("\n");
+	YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_BIDIRECTIONAL);
+	YWGPIO_Write(SCL, 0); //I2C_SCL(0);
+	iic_delay(2);
+	//YWGPIO_SetIoMode(SDA, YWGPIO_IO_MODE_OUTPUT);
+	i2csoft_sendack(SCL, SDA, ack);
+	return (data);
 }
 
-static int  i2c_gpio_read(U8 SlaveAddr,U8 *buffer, int len,int timeout,YWI2CSoft_Device_t *I2CSoftDevice)
+static int  i2c_gpio_read(U8 SlaveAddr, U8 *buffer, int len, int timeout, YWI2CSoft_Device_t *I2CSoftDevice)
 {
 	//int shift;
 	//int ack;
-    int i;
+	int i;
 #if 0
-    while(timeout--)
-    {
-        i2csoft_sendstart(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
-        //write_byte(SoftI2c.SlaveAddr +1);	/* send cycle */
-
-        //if(write_byte(SlaveAddr+1)) //ACK
-        if(!i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr+1)) //ACK
-        {
-            break;
-        }
-
-    	i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
-        iic_delay(10);
-    }
-
-    if(timeout == 0)
-    {
-        printk("read error\n");
-    	return(-1);
-    }
+	while (timeout--)
+	{
+		i2csoft_sendstart(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
+		//write_byte(SoftI2c.SlaveAddr +1); /* send cycle */
+		//if(write_byte(SlaveAddr+1)) //ACK
+		if (!i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr + 1)) //ACK
+		{
+			break;
+		}
+		i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
+		iic_delay(10);
+	}
+	if (timeout == 0)
+	{
+		printk("read error\n");
+		return (-1);
+	}
 #endif
-    i2csoft_sendstart(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
-    i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr+1);
-
-    //printk("len = %d :",len);
-    for(i=0;i<(len-1);i++)
-    {
-        buffer[i] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 0);
-        //printk("0x%x ",buffer[i]);
-    }
-    buffer[len-1] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 1);
-    //printk("0x%x ",buffer[len-1]);
-    //printk("\n");
-
+	i2csoft_sendstart(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
+	i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr + 1);
+	//printk("len = %d :",len);
+	for (i = 0; i < (len - 1); i++)
+	{
+		buffer[i] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 0);
+		//printk("0x%x ",buffer[i]);
+	}
+	buffer[len - 1] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 1);
+	//printk("0x%x ",buffer[len-1]);
+	//printk("\n");
 	i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
-	return(0);
+	return (0);
 }
 
-int i2c_gpio_write(U8 SlaveAddr,U8 *buffer, int len,int timeout,YWI2CSoft_Device_t *I2CSoftDevice)
+int i2c_gpio_write(U8 SlaveAddr, U8 *buffer, int len, int timeout, YWI2CSoft_Device_t *I2CSoftDevice)
 {
 	int failures = 0;
-
-	i2csoft_sendstart(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
+	i2csoft_sendstart(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
 	//if(write_byte(SoftI2c.SlaveAddr)) //send slave addr receive ack
-        //printk("0x%x ", SlaveAddr);
-	if(i2csoft_writebyte(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle, SlaveAddr)) //send slave addr receive ack
-    {   /* write cycle */
+	//printk("0x%x ", SlaveAddr);
+	if (i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr)) //send slave addr receive ack
+	{
+		/* write cycle */
 		//send_stop();
-        i2csoft_sendstop(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
+		i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
 		YWI2C_DEBUG(("i2c_write, no chip responded \n"));
-		return(-1);
+		return (-1);
 	}
-
-    while(len-- > 0)
-    {
-        //printk("0x%x ", *buffer++);
-        if(i2csoft_writebyte(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle, *buffer++))
-        {
+	while (len-- > 0)
+	{
+		//printk("0x%x ", *buffer++);
+		if (i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, *buffer++))
+		{
 			failures++;
-        }
+		}
 	}
-    //printk("\n");
-
-	i2csoft_sendstop(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
-
-	return(failures);
+	//printk("\n");
+	i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
+	return (failures);
 }
 
-static int  i2c_gpio_readnostop(U8 SlaveAddr,U8 *buffer, int len,int timeout,YWI2CSoft_Device_t *I2CSoftDevice)
+static int  i2c_gpio_readnostop(U8 SlaveAddr, U8 *buffer, int len, int timeout, YWI2CSoft_Device_t *I2CSoftDevice)
 {
 	//int shift;
 	//int ack;
-    int i;
+	int i;
 #if 0
-    while(timeout--)
-    {
-        i2csoft_sendstart(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
-        //write_byte(SoftI2c.SlaveAddr +1);	/* send cycle */
-
-        //if(write_byte(SlaveAddr+1)) //ACK
-        if(!i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr+1)) //ACK
-        {
-            break;
-        }
-
-    	i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
-        iic_delay(10);
-    }
-
-    if(timeout == 0)
-    {
-        printk("read error\n");
-    	return(-1);
-    }
+	while (timeout--)
+	{
+		i2csoft_sendstart(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
+		//write_byte(SoftI2c.SlaveAddr +1); /* send cycle */
+		//if(write_byte(SlaveAddr+1)) //ACK
+		if (!i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr + 1)) //ACK
+		{
+			break;
+		}
+		i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
+		iic_delay(10);
+	}
+	if (timeout == 0)
+	{
+		printk("read error\n");
+		return (-1);
+	}
 #endif
-    i2csoft_sendstart(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
-    i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr+1);
-
-    //printk("len = %d :",len);
-    for(i=0;i<(len-1);i++)
-    {
-        buffer[i] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 0);
-        //printk("0x%x ",buffer[i]);
-    }
-    buffer[len-1] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 1);
-    //printk("0x%x ",buffer[len-1]);
-    //printk("\n");
-
+	i2csoft_sendstart(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
+	i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr + 1);
+	//printk("len = %d :",len);
+	for (i = 0; i < (len - 1); i++)
+	{
+		buffer[i] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 0);
+		//printk("0x%x ",buffer[i]);
+	}
+	buffer[len - 1] = i2csoft_readbyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, 1);
+	//printk("0x%x ",buffer[len-1]);
+	//printk("\n");
 	//i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
-	return(0);
+	return (0);
 }
 
-int  i2c_gpio_writenostop(U8 SlaveAddr,U8 *buffer, int len,int timeout,YWI2CSoft_Device_t *I2CSoftDevice)
+int  i2c_gpio_writenostop(U8 SlaveAddr, U8 *buffer, int len, int timeout, YWI2CSoft_Device_t *I2CSoftDevice)
 {
 	int failures = 0;
-
-	i2csoft_sendstart(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
+	i2csoft_sendstart(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
 	//if(write_byte(SoftI2c.SlaveAddr)) //send slave addr receive ack
-	if(i2csoft_writebyte(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle, SlaveAddr)) //send slave addr receive ack
-    {   /* write cycle */
+	if (i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, SlaveAddr)) //send slave addr receive ack
+	{
+		/* write cycle */
 		//send_stop();
-        i2csoft_sendstop(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
+		i2csoft_sendstop(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle);
 		YWI2C_DEBUG(("i2c_write, no chip responded \n"));
-		return(1);
+		return (1);
 	}
-
-    while(len-- > 0)
-    {
-        if(i2csoft_writebyte(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle, *buffer++))
-        {
+	while (len-- > 0)
+	{
+		if (i2csoft_writebyte(I2CSoftDevice->SCLHandle, I2CSoftDevice->SDAHandle, *buffer++))
+		{
 			failures++;
-        }
+		}
 	}
-
 	//i2csoft_sendstop(I2CSoftDevice->SCLHandle,I2CSoftDevice->SDAHandle);
-
-	return(failures);
+	return (failures);
 }
 
-YW_ErrorType_T i2c_soft_init (char *DeviceName, YWI2cSoft_InitParam_t *InitParam)
+YW_ErrorType_T i2c_soft_init(char *DeviceName, YWI2cSoft_InitParam_t *InitParam)
 {
-    int                     i;
-    YWGPIO_OpenParams_T     GpioOpenParams;
-    YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-    if(DeviceName ==NULL || InitParam == NULL)
-    {
-        return YWHAL_ERROR_BAD_PARAMETER;
-    }
-
-    if(IsI2CAlreadyInitialised(DeviceName))
-    {
-        return YWHAL_ERROR_ALREADY_INITIALIZED;
-    }
-
-    for(i=0;i<YWI2CSOFT_MAX_DEVICE;i++)
-    {
-        if(I2CSoftDevice[i].IsInit == FALSE)
-        {
-            break;
-        }
-    }
-
-    if(i == YWI2CSOFT_MAX_DEVICE)
-    {
-        return YWHAL_ERROR_NOT_ENOUGH_DEVICE;
-    }
-
-    YWLIB_Memset(&(I2CSoftDevice[i]), 0, sizeof(YWI2CSoft_Device_t));
-    YWLIB_Strcpy((S8 *)I2CSoftDevice[i].I2CName, (S8 *)DeviceName);
-
-    GpioOpenParams.GpioIndex    = InitParam->SCLPioIndex;
-    GpioOpenParams.IoMode       = YWGPIO_IO_MODE_OUTPUT;
-    GpioOpenParams.WorkMode     = YWGPIO_WORK_MODE_PRIMARY;
-    GpioOpenParams.PrivateData  = NULL;
-    ErrorType = YWGPIO_Open(&(I2CSoftDevice[i].SCLHandle), &GpioOpenParams);
-    ErrorType |= YWGPIO_Write(I2CSoftDevice[i].SCLHandle, 1);
-    if(ErrorType != YW_NO_ERROR)
-    {
-        YWI2C_DEBUG(("%s,%d\n",__FILE__,__LINE__));
-        return ErrorType;
-    }
-
-    GpioOpenParams.GpioIndex    = InitParam->SDAPioIndex;
-    GpioOpenParams.IoMode       = YWGPIO_IO_MODE_OUTPUT;
-    GpioOpenParams.WorkMode     = YWGPIO_WORK_MODE_PRIMARY;
-    GpioOpenParams.PrivateData  = NULL;
-    ErrorType = YWGPIO_Open(&(I2CSoftDevice[i].SDAHandle), &GpioOpenParams);
-    ErrorType |= YWGPIO_Write(I2CSoftDevice[i].SDAHandle, 1);
-    if(ErrorType != YW_NO_ERROR)
-    {
-		YWI2C_DEBUG(("%s,%d\n",__FILE__,__LINE__));
-
-        YWGPIO_Close(I2CSoftDevice[i].SCLHandle);
-        return ErrorType;
-    }
-
-    ErrorType = YWOS_SemaphoreCreate((S8 *)"SOFTI2C_LOCK", 1, &I2CSoftDevice[i].SoftI2cLock);
-    if(ErrorType != YW_NO_ERROR)
-    {
-        YWGPIO_Close(I2CSoftDevice[i].SDAHandle);
-        YWGPIO_Close(I2CSoftDevice[i].SCLHandle);
-        return ErrorType;
-    }
-
-    I2CSoftDevice[i].Speed      = InitParam->Speed;
-    I2CSoftDevice[i].IsInit     = TRUE;
-
-
-    i2csoft_lock(i);
-	i2csoft_reset(I2CSoftDevice[i].SCLHandle,I2CSoftDevice[i].SDAHandle);
-    i2csoft_unlock(i);
-
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-
-    return YW_NO_ERROR;
+	int                     i;
+	YWGPIO_OpenParams_T     GpioOpenParams;
+	YW_ErrorType_T          ErrorType = YW_NO_ERROR;
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (DeviceName == NULL || InitParam == NULL)
+	{
+		return YWHAL_ERROR_BAD_PARAMETER;
+	}
+	if (IsI2CAlreadyInitialised(DeviceName))
+	{
+		return YWHAL_ERROR_ALREADY_INITIALIZED;
+	}
+	for (i = 0; i < YWI2CSOFT_MAX_DEVICE; i++)
+	{
+		if (I2CSoftDevice[i].IsInit == FALSE)
+		{
+			break;
+		}
+	}
+	if (i == YWI2CSOFT_MAX_DEVICE)
+	{
+		return YWHAL_ERROR_NOT_ENOUGH_DEVICE;
+	}
+	YWLIB_Memset(&(I2CSoftDevice[i]), 0, sizeof(YWI2CSoft_Device_t));
+	YWLIB_Strcpy((S8 *)I2CSoftDevice[i].I2CName, (S8 *)DeviceName);
+	GpioOpenParams.GpioIndex    = InitParam->SCLPioIndex;
+	GpioOpenParams.IoMode       = YWGPIO_IO_MODE_OUTPUT;
+	GpioOpenParams.WorkMode     = YWGPIO_WORK_MODE_PRIMARY;
+	GpioOpenParams.PrivateData  = NULL;
+	ErrorType = YWGPIO_Open(&(I2CSoftDevice[i].SCLHandle), &GpioOpenParams);
+	ErrorType |= YWGPIO_Write(I2CSoftDevice[i].SCLHandle, 1);
+	if (ErrorType != YW_NO_ERROR)
+	{
+		YWI2C_DEBUG(("%s,%d\n", __FILE__, __LINE__));
+		return ErrorType;
+	}
+	GpioOpenParams.GpioIndex    = InitParam->SDAPioIndex;
+	GpioOpenParams.IoMode       = YWGPIO_IO_MODE_OUTPUT;
+	GpioOpenParams.WorkMode     = YWGPIO_WORK_MODE_PRIMARY;
+	GpioOpenParams.PrivateData  = NULL;
+	ErrorType = YWGPIO_Open(&(I2CSoftDevice[i].SDAHandle), &GpioOpenParams);
+	ErrorType |= YWGPIO_Write(I2CSoftDevice[i].SDAHandle, 1);
+	if (ErrorType != YW_NO_ERROR)
+	{
+		YWI2C_DEBUG(("%s,%d\n", __FILE__, __LINE__));
+		YWGPIO_Close(I2CSoftDevice[i].SCLHandle);
+		return ErrorType;
+	}
+	ErrorType = YWOS_SemaphoreCreate((S8 *)"SOFTI2C_LOCK", 1, &I2CSoftDevice[i].SoftI2cLock);
+	if (ErrorType != YW_NO_ERROR)
+	{
+		YWGPIO_Close(I2CSoftDevice[i].SDAHandle);
+		YWGPIO_Close(I2CSoftDevice[i].SCLHandle);
+		return ErrorType;
+	}
+	I2CSoftDevice[i].Speed      = InitParam->Speed;
+	I2CSoftDevice[i].IsInit     = TRUE;
+	i2csoft_lock(i);
+	i2csoft_reset(I2CSoftDevice[i].SCLHandle, I2CSoftDevice[i].SDAHandle);
+	i2csoft_unlock(i);
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
 }
 
-
 YW_ErrorType_T i2c_soft_term(char *DeviceName)
 {
-    int                     i;
-    YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-
-    if(DeviceName ==NULL )
-    {
-        return YWHAL_ERROR_BAD_PARAMETER;
-    }
-
-    if(IsI2CAlreadyInitialised(DeviceName)== FALSE)
-    {
-        return YWHAL_ERROR_ALREADY_INITIALIZED;
-    }
-
-    for(i=0;i<YWI2CSOFT_MAX_DEVICE;i++) //find device
-    {
-        if(I2CSoftDevice[i].IsInit == TRUE)
-        {
-            break;
-        }
-    }
-
-    if(i == YWI2CSOFT_MAX_DEVICE)
-    {
-        return YWHAL_ERROR_NOT_ENOUGH_DEVICE;
-    }
-
-    ErrorType = YWGPIO_Close(I2CSoftDevice[i].SDAHandle);
-    ErrorType |= YWGPIO_Close(I2CSoftDevice[i].SCLHandle);
-    ErrorType |= YWOS_SemaphoreDelete(I2CSoftDevice[i].SoftI2cLock);
-
-
-    YWLIB_Memset(&(I2CSoftDevice[i]), 0, sizeof(YWI2CSoft_Device_t));
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-
-    return YW_NO_ERROR;
+	int                     i;
+	YW_ErrorType_T          ErrorType = YW_NO_ERROR;
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (DeviceName == NULL)
+	{
+		return YWHAL_ERROR_BAD_PARAMETER;
+	}
+	if (IsI2CAlreadyInitialised(DeviceName) == FALSE)
+	{
+		return YWHAL_ERROR_ALREADY_INITIALIZED;
+	}
+	for (i = 0; i < YWI2CSOFT_MAX_DEVICE; i++) //find device
+	{
+		if (I2CSoftDevice[i].IsInit == TRUE)
+		{
+			break;
+		}
+	}
+	if (i == YWI2CSOFT_MAX_DEVICE)
+	{
+		return YWHAL_ERROR_NOT_ENOUGH_DEVICE;
+	}
+	ErrorType = YWGPIO_Close(I2CSoftDevice[i].SDAHandle);
+	ErrorType |= YWGPIO_Close(I2CSoftDevice[i].SCLHandle);
+	ErrorType |= YWOS_SemaphoreDelete(I2CSoftDevice[i].SoftI2cLock);
+	YWLIB_Memset(&(I2CSoftDevice[i]), 0, sizeof(YWI2CSoft_Device_t));
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
 }
 
-YW_ErrorType_T i2c_soft_open(char *DeviceName,YWI2CSoft_Handle_t *Handle,YWI2cSoft_OpenParams_t *OpenParam)
+YW_ErrorType_T i2c_soft_open(char *DeviceName, YWI2CSoft_Handle_t *Handle, YWI2cSoft_OpenParams_t *OpenParam)
 {
-    int                     i,j;
+	int                     i, j;
 //    YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-
-    if(DeviceName == NULL || OpenParam== NULL)
-    {
-        return YWHAL_ERROR_BAD_PARAMETER;
-    }
-
-    if(IsI2CAlreadyInitialised(DeviceName)== FALSE)
-    {
-        return YWHAL_ERROR_ALREADY_INITIALIZED;
-    }
-
-    for(i=0;i<YWI2CSOFT_MAX_DEVICE;i++) //find device
-    {
-        if((I2CSoftDevice[i].IsInit)&&(YWLIB_Strcmp((S8 *)DeviceName, (S8 *)I2CSoftDevice[i].I2CName)==0))
-        {
-            break;
-        }
-    }
-
-    if(i == YWI2CSOFT_MAX_DEVICE)
-    {
-        return YWHAL_ERROR_NOT_ENOUGH_DEVICE;
-    }
-
-
-    for(j=0;j<YWI2CSOFT_MAX_HANDLE;j++)
-    {
-        if(I2CSoftDevice[i].OpenParam[j].IsOpen == FALSE)
-        {
-            break;
-        }
-    }
-
-    if(i == YWI2CSOFT_MAX_HANDLE)
-    {
-        return YWHAL_ERROR_FEATURE_NOT_SUPPORTED;
-    }
-
-    YWOS_SemaphoreWait(I2CSoftDevice[i].SoftI2cLock, YWOS_WAIT_INFINITY);
-
-    I2CSoftDevice[i].OpenParam[j].SlaveAddr = OpenParam->I2cAddress;
-    I2CSoftDevice[i].OpenParam[j].IsOpen    = TRUE;
-    *Handle                                 = (YWI2CSoft_Handle_t)(&I2CSoftDevice[i].OpenParam[j]);
-    YWOS_SemaphoreSend(I2CSoftDevice[i].SoftI2cLock);
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-
-    return YW_NO_ERROR;
-
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (DeviceName == NULL || OpenParam == NULL)
+	{
+		return YWHAL_ERROR_BAD_PARAMETER;
+	}
+	if (IsI2CAlreadyInitialised(DeviceName) == FALSE)
+	{
+		return YWHAL_ERROR_ALREADY_INITIALIZED;
+	}
+	for (i = 0; i < YWI2CSOFT_MAX_DEVICE; i++) //find device
+	{
+		if ((I2CSoftDevice[i].IsInit) && (YWLIB_Strcmp((S8 *)DeviceName, (S8 *)I2CSoftDevice[i].I2CName) == 0))
+		{
+			break;
+		}
+	}
+	if (i == YWI2CSOFT_MAX_DEVICE)
+	{
+		return YWHAL_ERROR_NOT_ENOUGH_DEVICE;
+	}
+	for (j = 0; j < YWI2CSOFT_MAX_HANDLE; j++)
+	{
+		if (I2CSoftDevice[i].OpenParam[j].IsOpen == FALSE)
+		{
+			break;
+		}
+	}
+	if (i == YWI2CSOFT_MAX_HANDLE)
+	{
+		return YWHAL_ERROR_FEATURE_NOT_SUPPORTED;
+	}
+	YWOS_SemaphoreWait(I2CSoftDevice[i].SoftI2cLock, YWOS_WAIT_INFINITY);
+	I2CSoftDevice[i].OpenParam[j].SlaveAddr = OpenParam->I2cAddress;
+	I2CSoftDevice[i].OpenParam[j].IsOpen    = TRUE;
+	*Handle                                 = (YWI2CSoft_Handle_t)(&I2CSoftDevice[i].OpenParam[j]);
+	YWOS_SemaphoreSend(I2CSoftDevice[i].SoftI2cLock);
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
 }
 
 YW_ErrorType_T i2c_soft_close(YWI2CSoft_Handle_t Handle)
 {
-    //YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-    U32                     DeviceIndex,HandleIndex;
-    YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t   *)Handle;
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-
-
-    if(!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex) )
-    {
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    if(!Param->IsOpen)
-    {
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    i2csoft_lock(DeviceIndex);
-
-    I2CSoftDevice[DeviceIndex].OpenParam[HandleIndex].IsOpen = FALSE;
-
-    i2csoft_unlock(DeviceIndex);
-
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-
-    return YW_NO_ERROR;
+	//YW_ErrorType_T          ErrorType = YW_NO_ERROR;
+	U32                     DeviceIndex, HandleIndex;
+	YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t *)Handle;
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex))
+	{
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	if (!Param->IsOpen)
+	{
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	i2csoft_lock(DeviceIndex);
+	I2CSoftDevice[DeviceIndex].OpenParam[HandleIndex].IsOpen = FALSE;
+	i2csoft_unlock(DeviceIndex);
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
 }
 
 YW_ErrorType_T i2c_soft_read(YWI2CSoft_Handle_t Handle,
-                                U8              *Buffer_p,
-                                U32             MaxLen,
-                                U32             Timeout,
-                                U32             *ActLen_p)
-{
-    int                     ret;
-    //YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-    U32                     DeviceIndex,HandleIndex;
-    YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t   *)Handle;
-
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-    if(!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex) )
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    if(!Param->IsOpen)
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    i2csoft_lock(DeviceIndex);
-
-    ret = i2c_gpio_read(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
-
-    i2csoft_unlock(DeviceIndex);
-
-    *ActLen_p = ret;
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-
-
-    return YW_NO_ERROR;
-
+			     U8              *Buffer_p,
+			     U32             MaxLen,
+			     U32             Timeout,
+			     U32             *ActLen_p)
+{
+	int                     ret;
+	//YW_ErrorType_T          ErrorType = YW_NO_ERROR;
+	U32                     DeviceIndex, HandleIndex;
+	YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t *)Handle;
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex))
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	if (!Param->IsOpen)
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	i2csoft_lock(DeviceIndex);
+	ret = i2c_gpio_read(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
+	i2csoft_unlock(DeviceIndex);
+	*ActLen_p = ret;
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
 }
 
 YW_ErrorType_T i2c_soft_write(YWI2CSoft_Handle_t Handle,
-                                U8              *Buffer_p,
-                                U32             MaxLen,
-                                U32             Timeout,
-                                U32             *ActLen_p)
-{
-    int                     ret;
-    //YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-    U32                     DeviceIndex,HandleIndex;
-    YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t   *)Handle;
-
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-
-    if(!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex) )
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    if(!Param->IsOpen)
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    i2csoft_lock(DeviceIndex);
+			      U8              *Buffer_p,
+			      U32             MaxLen,
+			      U32             Timeout,
+			      U32             *ActLen_p)
+{
+	int                     ret;
+	//YW_ErrorType_T          ErrorType = YW_NO_ERROR;
+	U32                     DeviceIndex, HandleIndex;
+	YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t *)Handle;
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex))
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	if (!Param->IsOpen)
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	i2csoft_lock(DeviceIndex);
 #if 0
 	{
 		int i;
 		for (i = 0; i < MaxLen; i++)
 		{
-		    printk("0x%x ", Buffer_p[i]);
+			printk("0x%x ", Buffer_p[i]);
 		}
 		printk("\n");
-    }
+	}
 #endif  /* 0 */
-
-    ret = i2c_gpio_write(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
-
-    i2csoft_unlock(DeviceIndex);
-
+	ret = i2c_gpio_write(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
+	i2csoft_unlock(DeviceIndex);
 	if (ret < 0)
 	{
-    	return YWHAL_ERROR_FEATURE_NOT_SUPPORTED;
+		return YWHAL_ERROR_FEATURE_NOT_SUPPORTED;
 	}
-    *ActLen_p = MaxLen - ret;
-
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-    return YW_NO_ERROR;
-
+	*ActLen_p = MaxLen - ret;
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
 }
 
 YW_ErrorType_T i2c_soft_readnostop(YWI2CSoft_Handle_t Handle,
-                                U8              *Buffer_p,
-                                U32             MaxLen,
-                                U32             Timeout,
-                                U32             *ActLen_p)
-{
-    int                     ret;
-    //YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-    U32                     DeviceIndex,HandleIndex;
-    YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t   *)Handle;
-
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-    if(!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex) )
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    if(!Param->IsOpen)
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    i2csoft_lock(DeviceIndex);
-
-    ret = i2c_gpio_readnostop(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
-
-    i2csoft_unlock(DeviceIndex);
-
-    *ActLen_p = ret;
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-
-
-    return YW_NO_ERROR;
+				   U8              *Buffer_p,
+				   U32             MaxLen,
+				   U32             Timeout,
+				   U32             *ActLen_p)
+{
+	int                     ret;
+	//YW_ErrorType_T          ErrorType = YW_NO_ERROR;
+	U32                     DeviceIndex, HandleIndex;
+	YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t *)Handle;
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex))
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	if (!Param->IsOpen)
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	i2csoft_lock(DeviceIndex);
+	ret = i2c_gpio_readnostop(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
+	i2csoft_unlock(DeviceIndex);
+	*ActLen_p = ret;
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
 }
 
 YW_ErrorType_T i2c_soft_writenostop(YWI2CSoft_Handle_t Handle,
-                                U8              *Buffer_p,
-                                U32             MaxLen,
-                                U32             Timeout,
-                                U32             *ActLen_p)
-{
-    int                     ret;
-    //YW_ErrorType_T          ErrorType = YW_NO_ERROR;
-    U32                     DeviceIndex,HandleIndex;
-    YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t   *)Handle;
-
-    YWI2C_INTERFACE(("%s line:%d in\n",__FUNCTION__,__LINE__));
-
-    if(!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex) )
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    if(!Param->IsOpen)
-    {
-        YWI2C_DEBUG(("%s %d\n",__FUNCTION__,__LINE__));
-        return YWHAL_ERROR_INVALID_HANDLE;
-    }
-
-    i2csoft_lock(DeviceIndex);
-    //printk("Param->SlaveAddr=0x%x DeviceIndex=0x%x\n",Param->SlaveAddr,DeviceIndex);
-    ret = i2c_gpio_writenostop(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
-
-    i2csoft_unlock(DeviceIndex);
-
-    *ActLen_p = ret;
-
-    YWI2C_INTERFACE(("%s line:%d OUT\n",__FUNCTION__,__LINE__));
-    return YW_NO_ERROR;    return YW_NO_ERROR;
+				    U8              *Buffer_p,
+				    U32             MaxLen,
+				    U32             Timeout,
+				    U32             *ActLen_p)
+{
+	int                     ret;
+	//YW_ErrorType_T          ErrorType = YW_NO_ERROR;
+	U32                     DeviceIndex, HandleIndex;
+	YWI2CSoft_OpenParam_t   *Param = (YWI2CSoft_OpenParam_t *)Handle;
+	YWI2C_INTERFACE(("%s line:%d in\n", __FUNCTION__, __LINE__));
+	if (!CheckI2cParam(Handle, &DeviceIndex, &HandleIndex))
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	if (!Param->IsOpen)
+	{
+		YWI2C_DEBUG(("%s %d\n", __FUNCTION__, __LINE__));
+		return YWHAL_ERROR_INVALID_HANDLE;
+	}
+	i2csoft_lock(DeviceIndex);
+	//printk("Param->SlaveAddr=0x%x DeviceIndex=0x%x\n",Param->SlaveAddr,DeviceIndex);
+	ret = i2c_gpio_writenostop(Param->SlaveAddr, Buffer_p, MaxLen, Timeout, &(I2CSoftDevice[DeviceIndex]));
+	i2csoft_unlock(DeviceIndex);
+	*ActLen_p = ret;
+	YWI2C_INTERFACE(("%s line:%d OUT\n", __FUNCTION__, __LINE__));
+	return YW_NO_ERROR;
+	return YW_NO_ERROR;
 }
 
-I2CDeviceName_T         SoftI2c_DeviceName[YWI2C_NUM_SOFT_I2C]={"SOFT_I2C0"};
+I2CDeviceName_T         SoftI2c_DeviceName[YWI2C_NUM_SOFT_I2C] = {"SOFT_I2C0"};
 
 int softi2c_init(void)
 {
-    int ret = 0;
-    YW_ErrorType_T              YW_ErrorCode = YW_NO_ERROR;
-
-    //printk("%s >\n", __func__);
-    {
-        YWI2cSoft_InitParam_t InitParam;
-
-        InitParam.IsSlaveDevice = FALSE;
-        InitParam.SCLPioIndex   = GPIO_SIMULATE_I2C_SCL_PORT * PIO_BITS +
-									GPIO_SIMULATE_I2C_SCL_BIT;
-        InitParam.SDAPioIndex   = GPIO_SIMULATE_I2C_SDA_PORT * PIO_BITS +
-									GPIO_SIMULATE_I2C_SDA_BIT;
-        InitParam.Speed         = 100000;
-
-        YWI2C_INTERFACE(("InitParam.SCLPioIndex = %d\n", InitParam.SCLPioIndex));
-        YWI2C_INTERFACE(("InitParam.SDAPioIndex = %d\n", InitParam.SDAPioIndex));
-
-        YW_ErrorCode = i2c_soft_init(SoftI2c_DeviceName[0], &InitParam);
-    	if (YW_ErrorCode != YW_NO_ERROR)
-    	{
-    		YWOSTRACE(("[ERROR][YWI2C_Init]init soft failed\n"));
-    		return YW_ErrorCode;
-    	}
-    }
-
-    {
-        YWI2CSoft_Handle_t          SoftHandle;
-        YWI2cSoft_OpenParams_t      OpenParam;
-
-        OpenParam.I2cAddress        = 0x50;
-        YW_ErrorCode = i2c_soft_open(SoftI2c_DeviceName[0], &SoftHandle, &OpenParam);
+	int ret = 0;
+	YW_ErrorType_T              YW_ErrorCode = YW_NO_ERROR;
+	//printk("%s >\n", __func__);
+	{
+		YWI2cSoft_InitParam_t InitParam;
+		InitParam.IsSlaveDevice = FALSE;
+		InitParam.SCLPioIndex   = GPIO_SIMULATE_I2C_SCL_PORT * PIO_BITS +
+					  GPIO_SIMULATE_I2C_SCL_BIT;
+		InitParam.SDAPioIndex   = GPIO_SIMULATE_I2C_SDA_PORT * PIO_BITS +
+					  GPIO_SIMULATE_I2C_SDA_BIT;
+		InitParam.Speed         = 100000;
+		YWI2C_INTERFACE(("InitParam.SCLPioIndex = %d\n", InitParam.SCLPioIndex));
+		YWI2C_INTERFACE(("InitParam.SDAPioIndex = %d\n", InitParam.SDAPioIndex));
+		YW_ErrorCode = i2c_soft_init(SoftI2c_DeviceName[0], &InitParam);
+		if (YW_ErrorCode != YW_NO_ERROR)
+		{
+			YWOSTRACE(("[ERROR][YWI2C_Init]init soft failed\n"));
+			return YW_ErrorCode;
+		}
+	}
+	{
+		YWI2CSoft_Handle_t          SoftHandle;
+		YWI2cSoft_OpenParams_t      OpenParam;
+		OpenParam.I2cAddress        = 0x50;
+		YW_ErrorCode = i2c_soft_open(SoftI2c_DeviceName[0], &SoftHandle, &OpenParam);
 		//printk("SoftHandle = 0x%x\n", (int)SoftHandle);
-        if (YW_ErrorCode == YW_NO_ERROR)
-        {
+		if (YW_ErrorCode == YW_NO_ERROR)
+		{
 			g_SoftHandle = SoftHandle;
-        }
-        else
-        {
-            YWOSTRACE(( "[ERROR][YWI2C_Open]I2C Open[%d] failed ! Error %d\n",
-            			0, YW_ErrorCode));
-       	 	return (YW_ErrorCode);
-        }
-
-    }
-
+		}
+		else
+		{
+			YWOSTRACE(("[ERROR][YWI2C_Open]I2C Open[%d] failed ! Error %d\n", 0, YW_ErrorCode));
+			return (YW_ErrorCode);
+		}
+	}
 #if 0
 	{
 		U32 ActLen = 0;
 		U8 aBuffer[2] = { 0xff, 0xff};
-
 		i2c_soft_write(g_SoftHandle, aBuffer, 2, 100, &ActLen);
 		printk("ActLen = %d\n", ActLen);
 	}
 #endif  /* 0 */
-
-    //printk("%s < %d\n", __func__, ret);
-    return ret;
+	//printk("%s < %d\n", __func__, ret);
+	return ret;
 }
 
-bool isofti2c_write(U8 *Buffer_p, U32 MaxLen)
+int isofti2c_write(U8 *Buffer_p, U32 MaxLen)
 {
 	U32 ActLen = 0;
-	YW_ErrorType_T	errType = YW_NO_ERROR;
-
+	YW_ErrorType_T  errType = YW_NO_ERROR;
 	i2c_soft_write(g_SoftHandle, Buffer_p, MaxLen, 100, &ActLen);
 	//printk("ActLen = %d\n", ActLen);
 	if (errType != YW_NO_ERROR)
 	{
-	    return FALSE;
+		return FALSE;
 	}
 	if (ActLen != MaxLen)
 	{
-	    return FALSE;
+		return FALSE;
 	}
 	return TRUE;
 }
 
-bool isofti2c_read(U8 *Buffer_p, U32 MaxLen)
+int isofti2c_read(U8 *Buffer_p, U32 MaxLen)
 {
 	U32 ActLen = 0;
-
 	i2c_soft_read(g_SoftHandle, Buffer_p, MaxLen, 100, &ActLen);
-
 	return TRUE;
 }
 
-bool softi2c_online(void)
+int softi2c_online(void)
 {
-	bool bRet = FALSE;
+	int bRet = FALSE;
 	U8 aBuffer[2] = { 0xff, 0xff};
-
 	bRet = isofti2c_write(aBuffer, 2);
-
 	return bRet;
 }
 
 void softi2c_cleanup(void)
 {
 	YW_ErrorType_T              YW_ErrorCode = YW_NO_ERROR;
-
-    //printk("%s >\n", __func__);
+	//printk("%s >\n", __func__);
+	{
+		YW_ErrorCode = i2c_soft_close(g_SoftHandle);
+	}
 	{
-        YW_ErrorCode = i2c_soft_close(g_SoftHandle);
-    }
-    {
-        YW_ErrorCode = i2c_soft_term(SoftI2c_DeviceName[0]);
-        if(YW_ErrorCode != YW_NO_ERROR)
-        {
-            YWOSTRACE(("[ERROR][YWI2C_Term] YWI2C_Term failed ! Error\n"));
-        }
-    }
-    //printk("%s <\n", __func__);
+		YW_ErrorCode = i2c_soft_term(SoftI2c_DeviceName[0]);
+		if (YW_ErrorCode != YW_NO_ERROR)
+		{
+			YWOSTRACE(("[ERROR][YWI2C_Term] YWI2C_Term failed ! Error\n"));
+		}
+	}
+	//printk("%s <\n", __func__);
 }
 
 #endif /*CONFIG_CPU_SUBTYPE_STX7105*/
diff -Naur a/frontcontroller/aotom/aotom_i2csoft.h b/frontcontroller/aotom/aotom_i2csoft.h
--- a/frontcontroller/aotom/aotom_i2csoft.h	2017-05-01 20:31:14.714295282 +0200
+++ b/frontcontroller/aotom/aotom_i2csoft.h	2017-05-02 14:19:36.516095782 +0200
@@ -1,25 +1,25 @@
-#ifndef __AOTOM_I2CSOFT_H__
-#define __AOTOM_I2CSOFT_H__
-
-typedef unsigned int YWI2CSoft_Handle_t;
-
-typedef struct  YWI2cSoft_InitParam_s
-{
-	bool IsSlaveDevice;
-	unsigned int SCLPioIndex;
-	unsigned int SDAPioIndex;
-	unsigned int Speed;
-} YWI2cSoft_InitParam_t;
-
-typedef struct YWI2cSoft_OpenParams_s
-{
-	unsigned short I2cAddress;
-} YWI2cSoft_OpenParams_t;
-
-int  softi2c_init(void);
-void softi2c_cleanup(void);
-bool softi2c_online(void);
-bool isofti2c_write(unsigned char *Buffer_p, u32 MaxLen);
-bool isofti2c_read(unsigned char *Buffer_p, u32 MaxLen);
-
-#endif /* __AOTOM_I2CSOFT_H__ */
+#ifndef __AOTOM_I2CSOFT_H__
+#define __AOTOM_I2CSOFT_H__
+
+typedef unsigned int YWI2CSoft_Handle_t;
+
+typedef struct  YWI2cSoft_InitParam_s
+{
+	int IsSlaveDevice;
+	unsigned int SCLPioIndex;
+	unsigned int SDAPioIndex;
+	unsigned int Speed;
+} YWI2cSoft_InitParam_t;
+
+typedef struct YWI2cSoft_OpenParams_s
+{
+	unsigned short I2cAddress;
+} YWI2cSoft_OpenParams_t;
+
+int  softi2c_init(void);
+void softi2c_cleanup(void);
+int softi2c_online(void);
+int isofti2c_write(unsigned char *Buffer_p, u32 MaxLen);
+int isofti2c_read(unsigned char *Buffer_p, u32 MaxLen);
+
+#endif /* __AOTOM_I2CSOFT_H__ */
diff -Naur a/frontcontroller/aotom/aotom_main.c b/frontcontroller/aotom/aotom_main.c
--- a/frontcontroller/aotom/aotom_main.c	2017-05-01 20:31:14.715295257 +0200
+++ b/frontcontroller/aotom/aotom_main.c	2017-05-02 14:21:10.572613549 +0200
@@ -1,8 +1,11 @@
 /*
- * aotom.c
+ * aotom_main.c
  *
  * (c) 2010 Spider-Team
  * (c) 2011 oSaoYa
+ * (c) 2012-2013 Stefan Seyfried
+ * (c) 2012-2013 martii
+ * (c) 2014 skl
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,11 +27,10 @@
  * fulan front panel driver.
  *
  * Devices:
- *	- /dev/vfd (vfd ioctls and read/write function)
+ *  - /dev/vfd (vfd ioctls and read/write function)
  *
  */
 
-
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/termbits.h>
@@ -36,6 +38,8 @@
 #include <linux/version.h>
 #include <linux/input.h>
 #include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
@@ -44,619 +48,740 @@
 #include <linux/time.h>
 #include <linux/poll.h>
 #include <linux/workqueue.h>
-#include <linux/proc_fs.h>
-
-#include <linux/device.h> /* class_creatre */
+/* for RTC / reboot_notifier hooks */
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/rtc.h>
+#include <linux/platform_device.h>
 
+#include "aotom_ywdefs.h"
 #include "aotom_main.h"
 
 static short paramDebug = 0;
 #define TAGDEBUG "[aotom] "
 
 #define dprintk(level, x...) do { \
-if ((paramDebug) && (paramDebug >= level)) printk(TAGDEBUG x); \
-} while (0)
+		if ((paramDebug) && (paramDebug > level)) printk(TAGDEBUG x); \
+	} while (0)
+
+#define DISPLAYWIDTH_MAX 8
 
-#define INVALID_KEY    	-1
-#define LOG_OFF     	0
-#define LOG_ON      	1
+#define NO_KEY_PRESS    -1
+#define KEY_PRESS_DOWN   1
+#define KEY_PRESS_UP     0
 
-static ushort mode_digit = DIGITNO;
 static char *gmt = "+0000";
 
-#define NAME_NODE "display_type"
-#define NAME_DIR "aotom"
-	
-struct proc_dir_entry *own_proc_dir;
-struct proc_dir_entry *own_proc_node;
+static int open_count = 0;
 
-typedef struct
-{
-	struct file*      fp;
-	int               read;
-	struct semaphore  sem;
+#define FRONTPANEL_MINOR_VFD    0
 
-} tFrontPanelOpen;
+tLedState led_state[LED_COUNT + 1];
+static int led_count = LED_COUNT;
 
-#define FRONTPANEL_MINOR_RC             1
-#define LASTMINOR                 	    2
+static struct semaphore write_sem;
+static struct semaphore draw_thread_sem;
 
-static tFrontPanelOpen FrontPanelOpen [LASTMINOR];
+#define RTC_NAME "aotom-rtc"
+static struct platform_device *rtc_pdev;
 
-#define BUFFERSIZE                256     //must be 2 ^ n
+extern YWPANEL_Version_t panel_version;
 
-struct receive_s
+static int VFD_Show_Time(u8 hh, u8 mm)
 {
-   int           len;
-   unsigned char buffer[BUFFERSIZE];
-};
-
-#define cMaxReceiveQueue	100
-static wait_queue_head_t   wq;
-
-struct receive_s receive[cMaxReceiveQueue];
-static int receiveCount = 0;
+	if ((hh > 24) || (mm > 59))
+	{
+		dprintk(2, "%s bad parameter!\n", __func__);
+		return -1;
+	}
+	return YWPANEL_FP_SetTime(hh * 3600 + mm * 60);
+}
 
-struct semaphore 	   write_sem;
-struct semaphore 	   rx_int_sem; /* unused until the irq works */
-struct semaphore 	   transmit_sem;
-struct semaphore 	   receive_sem;
-//struct semaphore 	   key_mutex;
+static int VFD_Show_Icon(int which, int on)
+{
+	return YWPANEL_VFD_ShowIcon(which, on);
+}
 
-//static struct semaphore  display_sem;
+static struct task_struct *draw_task = 0;
+#define DRAW_THREAD_STATUS_RUNNING  0
+#define DRAW_THREAD_STATUS_STOPPED  1
+#define DRAW_THREAD_STATUS_INIT     2
+static int draw_thread_status = DRAW_THREAD_STATUS_STOPPED;
 
-struct saved_data_s
-{
-	int   length;
-	char  data[BUFFERSIZE];
-};
+int aotomSetIcon(int which, int on);
+int aotomSetLed(int which, int on);
 
-static struct saved_data_s lastdata;
+int vfdlen_open(struct inode *inode, struct  file *file) {
+  return single_open(file, vfdlen_show, NULL);
+}
 
-/* last received ioctl command. we dont queue answers
- * from "getter" requests to the fp. they are protected
- * by a semaphore and the threads goes to sleep until
- * the answer has been received or a timeout occurs.
- */
+int vfdlen_show(struct seq_file *m, void *v) {
+  seq_printf(m, "%d\n", YWPANEL_width);
+  return 0;
+}
 
+static const struct file_operations vfdlen_fops = {
+  .owner = THIS_MODULE,
+  .open = vfdlen_open,
+  .read = seq_read,
+  .llseek = seq_lseek,
+  .release = single_release,
+};
 
-static int VFD_Show_Time(u8 hh, u8 mm)
+static void clear_display(void)
 {
-    if( (hh > 24) || (mm > 59))
-    {
-    	dprintk(2, "%s bad parameter!\n", __func__);
-    	return -1;
-    }
+	YWPANEL_VFD_ShowString("        ");
+}
 
-    return YWPANEL_FP_SetTime(hh*3600 + mm*60);
+static void VFD_set_all_icons(int onoff)
+{
+	int i;
+	for (i = 1; i < 46; i++)
+		aotomSetIcon(i, onoff);
 }
 
-static int VFD_Show_Ico(LogNum_T log_num, int log_stat)
+static void VFD_clr(void)
 {
-	return YWPANEL_VFD_ShowIco(log_num, log_stat);
+	YWPANEL_VFD_ShowTimeOff();
+	clear_display();
+	VFD_set_all_icons(LED_OFF);
 }
 
-static struct task_struct *thread;
-static int thread_stop  = 1;
-int aotomSetIcon(int which, int on);
+int utf8charlen(unsigned char c)
+{
+	if (!c)
+		return 0;
+	if (!(c >> 7))      // 0xxxxxxx
+		return 1;
+	if (c >> 5 == 6)    // 110xxxxx 10xxxxxx
+		return 2;
+	if (c >> 4 == 14)   // 1110xxxx 10xxxxxx 10xxxxxx
+		return 3;
+	if (c >> 3 == 30)   // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+		return 4;
+	return 0;
+}
 
-void clear_display(void)
+int utf8strlen(char *s, int len)
 {
-	YWPANEL_VFD_ShowString("        ");
+	int i = 0, ulen = 0;
+	while (i < len)
+	{
+		int trailing = utf8charlen((unsigned char)s[i]);
+		if (!trailing)
+			return ulen;
+		trailing--, i++;
+		if (trailing && (i >= len))
+			return ulen;
+		while (trailing)
+		{
+			if (i >= len || (unsigned char)s[i] >> 6 != 2)
+				return ulen;
+			trailing--;
+			i++;
+		}
+		ulen++;
+	}
+	return ulen; // can be UTF8 (or pure ASCII, at least no non-UTF-8 8bit characters)
 }
 
-static void VFD_clr(void)
+static int draw_thread(void *arg)
 {
-	int i;
+	struct vfd_ioctl_data *data = (struct vfd_ioctl_data *) arg;
+	unsigned char buf[sizeof(data->data) + 2 * DISPLAYWIDTH_MAX];
+	int len = data->length;
+	int off = 0;
+	int saved = 0;
+	int utf8len = utf8strlen(data->data, data->length);
+	if ((panel_version.DisplayInfo == YWPANEL_FP_DISPTYPE_LED) && (len > 2) && (data->data[2] == '.' || data->data[2] == ','))
+		saved = 1;
+	if (utf8len - saved > YWPANEL_width)
+	{
+		memset(buf, ' ', sizeof(buf));
+		off = YWPANEL_width - 1;
+		memcpy(buf + off, data->data, len);
+		len += off;
+		utf8len += off;
+		buf[len + YWPANEL_width] = 0;
+	}
+	else
+	{
+		memcpy(buf, data->data, len);
+		buf[len] = 0;
+	}
+	draw_thread_status = DRAW_THREAD_STATUS_RUNNING;
+	if (utf8len - saved > YWPANEL_width)
+	{
+		unsigned char *b = buf;
+		int pos;
+		for (pos = 0; pos < utf8len; pos++)
+		{
+			int i;
+			char dot = 0;
+			if (kthread_should_stop())
+			{
+				draw_thread_status = DRAW_THREAD_STATUS_STOPPED;
+				return 0;
+			}
+			if ((panel_version.DisplayInfo == YWPANEL_FP_DISPTYPE_LED) && (b + 2 < buf + sizeof(buf)) && (b[2] == '.' || b[2] == ','))
+				dot = b[2];
+			if (dot)
+				b[2] = ' ';
+			YWPANEL_VFD_ShowString(b);
+			if (dot)
+				b[2] = dot;
+			// sleep 200 ms
+			for (i = 0; i < 5; i++)
+			{
+				if (kthread_should_stop())
+				{
+					draw_thread_status = DRAW_THREAD_STATUS_STOPPED;
+					return 0;
+				}
+				msleep(40);
+			}
+			// advance to next UTF-8 character
+			b += utf8charlen(*b);
+		}
+	}
+	if (utf8len > 0)
+		YWPANEL_VFD_ShowString(buf + off);
+	else
+		clear_display();
+	draw_thread_status = DRAW_THREAD_STATUS_STOPPED;
+	return 0;
+}
 
-	clear_display();
-	if (mode_digit == DIGIT8)
+static int led_thread(void *arg)
+{
+	int led = (int) arg;
+	// toggle LED status for a given time period
+	led_state[led].stop = 0;
+	while (!kthread_should_stop())
 	{
-	    YWPANEL_VFD_ShowTimeOff();
-	    for(i=1; i < 46; i++) aotomSetIcon(i, 0);
+		if (!down_interruptible(&led_state[led].led_sem))
+		{
+			if (kthread_should_stop())
+				break;
+			while (!down_trylock(&led_state[led].led_sem)); // make sure semaphore is at 0
+			YWPANEL_VFD_SetLed(led, !led_state[led].state);
+			while ((led_state[led].period > 0) && !kthread_should_stop())
+			{
+				msleep(10);
+				led_state[led].period -= 10;
+			}
+			// switch LED back to manually set state
+			YWPANEL_VFD_SetLed(led, led_state[led].state);
+		}
 	}
+	led_state[led].stop = 1;
+	led_state[led].led_task = 0;
+	return 0;
 }
 
-int draw_thread(void *arg)
+// Try "spark_fp -p 20 -l 2" ... --martii
+static int spinner_thread(void *arg)
 {
-  struct vfd_ioctl_data *data;
-  struct vfd_ioctl_data draw_data;
-  unsigned char buf[VFD_DATA_LEN];
-  int count = 0;
-  int pos = 0;
-
-  data = (struct vfd_ioctl_data *)arg;
-
-  draw_data.length = data->length;
-  memcpy(draw_data.data,data->data,data->length);
-
-  thread_stop = 0;
-
-  count = utf8_len(draw_data.data, draw_data.length);
-
-  if(count > mode_digit)
-  {
-    while(pos < draw_data.length)
-    {
-       int countb;
-
-       if(kthread_should_stop())
-       {
-    	   thread_stop = 1;
-    	   return 0;
-       }
-
-       countb = utf8_count(&draw_data.data[pos], draw_data.length - pos, 8);
-       clear_display();
-       memcpy(buf, &draw_data.data[pos], countb);
-       buf[countb] = '\0';
-       YWPANEL_VFD_ShowString(buf);
-       msleep(200);
-       if (draw_data.data[pos] > 128)
-       {
-           pos += 2;
-       } else {
-           pos += 1;
-       }
-    }
-  }
-
-  if(count > 0)
-  {
-      int countb = utf8_count(&draw_data.data[0], draw_data.length, 8);
-      clear_display();
-      memcpy(buf, draw_data.data, countb);
-      buf[countb] = '\0';
-      YWPANEL_VFD_ShowString(buf);
-  }
-  else VFD_clr();
+	int led = (int) arg;
+	// enable DISK_S0, periodically enable S1, S2, S3 until stopped
+	led_state[led].stop = 0;
+	while (!kthread_should_stop())
+	{
+		if (!down_interruptible(&led_state[led].led_sem))
+		{
+			int i = 0;
+			if (kthread_should_stop())
+				break;
+			while (!down_trylock(&led_state[led].led_sem));
+			YWPANEL_VFD_ShowIcon(AOTOM_DISK_S0, LED_ON);
+			while ((led_state[led].period > 0) && !kthread_should_stop())
+			{
+				int period = led_state[led].period;
+				YWPANEL_VFD_ShowIcon(AOTOM_DISK_S1, i == 0);
+				YWPANEL_VFD_ShowIcon(AOTOM_DISK_S2, i == 1);
+				YWPANEL_VFD_ShowIcon(AOTOM_DISK_S3, i == 2);
+				i++;
+				i %= 3;
+				while ((period > 0) && (led_state[led].period > 0) && !kthread_should_stop())
+				{
+					msleep(10);
+					period -= 10;
+				}
+			}
+			YWPANEL_VFD_ShowIcon(AOTOM_DISK_S0, LED_OFF);
+			YWPANEL_VFD_ShowIcon(AOTOM_DISK_S1, LED_OFF);
+			YWPANEL_VFD_ShowIcon(AOTOM_DISK_S2, LED_OFF);
+			YWPANEL_VFD_ShowIcon(AOTOM_DISK_S3, LED_OFF);
+		}
+	}
+	led_state[led].stop = 1;
+	led_state[led].led_task = 0;
+	return 0;
+}
 
-  thread_stop = 1;
-  return 0;
+static struct vfd_ioctl_data last_draw_data;
+
+static int run_draw_thread(struct vfd_ioctl_data *draw_data)
+{
+	if (down_interruptible(&draw_thread_sem))
+		return -ERESTARTSYS;
+	// return if there is already a draw task running for the same text
+	if ((draw_thread_status != DRAW_THREAD_STATUS_STOPPED) && draw_task && (last_draw_data.length == draw_data->length) && !memcmp(&last_draw_data.data, draw_data->data, draw_data->length))
+	{
+		up(&draw_thread_sem);
+		return 0;
+	}
+	memcpy(&last_draw_data, draw_data, sizeof(struct vfd_ioctl_data));
+	// stop existing thread, if any
+	if ((draw_thread_status != DRAW_THREAD_STATUS_STOPPED) && draw_task)
+	{
+		kthread_stop(draw_task);
+		while (draw_thread_status != DRAW_THREAD_STATUS_STOPPED)
+			msleep(1);
+	}
+	draw_thread_status = DRAW_THREAD_STATUS_INIT;
+	draw_task = kthread_run(draw_thread, draw_data, "draw_thread");
+	//wait until thread has copied the argument
+	while (draw_thread_status == DRAW_THREAD_STATUS_INIT)
+		msleep(1);
+	up(&draw_thread_sem);
+	return 0;
 }
 
-int run_draw_thread(struct vfd_ioctl_data *draw_data)
+int aotomSetTime(char *time)
 {
-    if(!thread_stop)
-      kthread_stop(thread);
+	int res = 0;
+	dprintk(5, "%s >\n", __func__);
+	dprintk(5, "%s time: %02d:%02d\n", __func__, time[2], time[3]);
+	res = VFD_Show_Time(time[2], time[3]);
+	YWPANEL_FP_ControlTimer(true);
+	dprintk(5, "%s <\n", __func__);
+	return res;
+}
 
-    //wait thread stop
-    while(!thread_stop)
-    {msleep(50);}
-
-    if (draw_data->length < mode_digit) {
-        char buf[DIGIT8 + 1];
-        memset(buf, ' ', sizeof(buf) - 1);
-        buf[sizeof(buf)-1] = '\0';
-        if (draw_data->length)
-            memcpy(buf, draw_data->data, draw_data->length);
-        YWPANEL_VFD_ShowString(buf);
-    } else {
-        thread_stop = 2;
-        thread=kthread_run(draw_thread,draw_data,"draw thread");
-
-        //wait thread run
-        while(thread_stop == 2)
-        {msleep(50);}
-    }
-    return 0;
-}
-
-static int AOTOMfp_Get_Key_Value(void)
-{
-	int ret, key_val = INVALID_KEY;
-
-	ret =  YWPANEL_VFD_GetKeyValue();
-
-	switch(ret)
-	{
-        case 105:
-            key_val = KEY_LEFT;
-            break;
-        case 103:
-            key_val = KEY_UP;
-            break;
-        case 28:
-            key_val = KEY_OK;
-            break;
-        case 106:
-            key_val = KEY_RIGHT;
-            break;
-        case 108:
-            key_val = KEY_DOWN;
-            break;
-        case 88:
-            key_val = KEY_POWER;
-            break;
-        case 102:
-            key_val = KEY_MENU;
-            break;
-//        case 48:
-//            key_val = KEY_EXIT;
-//            break;
-        default:
-            key_val = INVALID_KEY;
-            break;
-    }
-
-	return key_val;
-}
-
-int aotomSetTime(char* time)
-{
-   int res = 0;
-
-   dprintk(5, "%s >\n", __func__);
-   dprintk(5, "%s time: %02d:%02d\n", __func__, time[2], time[3]);
-   res = VFD_Show_Time(time[2], time[3]);
-
-   if (mode_digit != DIGITNO)  YWPANEL_FP_ControlTimer(true);
-
-   dprintk(5, "%s <\n", __func__);
-   return res;
-}
-
-//int vfd_init_func(void)
-//{
-//	dprintk(5, "%s >\n", __func__);
-//	printk("Fulan VFD module initializing\n");
-//	return 0;
-//}
+int vfd_init_func(void)
+{
+	dprintk(5, "%s >\n", __func__);
+	printk("Fulan VFD module initializing\n");
+	return 0;
+}
 
 int aotomSetIcon(int which, int on)
 {
 	int  res = 0;
-
 	dprintk(5, "%s > %d, %d\n", __func__, which, on);
-	if (which < 1 || which > 45)
+	if (which < AOTOM_FIRST)   // sequential enumeration, starting at 1
+	{
+		which -= 1;
+		which = ((which / 15) + 11) * 16 + (which % 15) + 1;
+	}
+	if (which < AOTOM_FIRST || which > AOTOM_LAST)
 	{
 		printk("VFD/AOTOM icon number out of range %d\n", which);
 		return -EINVAL;
 	}
-
-	which-=1;
-	res = VFD_Show_Ico(((which/15)+11)*16+(which%15)+1, on);
-
+	res = VFD_Show_Icon(which, on);
 	dprintk(10, "%s <\n", __func__);
-
-   return res;
+	return res;
 }
 
-/* export for later use in e2_proc */
-EXPORT_SYMBOL(aotomSetIcon);
-
-static ssize_t AOTOMdev_write(struct file *filp, const char *buff, size_t len, loff_t *off)
+int aotomSetLed(int which, int on)
 {
-    int minor, vLoop, res = 0;
-
-    struct vfd_ioctl_data data;
-
-    dprintk(5, "%s > (len %d, offs %d)\n", __func__, len, (int) *off);
-
-    minor = -1;
-    for (vLoop = 0; vLoop < LASTMINOR; vLoop++) {
-	if (FrontPanelOpen[vLoop].fp == filp) {
-	    minor = vLoop;
+	int  res = 0;
+	dprintk(5, "%s > %d, %d\n", __func__, which, on);
+	if (which < 0 || which >= LED_COUNT)
+	{
+		printk("VFD/AOTOM led number out of range %d\n", which);
+		return -EINVAL;
+	}
+	if (led_state[which].enable) {
+		res = YWPANEL_VFD_SetLed(which,on);
+		led_state[which].state = on;
 	}
-    }
-
-    if (minor == -1) {
-	dprintk(0, "Error Bad Minor\n");
-	return -ENODEV;
-    }
-
-    dprintk(1, "minor = %d\n", minor);
-
-    if (minor == FRONTPANEL_MINOR_RC)
-	return -EOPNOTSUPP;
-
-    if (down_interruptible(&write_sem))
-	return -ERESTARTSYS;
-
-    data.length = len;
-    if (data.length > VFD_DATA_LEN)
-	data.length = VFD_DATA_LEN;
-
-    // get rid of trailing endline. could be if echo command used
-    if ((data.length > 0) && (buff[data.length - 1] == '\n'))
-	data.length--;
-
-    if (data.length <= 0) {
-	res = -1;
-	dprintk(2, "empty string\n");
-    }
-    else {
-	if (copy_from_user(data.data, buff, data.length))
-	    res = -EFAULT;
-	else
-	    res = run_draw_thread(&data);
-    }
-
-    up(&write_sem);
-
-    dprintk(10, "%s < res %d len %d\n", __func__, res, data.length);
-
-    if (res < 0)
 	return res;
-    else
-	return len;
 }
 
-static ssize_t AOTOMdev_read(struct file *filp, char __user *buff, size_t len, loff_t *off)
+int aotomEnableLed(int which, int on)
 {
-	int minor, vLoop;
-
-	dprintk(5, "%s > (len %d, offs %d)\n", __func__, len, (int) *off);
-
-	minor = -1;
-  	for (vLoop = 0; vLoop < LASTMINOR; vLoop++)
-  	{
-    		if (FrontPanelOpen[vLoop].fp == filp)
-    		{
-			    minor = vLoop;
-		   }
-	}
-
-	if (minor == -1)
+	int  res = 0;
+	if (which < 0 || which >= LED_COUNT)
 	{
-		printk("Error Bad Minor\n");
-		return -EUSERS;
+		printk("VFD/AOTOM led number out of range %d\n", which);
+		return -EINVAL;
 	}
+	led_state[which].enable = on;
+	return res;
+}
 
-	dprintk(1, "minor = %d\n", minor);
-
-	if (minor == FRONTPANEL_MINOR_RC)
-	{
-
-	  while (receiveCount == 0)
-	  {
-	    if (wait_event_interruptible(wq, receiveCount > 0))
-		    return -ERESTARTSYS;
-	  }
-
-	  /* 0. claim semaphore */
-	  down_interruptible(&receive_sem);
-
-	  /* 1. copy data to user */
-          copy_to_user(buff, receive[0].buffer, receive[0].len);
-
-	  /* 2. copy all entries to start and decreas receiveCount */
-	  receiveCount--;
-	  memmove(&receive[0], &receive[1], 99 * sizeof(struct receive_s));
+int aotomWriteText(char *buf, size_t len)
+{
+	int res = 0;
+	struct vfd_ioctl_data data;
+	if (len > sizeof(data.data))
+		data.length = sizeof(data.data);
+	else
+		data.length = len;
+	while ((data.length > 0) && (buf[data.length - 1 ] == '\n'))
+	  data.length--;
+	if (data.length > sizeof(data.data))
+		len = data.length = sizeof(data.data);
+	memcpy(data.data, buf, data.length);
+	res = run_draw_thread(&data);
+	if (res < 0)
+		return res;
+	return len;
+}
 
-	  /* 3. free semaphore */
-	  up(&receive_sem);
+int aotomSetBrightness(int level)
+{
+	int  res = 0;
+	dprintk(5, "%s > %d\n", __func__, level);
+	if (level < 0)
+		level = 0;
+	else if (level > 7)
+		level = 7;
+	res = YWPANEL_VFD_SetBrightness(level);
+	return res;
+}
 
-	  return 8;
-	}
+int aotomGetVersion()
+{
+	return panel_version.DisplayInfo;
+}
 
-	/* copy the current display string to the user */
- 	if (down_interruptible(&FrontPanelOpen[minor].sem))
-	{
-	   printk("%s return erestartsys<\n", __func__);
-	   return -ERESTARTSYS;
-	}
+/* export for later use in e2_proc */
+EXPORT_SYMBOL(aotomSetIcon);
+EXPORT_SYMBOL(aotomSetLed);
+EXPORT_SYMBOL(aotomWriteText);
+EXPORT_SYMBOL(aotomEnableLed);
+EXPORT_SYMBOL(aotomSetBrightness);
+EXPORT_SYMBOL(aotomGetVersion);
 
-	if (FrontPanelOpen[minor].read == lastdata.length)
+static ssize_t AOTOMdev_write(struct file *filp, const char *buff, size_t len, loff_t *off)
+{
+	char *kernel_buf;
+	int res = 0;
+	struct vfd_ioctl_data data;
+	dprintk(5, "%s > (len %d, offs %d)\n", __func__, len, (int) *off);
+	kernel_buf = kmalloc(len, GFP_KERNEL);
+	if (kernel_buf == NULL)
 	{
-	    FrontPanelOpen[minor].read = 0;
-
-	    up (&FrontPanelOpen[minor].sem);
-	    printk("%s return 0<\n", __func__);
-	    return 0;
+		printk("%s returns no memory <\n", __func__);
+		return -ENOMEM;
 	}
-
-	if (len > lastdata.length)
-		len = lastdata.length;
-
-	/* fixme: needs revision because of utf8! */
-	if (len > 16)
-		len = 16;
-
-	FrontPanelOpen[minor].read = len;
-	copy_to_user(buff, lastdata.data, len);
-
-	up (&FrontPanelOpen[minor].sem);
-
-	dprintk(10, "%s < (len %d)\n", __func__, len);
+	copy_from_user(kernel_buf, buff, len);
+	if (len > sizeof(data.data))
+		data.length = sizeof(data.data);
+	else
+		data.length = len;
+	while ((data.length > 0) && (kernel_buf[data.length - 1 ] == '\n'))
+		data.length--;
+	if (data.length > sizeof(data.data))
+		len = data.length = sizeof(data.data);
+	memcpy(data.data, kernel_buf, data.length);
+	res = run_draw_thread(&data);
+	kfree(kernel_buf);
+	dprintk(10, "%s < res %d len %d\n", __func__, res, len);
+	if (res < 0)
+		return res;
 	return len;
 }
 
-int AOTOMdev_open(struct inode *inode, struct file *filp)
+void flashLED(int led, int ms)
 {
-	int minor;
+	if (!led_state[led].led_task || (ms < 1 && led < LED_COUNT - 1))
+		return;
+	led_state[led].period = ms;
+	up(&led_state[led].led_sem);
+}
 
+static int AOTOMdev_open(struct inode *inode, struct file *filp)
+{
+	int minor;
 	dprintk(5, "%s >\n", __func__);
-
 	minor = MINOR(inode->i_rdev);
-
 	dprintk(1, "open minor %d\n", minor);
-
-  	if (FrontPanelOpen[minor].fp != NULL)
-  	{
-		dprintk(0, "EUSER\n");
-		return -EUSERS;
-  	}
-  	FrontPanelOpen[minor].fp = filp;
-  	FrontPanelOpen[minor].read = 0;
-
+	if (minor != FRONTPANEL_MINOR_VFD)
+		return -ENOTSUPP;
+	open_count++;
 	dprintk(5, "%s <\n", __func__);
 	return 0;
 }
 
-int AOTOMdev_close(struct inode *inode, struct file *filp)
+static int AOTOMdev_close(struct inode *inode, struct file *filp)
 {
 	int minor;
-
 	dprintk(5, "%s >\n", __func__);
-
-  	minor = MINOR(inode->i_rdev);
-
+	minor = MINOR(inode->i_rdev);
 	dprintk(1, "close minor %d\n", minor);
-
-  	if (FrontPanelOpen[minor].fp == NULL)
-	{
-		dprintk(0, "EUSER\n");
-		return -EUSERS;
-  	}
-	FrontPanelOpen[minor].fp = NULL;
-  	FrontPanelOpen[minor].read = 0;
-
+	if (open_count > 0)
+		open_count--;
 	dprintk(5, "%s <\n", __func__);
 	return 0;
 }
 
+static struct aotom_ioctl_data aotom_data;
 static struct vfd_ioctl_data vfd_data;
 
 static int AOTOMdev_ioctl(struct inode *Inode, struct file *File, unsigned int cmd, unsigned long arg)
 {
-    static int mode = 0;
-    struct aotom_ioctl_data * aotom = (struct aotom_ioctl_data *) arg;
-    int res = 0;
-
-    dprintk(5, "%s > 0x%.8x\n", __func__, cmd);
-
-    if (down_interruptible(&write_sem))
-	return -ERESTARTSYS;
-
-    switch (cmd) {
-	case VFDSETMODE:
-	    mode = aotom->u.mode.compat;
-	    break;
-	case VFDSETLED:
-	{
-	    if (mode_digit != DIGITNO) res = YWPANEL_VFD_SetLed(aotom->u.led.led_nr, aotom->u.led.on);
-	    break;
-	}
-	case VFDICONDISPLAYONOFF:
-	{
-//	    printk("aotom -->> %d = %d\n", aotom->u.icon.icon_nr, aotom->u.icon.on);
-	    if (mode_digit == DIGIT8) {
-		res = aotomSetIcon(aotom->u.icon.icon_nr, aotom->u.icon.on);
-	    }
-	    if (mode_digit == DIGIT4) {
-		switch (aotom->u.icon.icon_nr) {
-//		    case 0:
-//		    {
-//			struct vfd_ioctl_data * vfd = (struct vfd_ioctl_data *) arg;
-//			if (5 == vfd->length) {
-//			    if ((0x1e & 0xf) == vfd->data[0]) {
-//				res = YWPANEL_VFD_SetLed(0, vfd->data[4]);
-//			    }
-//			}
-//			break;
-//		    }
-		    case 35:
-			res = YWPANEL_VFD_SetLed(1, aotom->u.led.on);
-			break;
-		    default:
-			break;
-		}
-	    }
-	    mode = 0;
-	    break;
-	}
-	case VFDSTANDBY:
-	{
-	    if (mode_digit != DIGITNO) {
-		u32 uTime = 0;
-#if 0
-		u32 uStandByKey = 0;
-#endif
-		u32 uPowerOnTime = 0;
-		get_user(uTime, (int *) arg);
-		//printk("uTime = %d\n", uTime);
-
-		uPowerOnTime = YWPANEL_FP_GetPowerOnTime();
-		//printk("1uPowerOnTime = %d\n", uPowerOnTime);
-
-		YWPANEL_FP_SetPowerOnTime(uTime);
-
-		uPowerOnTime = YWPANEL_FP_GetPowerOnTime();
-		//printk("2uPowerOnTime = %d\n", uPowerOnTime);
-#if 0
-		uStandByKey = YWPANEL_FP_GetStandByKey(0);
-		printk("uStandByKey = %d\n", uStandByKey);
-		uStandByKey = YWPANEL_FP_GetStandByKey(1);
-		printk("uStandByKey = %d\n", uStandByKey);
-		uStandByKey = YWPANEL_FP_GetStandByKey(2);
-		printk("uStandByKey = %d\n", uStandByKey);
-		uStandByKey = YWPANEL_FP_GetStandByKey(3);
-		printk("uStandByKey = %d\n", uStandByKey);
-		uStandByKey = YWPANEL_FP_GetStandByKey(4);
-		printk("uStandByKey = %d\n", uStandByKey);
-#endif
-		YWPANEL_FP_ControlTimer(true);
-		YWPANEL_FP_SetCpuStatus(0x02);
-	    }
-	    break;
-	}
-	case VFDSETTIME:
-	    res = aotomSetTime((char *) arg);
-	    break;
-	case VFDGETTIME:
-	{
-	    if (mode_digit != DIGITNO) {
-		u32 uTime = 0;
-		uTime = YWPANEL_FP_GetTime();
-		//printk("uTime = %d\n", uTime);
-		put_user(uTime, (int *) arg);
-	    }
-	    break;
-	}
-	case VFDDISPLAYCHARS:
-	    if (mode == 0) {
-		if (copy_from_user(&vfd_data, (void *) arg, sizeof (vfd_data)))
-		    return -EFAULT;
-		if (vfd_data.length > sizeof (vfd_data.data))
-		    vfd_data.length = sizeof (vfd_data.data);
-		while ((vfd_data.length > 0) && (vfd_data.data[vfd_data.length - 1 ] == '\n'))
-		    vfd_data.length--;
-		res = run_draw_thread(&vfd_data);
-	    }
-	    mode = 0;
-	    break;
-	case VFDDISPLAYCLR:
-	    vfd_data.length = 0;
-	    res = run_draw_thread(&vfd_data);
-	    break;
-	case 0x5305:
-	    if (mode_digit == DIGIT4) {
-		dprintk(0, "unknown IOCTL 0x%x\n", cmd);
-		mode = 0;
-	    }
-	    break;
-	case VFDBRIGHTNESS:
-	    if (mode_digit == DIGIT8) YWPANEL_VFD_SetBrightness(aotom->u.brightness.level);
-	    break;
-	case VFDGETWAKEUPMODE:
-	case VFDDISPLAYWRITEONOFF:
-	case 0x5401:
-	    break;
-	default:
-	    dprintk(0, "unknown IOCTL 0x%x\n", cmd);
-	    mode = 0;
-	    break;
-    }
-
-    up(&write_sem);
-
-    dprintk(5, "%s <\n", __func__);
-    return res;
-}
-
-static unsigned int AOTOMdev_poll(struct file *filp, poll_table *wait)
-{
-  unsigned int mask = 0;
-
-  poll_wait(filp, &wq, wait);
-
-  if(receiveCount > 0)
-  {
-    mask = POLLIN | POLLRDNORM;
-  }
-
-  return mask;
+	static int mode = 0;
+	int res = -EINVAL;
+	dprintk(5, "%s > 0x%.8x\n", __func__, cmd);
+	if (down_interruptible(&write_sem))
+		return -ERESTARTSYS;
+	switch (cmd)
+	{
+		case VFDSETMODE:
+		case VFDSETLED:
+		case VFDICONDISPLAYONOFF:
+		case VFDSETTIME:
+		case VFDBRIGHTNESS:
+		case VFDGETSTBYKEY:
+		case VFDSETSTBYKEY:
+		case VFDGETBLUEKEY:
+		case VFDSETBLUEKEY:
+			if (copy_from_user(&aotom_data, (void *) arg, sizeof(aotom_data)))
+				return -EFAULT;
+	}
+	switch (cmd)
+	{
+		case VFDSETMODE:
+			mode = aotom_data.u.mode.compat;
+			break;
+		case VFDSETLED:
+			if (aotom_data.u.led.led_nr > -1 && aotom_data.u.led.led_nr < led_count)
+			{
+				switch (aotom_data.u.led.on)
+				{
+					case LED_OFF:
+					case LED_ON:
+						if (aotom_data.u.led.led_nr < LED_COUNT)
+						{
+							res = YWPANEL_VFD_SetLed(aotom_data.u.led.led_nr, aotom_data.u.led.on);
+							led_state[aotom_data.u.led.led_nr].state = aotom_data.u.led.on;
+							break;
+						}
+					default:
+						// led 0-1: toggle LED for <aotom_data.u.led.on * 10 ms>
+						// led 2:   set spinner segment time to <aotom_data.u.led.on * 10 ms> and enable spinner
+						if (aotom_data.u.led.led_nr < led_count)
+						{
+							flashLED(aotom_data.u.led.led_nr, aotom_data.u.led.on * 10);
+							res = 0;
+						}
+				}
+			}
+			break;
+		case VFDBRIGHTNESS:
+			if (aotom_data.u.brightness.level < 0)
+				aotom_data.u.brightness.level = 0;
+			else if (aotom_data.u.brightness.level > 7)
+				aotom_data.u.brightness.level = 7;
+			res = YWPANEL_VFD_SetBrightness(aotom_data.u.brightness.level);
+			break;
+		case VFDICONDISPLAYONOFF:
+			switch (panel_version.DisplayInfo)
+			{
+				case YWPANEL_FP_DISPTYPE_LED:
+					switch (aotom_data.u.icon.icon_nr)
+					{
+						case 0: // ?!?
+							res = YWPANEL_VFD_SetLed(LED_RED, aotom_data.u.icon.on);
+							led_state[LED_RED].state = aotom_data.u.icon.on;
+							break;
+						case AOTOM_DOT2:
+							res = YWPANEL_VFD_SetLed(LED_GREEN, aotom_data.u.icon.on);
+							led_state[LED_GREEN].state = aotom_data.u.icon.on;
+							break;
+						case 46:
+						case AOTOM_ALL:
+							led_state[LED_RED].state = aotom_data.u.icon.on;
+							led_state[LED_GREEN].state = aotom_data.u.icon.on;
+							YWPANEL_VFD_SetLed(LED_RED, aotom_data.u.icon.on);
+							res = YWPANEL_VFD_SetLed(LED_GREEN, aotom_data.u.icon.on);
+							break;
+					}
+					break;
+				default:
+				{
+					int icon_nr = aotom_data.u.icon.icon_nr;
+					if (icon_nr & ~0xff)
+					{
+						icon_nr >>= 8;
+						switch (icon_nr)
+						{
+							case 0x11:
+								icon_nr = AOTOM_DOUBLESCREEN;
+								break;
+							case 0x13:
+								icon_nr = AOTOM_CA;
+								break;
+							case 0x15:
+								icon_nr = AOTOM_MP3;
+								break;
+							case 0x17:
+								icon_nr = AOTOM_AC3;
+								break;
+							case 0x1A:
+								icon_nr = AOTOM_PLAY_LOG;
+								break;
+							case 0x1e:
+								icon_nr = AOTOM_REC1;
+								break;
+							case 38:
+								// AOTOM_DISK_S3
+								break; //cd part1
+							case 39:
+								// AOTOM_DISK_S2
+								break; //cd part2
+							case 40:
+								// AOTOM_DISK_S1
+								break; //cd part3
+							case 41:
+								// AOTOM_DISK_S0
+								break; //cd part4
+							default:
+								icon_nr = -1; //no additional symbols at the moment
+								break;
+						}
+					}
+					switch (icon_nr)
+					{
+						case 46:
+						case AOTOM_ALL:
+							VFD_set_all_icons(aotom_data.u.icon.on);
+							res = 0;
+						case -1:
+							break;
+						default:
+							res = aotomSetIcon(icon_nr, aotom_data.u.icon.on);
+					}
+				}
+				mode = 0;
+				break;
+			}
+			break;
+		case VFDSETPOWERONTIME:
+		{
+			u32 uTime = 0;
+			get_user(uTime, (int *) arg);
+			YWPANEL_FP_SetPowerOnTime(uTime);
+			res = 0;
+			break;
+		}
+		case VFDPOWEROFF:
+			clear_display();
+			YWPANEL_FP_ControlTimer(true);
+			YWPANEL_FP_SetCpuStatus(YWPANEL_CPUSTATE_STANDBY);
+			res = 0;
+			break;
+		case VFDSTANDBY:
+		{
+			u32 uTime = 0;
+			get_user(uTime, (int *) arg);
+			YWPANEL_FP_SetPowerOnTime(uTime);
+			clear_display();
+			YWPANEL_FP_ControlTimer(true);
+			YWPANEL_FP_SetCpuStatus(YWPANEL_CPUSTATE_STANDBY);
+			res = 0;
+			break;
+		}
+		case VFDSETTIME2:
+		{
+			u32 uTime = 0;
+			res = get_user(uTime, (int *)arg);
+			if (! res)
+			{
+				res = YWPANEL_FP_SetTime(uTime);
+				YWPANEL_FP_ControlTimer(true);
+			}
+			break;
+		}
+		case VFDSETTIME:
+			res = aotomSetTime(aotom_data.u.time.time);
+			break;
+		case VFDGETTIME:
+		{
+			u32 uTime = 0;
+			uTime = YWPANEL_FP_GetTime();
+			//printk("uTime = %d\n", uTime);
+			res = put_user(uTime, (int *) arg);
+			break;
+		}
+		case VFDDISPLAYCHARS:
+			if (mode == 0)
+			{
+				if (copy_from_user(&vfd_data, (void *) arg, sizeof(vfd_data)))
+					return -EFAULT;
+				if (vfd_data.length > sizeof(vfd_data.data))
+					vfd_data.length = sizeof(vfd_data.data);
+				while ((vfd_data.length > 0) && (vfd_data.data[vfd_data.length - 1 ] == '\n'))
+					vfd_data.length--;
+				res = run_draw_thread(&vfd_data);
+			}
+			else
+				mode = 0;
+			break;
+		case VFDDISPLAYCLR:
+			vfd_data.length = 0;
+			res = run_draw_thread(&vfd_data);
+			break;
+		case VFDGETWAKEUPMODE:
+		case VFDDISPLAYWRITEONOFF:
+			res = 0;
+			break;
+		case VFDGETSTARTUPSTATE:
+		{
+			YWPANEL_STARTUPSTATE_t State;
+			if (YWPANEL_FP_GetStartUpState(&State))
+				res = put_user(State, (int *) arg);
+			break;
+		}
+		case VFDSETLOOPSTATE:
+		{
+			YWPANEL_LOOPSTATE_t State = YWPANEL_LOOPSTATE_UNKNOWN;
+			res = get_user(State, (int *)arg);
+			if (!res)
+				res = YWPANEL_FP_SetLoopState(State);
+			break;
+		}
+		case VFDGETLOOPSTATE:
+		{
+			YWPANEL_LOOPSTATE_t State;
+			if (YWPANEL_FP_GetLoopState(&State))
+				res = put_user(State, (int *) arg);
+			break;
+		}
+		case VFDGETVERSION:
+		{
+			YWPANEL_Version_t panel_version;
+			memset(&panel_version, 0, sizeof(YWPANEL_Version_t));
+			if (YWPANEL_FP_GetVersion(&panel_version))
+				res = put_user(panel_version.DisplayInfo, (int *)arg);
+			break;
+		}
+		case VFDGETBLUEKEY:
+		case VFDGETSTBYKEY:
+		{
+			if (YWPANEL_FP_GetKey(cmd == VFDGETBLUEKEY, aotom_data.u.key.key_nr, &aotom_data.u.key.key))
+				res = copy_to_user((void *) arg, &aotom_data, sizeof(aotom_data));
+			break;
+		}
+		case VFDSETBLUEKEY:
+		case VFDSETSTBYKEY:
+			res = !YWPANEL_FP_SetKey(cmd == VFDSETBLUEKEY, aotom_data.u.key.key_nr, aotom_data.u.key.key);
+			break;
+		default:
+			printk("VFD/AOTOM: unknown IOCTL 0x%x\n", cmd);
+		case 0x5305:
+		case 0x5401:
+			mode = 0;
+			break;
+	}
+	up(&write_sem);
+	dprintk(5, "%s <\n", __func__);
+	return res;
 }
 
 static struct file_operations vfd_fops =
@@ -664,8 +789,6 @@
 	.owner = THIS_MODULE,
 	.ioctl = AOTOMdev_ioctl,
 	.write = AOTOMdev_write,
-	.read  = AOTOMdev_read,
-  	.poll  = (void*) AOTOMdev_poll,
 	.open  = AOTOMdev_open,
 	.release  = AOTOMdev_close
 };
@@ -674,68 +797,59 @@
 
 static char *button_driver_name = "fulan front panel buttons";
 static struct input_dev *button_dev;
-static int button_value = -1;
-static int bad_polling = 0;
+static int bad_polling = 1;
 static struct workqueue_struct *fpwq;
 
-struct semaphore button_sem;
-
 static void button_bad_polling(struct work_struct *work)
 {
 	int btn_pressed = 0;
 	int report_key = 0;
-
-	while(bad_polling == 1)
+	while (bad_polling == 1)
 	{
+		int button_value;
 		msleep(50);
-		button_value = AOTOMfp_Get_Key_Value();
-		if (button_value != INVALID_KEY) {
+		button_value = YWPANEL_VFD_GetKeyValue();
+		if (button_value != KEY_UNKNOWN)
+		{
 			dprintk(5, "got button: %X\n", button_value);
-			if (mode_digit == DIGIT8 ) VFD_Show_Ico(DOT2,LOG_ON);
-			else YWPANEL_VFD_SetLed(1, LOG_ON);
+			flashLED(LED_GREEN, 100);
 			if (1 == btn_pressed)
 			{
-				if (report_key != button_value)
-				{
-					input_report_key(button_dev, report_key, 0);
-					input_sync(button_dev);
-				}
-				else
-				{
-				    continue;
-				}
+				if (report_key == button_value)
+					continue;
+				input_report_key(button_dev, report_key, 0);
+				input_sync(button_dev);
 			}
 			report_key = button_value;
 			btn_pressed = 1;
-			switch(button_value) {
+			switch (button_value)
+			{
 				case KEY_LEFT:
 				case KEY_RIGHT:
 				case KEY_UP:
 				case KEY_DOWN:
 				case KEY_OK:
 				case KEY_MENU:
-				//case KEY_EXIT:
+				case KEY_EXIT:
 				case KEY_POWER:
 					input_report_key(button_dev, button_value, 1);
 					input_sync(button_dev);
 					break;
 				default:
-					dprintk(5, "[BTN] unknown button_value?\n");
+					dprintk(5, "[BTN] unknown button_value %d\n", button_value);
 			}
 		}
-		else {
-			if(btn_pressed) {
+		else
+		{
+			if (btn_pressed)
+			{
 				btn_pressed = 0;
-				msleep(80);
-				if (mode_digit == DIGIT8 ) VFD_Show_Ico(DOT2,LOG_OFF);
-				else YWPANEL_VFD_SetLed(1, LOG_OFF);
 				input_report_key(button_dev, report_key, 0);
 				input_sync(button_dev);
 			}
 		}
 	}
-	up(&button_sem);
-
+	bad_polling = 2;
 }
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
@@ -745,177 +859,262 @@
 #endif
 static int button_input_open(struct input_dev *dev)
 {
-	if (down_interruptible(&button_sem))
-	{
-		dprintk(0, "[BTN] ERROR workqueue already running\n");
-		return 1;
-	}
-
-	bad_polling = 1;
 	fpwq = create_workqueue("button");
-
-	if(queue_work(fpwq, &button_obj))
+	if (queue_work(fpwq, &button_obj))
 	{
 		dprintk(5, "[BTN] queue_work successful ...\n");
+		return 0;
 	}
-	else
-	{
-		dprintk(5, "[BTN] queue_work not successful, exiting ...\n");
-		return 1;
-	}
-
-	return 0;
+	dprintk(5, "[BTN] queue_work not successful, exiting ...\n");
+	return 1;
 }
 
 static void button_input_close(struct input_dev *dev)
 {
-
 	bad_polling = 0;
-	down(&button_sem);
-
+	while (bad_polling != 2)
+		msleep(1);
+	bad_polling = 1;
 	if (fpwq)
 	{
 		destroy_workqueue(fpwq);
 		dprintk(5, "[BTN] workqueue destroyed\n");
 	}
-	up(&button_sem);
 }
 
-int button_dev_init(void)
+static int button_dev_init(void)
 {
 	int error;
-
 	dprintk(5, "[BTN] allocating and registering button device\n");
-
 	button_dev = input_allocate_device();
 	if (!button_dev)
 		return -ENOMEM;
-
 	button_dev->name = button_driver_name;
 	button_dev->open = button_input_open;
-	button_dev->close= button_input_close;
-
-
-	set_bit(EV_KEY		, button_dev->evbit );
-	set_bit(KEY_UP		, button_dev->keybit);
-	set_bit(KEY_DOWN	, button_dev->keybit);
-	set_bit(KEY_LEFT	, button_dev->keybit);
-	set_bit(KEY_RIGHT	, button_dev->keybit);
-	set_bit(KEY_POWER	, button_dev->keybit);
-	set_bit(KEY_MENU	, button_dev->keybit);
-	set_bit(KEY_OK		, button_dev->keybit);
-	//set_bit(KEY_EXIT	, button_dev->keybit);
-
+	button_dev->close = button_input_close;
+	set_bit(EV_KEY    , button_dev->evbit);
+	set_bit(KEY_UP    , button_dev->keybit);
+	set_bit(KEY_DOWN  , button_dev->keybit);
+	set_bit(KEY_LEFT  , button_dev->keybit);
+	set_bit(KEY_RIGHT , button_dev->keybit);
+	set_bit(KEY_POWER , button_dev->keybit);
+	set_bit(KEY_MENU  , button_dev->keybit);
+	set_bit(KEY_OK    , button_dev->keybit);
+	set_bit(KEY_EXIT  , button_dev->keybit);
 	error = input_register_device(button_dev);
-	if (error) {
+	if (error)
 		input_free_device(button_dev);
-		return error;
+	return error;
+}
+
+static void button_dev_exit(void)
+{
+	dprintk(5, "[BTN] unregistering button device\n");
+	input_unregister_device(button_dev);
+}
+
+static int aotom_reboot_event(struct notifier_block *nb, unsigned long event, void *ptr)
+{
+	switch (event)
+	{
+		case SYS_POWER_OFF:
+			YWPANEL_VFD_ShowString("POWEROFF");
+			break;
+		case SYS_HALT:
+			YWPANEL_VFD_ShowString("HALT");
+			break;
+		default:
+			YWPANEL_VFD_ShowString("REBOOT");
+			return NOTIFY_DONE;
 	}
+	msleep(1000);
+	clear_display();
+	YWPANEL_FP_ControlTimer(true);
+	YWPANEL_FP_SetCpuStatus(YWPANEL_CPUSTATE_STANDBY);
+	return NOTIFY_DONE;
+};
+
+static struct notifier_block aotom_reboot_block =
+{
+	.notifier_call = aotom_reboot_event,
+	.priority = INT_MAX,
+};
 
+static int aotom_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	u32 uTime = 0;
+	//printk("%s\n", __func__);
+	uTime = YWPANEL_FP_GetTime();
+	rtc_time_to_tm(uTime, tm);
 	return 0;
 }
 
-void button_dev_exit(void)
+static int tm2time(struct rtc_time *tm)
 {
-	dprintk(5, "[BTN] unregistering button device\n");
-	input_unregister_device(button_dev);
+	return mktime(tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
 }
 
-ssize_t proc_node_read(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+static int aotom_rtc_set_time(struct device *dev, struct rtc_time *tm)
 {
-    int len;
-   *eof = 1;
-   len=sprintf(buffer, "%d\n", mode_digit);
-   return len;
+	int res = 0;
+	//printk("%s\n", __func__);
+	u32 uTime = tm2time(tm);
+	res = YWPANEL_FP_SetTime(uTime);
+	YWPANEL_FP_ControlTimer(true);
+	return res;
 }
 
-#define DEVICE_NAME "vfd"
+static int aotom_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *al)
+{
+	return 0;
+}
+
+static int aotom_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *al)
+{
+	u32 a_time = 0;
+	if (al->enabled)
+		a_time = tm2time(&al->time);
+	printk(KERN_INFO "%s enabled:%d time: %d\n", __func__, al->enabled, a_time);
+	YWPANEL_FP_SetPowerOnTime(a_time);
+	return 0;
+}
+
+static const struct rtc_class_ops aotom_rtc_ops =
+{
+	.read_time  = aotom_rtc_read_time,
+	.set_time   = aotom_rtc_set_time,
+	.read_alarm = aotom_rtc_read_alarm,
+	.set_alarm  = aotom_rtc_set_alarm
+};
+
+static int __devinit aotom_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	/* I have no idea where the pdev comes from, but it needs the can_wakeup = 1
+	 * otherwise we don't get the wakealarm sysfs attribute... :-) */
+	pdev->dev.power.can_wakeup = 1;
+	rtc = rtc_device_register("aotom", &pdev->dev, &aotom_rtc_ops, THIS_MODULE);
+	printk(KERN_DEBUG "%s %p\n", __func__, rtc);
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+	printk(KERN_DEBUG "%s 2\n", __func__);
+	platform_set_drvdata(pdev, rtc);
+	return 0;
+}
+
+static int __devexit aotom_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+	printk(KERN_DEBUG "%s %p\n", __func__, rtc);
+	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct platform_driver aotom_rtc_driver =
+{
+	.probe = aotom_rtc_probe,
+	.remove = __devexit_p(aotom_rtc_remove),
+	.driver = {
+		.name   = RTC_NAME,
+		.owner  = THIS_MODULE
+	},
+};
+
+extern void create_proc_fp(void);
+extern void remove_proc_fp(void);
+
 static struct class *vfd_class = 0;
 
 static int __init aotom_init_module(void)
 {
 	int i;
-	
 	dprintk(5, "%s >\n", __func__);
-
 	printk("Fulan front panel driver\n");
-
-//	sema_init(&display_sem,1);
-	sema_init(&button_sem, 1);
-	if(YWPANEL_VFD_Init(&mode_digit)) {
+	if (YWPANEL_VFD_Init())
+	{
 		printk("unable to init module\n");
 		return -1;
 	}
-
 	VFD_clr();
-	if(button_dev_init() != 0)
+	if (button_dev_init() != 0)
 		return -1;
-
-	if (register_chrdev(VFD_MAJOR,DEVICE_NAME,&vfd_fops))
-		printk("unable to get major %d for VFD\n",VFD_MAJOR);
-
-	vfd_class = class_create(THIS_MODULE, DEVICE_NAME);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
-	device_create(vfd_class, NULL, MKDEV(VFD_MAJOR, 0), NULL, "vfd");
-	device_create(vfd_class, NULL, MKDEV(VFD_MAJOR, 1), NULL, "rc");
-#else
-	class_device_create(vfd_class, NULL, MKDEV(VFD_MAJOR, 0), NULL, "vfd", 0);
-	class_device_create(vfd_class, NULL, MKDEV(VFD_MAJOR, 1), NULL, "rc", 1);
-#endif
-
+	if (register_chrdev(VFD_MAJOR, "VFD", &vfd_fops))
+		printk("unable to get major %d for VFD\n", VFD_MAJOR);
+	vfd_class = class_create(THIS_MODULE, "VFD");
+	device_create(vfd_class, NULL, MKDEV(VFD_MAJOR,0), NULL, "dbox!oled0");
 	sema_init(&write_sem, 1);
-//	sema_init(&key_mutex, 1);
-
-	for (i = 0; i < LASTMINOR; i++)
-	    sema_init(&FrontPanelOpen[i].sem, 1);
-
-	own_proc_dir = create_proc_entry(NAME_DIR, S_IFDIR | S_IRWXUGO, NULL);
-	if (own_proc_dir == NULL ) {
-	    printk(KERN_ERR "can't create /proc/%s\n", NAME_DIR);
-	    return -ENOMEM;
-	}
-	dprintk(5, "Create /proc/%s\n", NAME_DIR);
-	own_proc_dir->gid =0 ;
-	
-	own_proc_node=create_proc_entry(NAME_NODE, S_IFREG | S_IRUGO | S_IWUGO, own_proc_dir);
-	if (own_proc_node == NULL ) {
-	    printk(KERN_ERR "can't create /proc/%s/%s\n", NAME_DIR, NAME_NODE);
-	    return -ENOMEM;
-	}
-	dprintk(5, "Create /proc/%s/%s\n", NAME_DIR, NAME_NODE);
-	own_proc_node->uid = 0;
-	own_proc_node->gid =0 ;
-	
-	own_proc_node->read_proc=proc_node_read;
-	
+	sema_init(&draw_thread_sem, 1);
+	for (i = 0; i < LED_COUNT; i++)
+	{
+		led_state[i].state = LED_OFF;
+		led_state[i].period = 0;
+		led_state[i].stop = 1;
+		led_state[i].enable = 1;
+		sema_init(&led_state[i].led_sem, 0);
+		led_state[i].led_task = kthread_run(led_thread, (void *) i, "led_thread");
+	}
+	if (panel_version.DisplayInfo == YWPANEL_FP_DISPTYPE_VFD)
+	{
+		led_state[led_count].state = LED_OFF;
+		led_state[led_count].period = 0;
+		led_state[led_count].stop = 1;
+		sema_init(&led_state[led_count].led_sem, 0);
+		led_state[led_count].led_task = kthread_run(spinner_thread, (void *) led_count, "spinner thread");
+		led_count++;
+	}
+	register_reboot_notifier(&aotom_reboot_block);
+	i = platform_driver_register(&aotom_rtc_driver);
+	if (i)
+		printk(KERN_ERR "%s platform_driver_register failed: %d\n", __func__, i);
+	else
+		rtc_pdev = platform_device_register_simple(RTC_NAME, -1, NULL, 0);
+	if (IS_ERR(rtc_pdev))
+		printk(KERN_ERR "%s platform_device_register_simple failed: %ld\n", __func__, PTR_ERR(rtc_pdev));
+	create_proc_fp();
 	dprintk(5, "%s <\n", __func__);
+	proc_create("vfdlen", 0, NULL, &vfdlen_fops);
 	return 0;
 }
 
+static int led_thread_active(void)
+{
+	int i;
+	for (i = 0; i < led_count; i++)
+		if (!led_state[i].stop && led_state[i].led_task)
+			return 0;
+	return -1;
+}
+
 static void __exit aotom_cleanup_module(void)
 {
-	remove_proc_entry(NAME_NODE, own_proc_dir);
-	dprintk(5, "Remove .../proc/%s\n", NAME_DIR);
-	remove_proc_entry(NAME_DIR, NULL);
-	dprintk(5, "Remove .../proc/%s/%s\n", NAME_DIR, NAME_NODE);
-	
+	int i;
+	unregister_reboot_notifier(&aotom_reboot_block);
+	platform_driver_unregister(&aotom_rtc_driver);
+	platform_set_drvdata(rtc_pdev, NULL);
+	platform_device_unregister(rtc_pdev);
+	if ((draw_thread_status != DRAW_THREAD_STATUS_STOPPED) && draw_task)
+		kthread_stop(draw_task);
+	for (i = 0; i < led_count; i++)
+		if (!led_state[i].stop && led_state[i].led_task)
+		{
+			up(&led_state[i].led_sem);
+			kthread_stop(led_state[i].led_task);
+		}
+	while ((draw_thread_status != DRAW_THREAD_STATUS_STOPPED) && led_thread_active())
+		msleep(1);
 	dprintk(5, "[BTN] unloading ...\n");
 	button_dev_exit();
-
-	//kthread_stop(time_thread);
-
-	unregister_chrdev(VFD_MAJOR,DEVICE_NAME);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
 	device_destroy(vfd_class, MKDEV(VFD_MAJOR, 0));
-	device_destroy(vfd_class, MKDEV(VFD_MAJOR, 1));
-#else
-	class_device_destroy(vfd_class, MKDEV(VFD_MAJOR, 0));
-	class_device_destroy(vfd_class, MKDEV(VFD_MAJOR, 1));
-#endif
+	class_unregister(vfd_class);
 	class_destroy(vfd_class);
-
-	
+	unregister_chrdev(VFD_MAJOR, "VFD");
+	YWPANEL_VFD_Term();
+	remove_proc_entry("vfdlen", NULL);
 	printk("Fulan front panel module unloading\n");
+
+	remove_proc_fp();
+
 }
 
 module_init(aotom_init_module);
@@ -924,12 +1123,9 @@
 module_param(paramDebug, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
 MODULE_PARM_DESC(paramDebug, "Debug Output 0=disabled >0=enabled(debuglevel)");
 
-module_param(gmt,charp,0);
+module_param(gmt, charp, 0);
 MODULE_PARM_DESC(gmt, "gmt offset (default +0000");
 
-module_param(mode_digit, ushort ,0);
-MODULE_PARM_DESC(mode_digit, "mode type (4-digit, 8-digit and icon) (default 4-digit)");
-
 MODULE_DESCRIPTION("VFD module for fulan boxes");
 MODULE_AUTHOR("Spider-Team, oSaoYa");
 MODULE_LICENSE("GPL");
diff -Naur a/frontcontroller/aotom/aotom_main.h b/frontcontroller/aotom/aotom_main.h
--- a/frontcontroller/aotom/aotom_main.h	2017-05-01 20:31:14.715295257 +0200
+++ b/frontcontroller/aotom/aotom_main.h	2017-05-02 14:21:10.573613522 +0200
@@ -1,11 +1,14 @@
 #ifndef __AOTOM_MAIN_H__
 #define __AOTOM_MAIN_H__
 
-#define VFD_MAJOR				147
-
-#define DIGITNO 0
-#define DIGIT4 4
-#define DIGIT8 8
+#define LED_OFF               0
+#define LED_ON                1
+#define LOG_OFF               LED_OFF // deprecated
+#define LOG_ON                LED_ON  // deprecated
+#define LED_RED               0
+#define LED_GREEN             1
+#define LED_COUNT             2
+#define LED_SPINNER           2
 
 #define VFDBRIGHTNESS         0xc0425a03
 #define VFDDRIVERINIT         0xc0425a08
@@ -13,46 +16,40 @@
 #define VFDDISPLAYWRITEONOFF  0xc0425a05
 #define VFDDISPLAYCHARS       0xc0425a00
 
+#define VFDGETBLUEKEY         0xc0425af1
+#define VFDSETBLUEKEY         0xc0425af2
+#define VFDGETSTBYKEY         0xc0425af3
+#define VFDSETSTBYKEY         0xc0425af4
+#define VFDPOWEROFF           0xc0425af5
+#define VFDSETPOWERONTIME     0xc0425af6
+#define VFDGETVERSION         0xc0425af7
+#define VFDGETSTARTUPSTATE    0xc0425af8
 #define VFDGETWAKEUPMODE      0xc0425af9
 #define VFDGETTIME            0xc0425afa
 #define VFDSETTIME            0xc0425afb
 #define VFDSTANDBY            0xc0425afc
-
+#define VFDSETTIME2           0xc0425afd // seife, set 'complete' time...
 #define VFDSETLED             0xc0425afe
 #define VFDSETMODE            0xc0425aff
-#define VFDDISPLAYCLR		  0xc0425b00
-
-#define	REMOTE_SLAVE_ADDRESS			0x40bd0000	/* slave address is 5 */
-#define	REMOTE_SLAVE_ADDRESS_NEW		0xc03f0000	/* sz 2008-06-26 add new remote*/
-#define	REMOTE_SLAVE_ADDRESS_EDISION1	0x22dd0000
-#define	REMOTE_SLAVE_ADDRESS_EDISION2	0XCC330000
-#define	REMOTE_SLAVE_ADDRESS_GOLDEN 	0x48b70000	/* slave address is 5 */
-#define REMOTE_TOPFIELD_MASK			0x4fb0000
-
-#define YW_VFD_ENABLE
-#define  INVALID_KEY	-1
+#define VFDDISPLAYCLR         0xc0425b00
+#define VFDGETLOOPSTATE       0xc0425b01
+#define VFDSETLOOPSTATE       0xc0425b02
 
-#define	I2C_BUS_NUM		1
-#define	I2C_BUS_ADD		(0x50>>1)  //this is important not 0x50
+#define INVALID_KEY           -1
 
-typedef unsigned int	YWOS_ClockMsec;
-
-#define LOG_OFF     0
-#define LOG_ON      1
-#define YWPANEL_KEYBOARD
-
-#define VFD_DATA_LEN 64
-
-struct set_brightness_s {
+struct set_brightness_s
+{
 	int level;
 };
 
-struct set_icon_s {
+struct set_icon_s
+{
 	int icon_nr;
 	int on;
 };
 
-struct set_led_s {
+struct set_led_s
+{
 	int led_nr;
 	int on;
 };
@@ -63,23 +60,33 @@
  * time[3] = min
  * time[4] = sec
  */
-struct set_standby_s {
+struct set_standby_s
+{
 	char time[5];
 };
 
-struct set_time_s {
+struct set_time_s
+{
 	char time[5];
 };
 
-/* this setups the mode temporarily (for one ioctl)
+struct set_key_s
+{
+	int key_nr;
+	unsigned int key;
+};
+
+/* this changes the mode temporarily (for one ioctl)
  * to the desired mode. currently the "normal" mode
  * is the compatible vfd mode
  */
-struct set_mode_s {
+struct set_mode_s
+{
 	int compat; /* 0 = compatibility mode to vfd driver; 1 = nuvoton mode */
 };
 
-struct aotom_ioctl_data {
+struct aotom_ioctl_data
+{
 	union
 	{
 		struct set_icon_s icon;
@@ -88,148 +95,90 @@
 		struct set_mode_s mode;
 		struct set_standby_s standby;
 		struct set_time_s time;
+		struct set_key_s key;
 	} u;
 };
 
-
-
-struct vfd_ioctl_data {
-	unsigned char start;
-	unsigned char data[VFD_DATA_LEN];
+struct vfd_ioctl_data
+{
+	unsigned char start_address;
+	unsigned char data[64];
 	unsigned char length;
 };
 
 enum
 {
-	KEY_DIGIT0 = 11,
-	KEY_DIGIT1 = 2,
-	KEY_DIGIT2 = 3,
-	KEY_DIGIT3 = 4,
-	KEY_DIGIT4 = 5,
-	KEY_DIGIT5 = 6,
-	KEY_DIGIT6 = 7,
-	KEY_DIGIT7 = 8,
-	KEY_DIGIT8 = 9,
-	KEY_DIGIT9 = 10
+	/*----------------------------------11G-------------------------------------*/
+	AOTOM_PLAY_FASTBACKWARD = 11 * 16 + 1,
+	AOTOM_FIRST = AOTOM_PLAY_FASTBACKWARD,
+	AOTOM_PLAY_PREV,
+	AOTOM_PLAY_HEAD = AOTOM_PLAY_PREV,  // deprecated
+	AOTOM_PLAY,
+	AOTOM_PLAY_LOG = AOTOM_PLAY,        // deprecated
+	AOTOM_NEXT,
+	AOTOM_PLAY_TAIL = AOTOM_NEXT,       // deprecated
+	AOTOM_PLAY_FASTFORWARD,
+	AOTOM_PLAY_PAUSE,
+	AOTOM_REC1,
+	AOTOM_MUTE,
+	AOTOM_LOOP,
+	AOTOM_CYCLE = AOTOM_LOOP,           // deprecated
+	AOTOM_DOLBYDIGITAL,
+	AOTOM_DUBI = AOTOM_DOLBYDIGITAL,    // deprecated
+	AOTOM_CA,
+	AOTOM_CI,
+	AOTOM_USB,
+	AOTOM_DOUBLESCREEN,
+	AOTOM_REC2,
+	/*----------------------------------12G-------------------------------------*/
+	AOTOM_HDD_A8 = 12 * 16 + 1,
+	AOTOM_HDD_A7,
+	AOTOM_HDD_A6,
+	AOTOM_HDD_A5,
+	AOTOM_HDD_A4,
+	AOTOM_HDD_A3,
+	AOTOM_HDD_FULL,
+	AOTOM_HDD_A2,
+	AOTOM_HDD_A1,
+	AOTOM_MP3,
+	AOTOM_AC3,
+	AOTOM_TV,
+	AOTOM_TVMODE_LOG = AOTOM_TV,        // deprecated
+	AOTOM_AUDIO,
+	AOTOM_ALERT,
+	AOTOM_HDD_FRAME,
+	AOTOM_HDD_A9 = AOTOM_HDD_FRAME,     // deprecated
+	/*----------------------------------13G-------------------------------------*/
+	AOTOM_CLOCK_PM = 13 * 16 + 1,
+	AOTOM_CLOCK_AM,
+	AOTOM_CLOCK,
+	AOTOM_TIME_SECOND,
+	AOTOM_DOT2,
+	AOTOM_STANDBY,
+	AOTOM_TERRESTRIAL,
+	AOTOM_TER = AOTOM_TERRESTRIAL,      // deprecated
+	AOTOM_DISK_S3,
+	AOTOM_DISK_S2,
+	AOTOM_DISK_S1,
+	AOTOM_DISK_CIRCLE,
+	AOTOM_DISK_S0 = AOTOM_DISK_CIRCLE,  // deprecated
+	AOTOM_SATELLITE,
+	AOTOM_SAT = AOTOM_SATELLITE,        // deprecated
+	AOTOM_TIMESHIFT,
+	AOTOM_DOT1,
+	AOTOM_CABLE,
+	AOTOM_CAB = AOTOM_CABLE,            // deprecated
+	AOTOM_LAST = AOTOM_CABLE,
+	/*----------------------------------end-------------------------------------*/
+	AOTOM_ALL
 };
 
-enum
-{
-	POWER_KEY 		 = 88,
-
-    TIME_SET_KEY 	 = 87,
-	UHF_KEY 		 = 68,
-	VFormat_KEY 	 = 67,
-    MUTE_KEY 		 = 66,
-
-    TVSAT_KEY 		 = 65,
-    MUSIC_KEY 		 = 64,
-    FIND_KEY 		 = 63,
-    FAV_KEY 		 = 62,
-
-    MENU_KEY 		 = 102,	// HOME
-    i_KEY 			 = 61,
-    EPG_KEY 		 = 18,
-    EXIT_KEY 		 = 48,	// B
-    RECALL_KEY 		 = 30,
-    RECORD_KEY 		 = 19,
-
-	UP_KEY 			 = 103,	// UP
-	DOWN_KEY		 = 108,	// DOWN
-	LEFT_KEY 		 = 105,	// LEFT
-	RIGHT_KEY		 = 106,	// RIGTHT
-	SELECT_KEY 		 = 28,	// ENTER
-
-    PLAY_KEY 		 = 25,
-    PAGE_UP_KEY 	 = 104,	// P_UP
-    PAUSE_KEY 		 = 22,
-    PAGE_DOWN_KEY 	 = 109,	// P_DOWN
-
-    STOP_KEY 		 = 20,
-	SLOW_MOTION_KEY  = 50,
-	FAST_REWIND_KEY  = 33,
-	FAST_FORWARD_KEY = 49,
-
-    DOCMENT_KEY 	 = 32,
-    SWITCH_PIC_KEY 	 = 17,
-    PALY_MODE_KEY 	 = 24,
-    USB_KEY 		 = 111,
-
-    RADIO_KEY 		 = 110,
-    SAT_KEY		 	 = 15,
-    F1_KEY 			 = 59,
-	F2_KEY 			 = 60,
-
-	RED_KEY 		 = 44,	// Z
-	GREEN_KEY 		 = 45,	// X
-	YELLOW_KEY 		 = 46,	// C
-	BLUE_KEY 		 = 47	// V
-};
+#ifdef __KERNEL__
 
-typedef enum LogNum_e
-{
-/*----------------------------------11G-------------------------------------*/
-    PLAY_FASTBACKWARD = 11*16+1,//  1
-    PLAY_HEAD,			// 2
-    PLAY_LOG,			// 3
-    PLAY_TAIL,			// 4
-    PLAY_FASTFORWARD,		// 5
-    PLAY_PAUSE,			// 6
-    REC1,			// 7
-    MUTE,			// 8
-    CYCLE,			// 9
-    DUBI,			// 10
-    CA,				// 11
-    CI,				// 12
-    USB,			// 13
-    DOUBLESCREEN,		// 14
-    REC2,			// 15
-/*----------------------------------12G-------------------------------------*/
-    HDD_A8 = 12*16+1,		// 16
-    HDD_A7,			// 17
-    HDD_A6,			// 18
-    HDD_A5,			// 19
-    HDD_A4,			// 20
-    HDD_A3,			// 21
-    HDD_FULL,			// 22
-    HDD_A2,			// 23
-    HDD_A1,			// 24
-    MP3,			// 25
-    AC3,			// 26
-    TVMODE_LOG,			// 27
-    AUDIO,			// 28
-    ALERT,			// 29
-    HDD_A9,			// 30
-/*----------------------------------13G-------------------------------------*/
-    CLOCK_PM = 13*16+1,		// 31
-    CLOCK_AM,			// 32
-    CLOCK,			// 33
-    TIME_SECOND,		// 34
-    DOT2,			// 35
-    STANDBY,			// 36
-    TER,			// 37
-    DISK_S3,			// 38
-    DISK_S2,			// 39
-    DISK_S1,			// 40
-    DISK_S0,			// 41
-    SAT,			// 42
-    TIMESHIFT,			// 43
-    DOT1,			// 44
-    CAB,			// 45
-  /*----------------------------------end-------------------------------------*/
-    LogNum_Max
-} LogNum_T;
-
-typedef enum
-{
-	REMOTE_OLD,
-	REMOTE_NEW,
-	REMOTE_TOPFIELD,
-	REMOTE_EDISION1,
-	REMOTE_EDISION2,
-	REMOTE_GOLDEN,
-	REMOTE_UNKNOWN
-} REMOTE_TYPE;
+#define VFD_MAJOR       147
+#define I2C_BUS_NUM     1
+#define I2C_BUS_ADD     (0x50>>1)  //this is important not 0x50
+typedef unsigned int    YWOS_ClockMsec;
 
 typedef enum VFDMode_e
 {
@@ -251,11 +200,13 @@
 	u8 CurrValue2;
 } SegAddrVal_T;
 
+#if 0
 typedef struct VFD_Format_s
 {
 	unsigned char LogNum;
 	unsigned char LogSta;
 } VFD_Format_T;
+#endif
 
 typedef struct VFD_Time_s
 {
@@ -263,31 +214,42 @@
 	unsigned char mint;
 } VFD_Time_T;
 
-#define YWPANEL_FP_INFO_MAX_LENGTH		  (10)
-#define YWPANEL_FP_DATA_MAX_LENGTH		  (38)
+#define YWPANEL_FP_INFO_MAX_LENGTH        (10)
+#define YWPANEL_FP_DATA_MAX_LENGTH        (38)
 
 typedef struct YWPANEL_I2CData_s
 {
-	u8	writeBuffLen;
-	u8	writeBuff[YWPANEL_FP_DATA_MAX_LENGTH];
-	u8	readBuff[YWPANEL_FP_INFO_MAX_LENGTH];
+	u8  writeBuffLen;
+	u8  writeBuff[YWPANEL_FP_DATA_MAX_LENGTH];
+	u8  readBuff[YWPANEL_FP_INFO_MAX_LENGTH];
 
 } YWPANEL_I2CData_t;
 
+typedef struct
+{
+	int state;
+	int period;
+	int stop;
+	int enable;
+	struct task_struct *led_task;
+	struct semaphore led_sem;
+} tLedState;
+
 typedef enum YWPANEL_DataType_e
 {
 	YWPANEL_DATATYPE_LBD = 0x01,
 	YWPANEL_DATATYPE_LCD,
 	YWPANEL_DATATYPE_LED,
 	YWPANEL_DATATYPE_VFD,
+	YWPANEL_DATATYPE_DVFD,
 	YWPANEL_DATATYPE_SCANKEY,
 	YWPANEL_DATATYPE_IRKEY,
 
 	YWPANEL_DATATYPE_GETVERSION,
+	YWPANEL_DATATYPE_GETCPUSTATE,
+	YWPANEL_DATATYPE_SETCPUSTATE,
 	YWPANEL_DATATYPE_GETVFDSTATE,
 	YWPANEL_DATATYPE_SETVFDSTATE,
-	YWPANEL_DATATYPE_GETCPUSTATE, //10
-	YWPANEL_DATATYPE_SETCPUSTATE,
 
 	YWPANEL_DATATYPE_GETSTBYKEY1,
 	YWPANEL_DATATYPE_GETSTBYKEY2,
@@ -297,8 +259,18 @@
 	YWPANEL_DATATYPE_SETSTBYKEY1,
 	YWPANEL_DATATYPE_SETSTBYKEY2,
 	YWPANEL_DATATYPE_SETSTBYKEY3,
-	YWPANEL_DATATYPE_SETSTBYKEY4, //20
+	YWPANEL_DATATYPE_SETSTBYKEY4,
 	YWPANEL_DATATYPE_SETSTBYKEY5,
+	YWPANEL_DATATYPE_GETBLUEKEY1,
+	YWPANEL_DATATYPE_GETBLUEKEY2,
+	YWPANEL_DATATYPE_GETBLUEKEY3,
+	YWPANEL_DATATYPE_GETBLUEKEY4,
+	YWPANEL_DATATYPE_GETBLUEKEY5,
+	YWPANEL_DATATYPE_SETBLUEKEY1,
+	YWPANEL_DATATYPE_SETBLUEKEY2,
+	YWPANEL_DATATYPE_SETBLUEKEY3,
+	YWPANEL_DATATYPE_SETBLUEKEY4,
+	YWPANEL_DATATYPE_SETBLUEKEY5,
 
 	YWPANEL_DATATYPE_GETIRCODE,
 	YWPANEL_DATATYPE_SETIRCODE,
@@ -311,7 +283,7 @@
 	YWPANEL_DATATYPE_GETVERIFYSTATE,
 	YWPANEL_DATATYPE_SETVERIFYSTATE,
 
-	YWPANEL_DATATYPE_GETTIME, //30
+	YWPANEL_DATATYPE_GETTIME,
 	YWPANEL_DATATYPE_SETTIME,
 	YWPANEL_DATATYPE_CONTROLTIMER,
 
@@ -321,42 +293,32 @@
 	YWPANEL_DATATYPE_GETVFDSTANDBYSTATE,
 	YWPANEL_DATATYPE_SETVFDSTANDBYSTATE,
 
-	YWPANEL_DATATYPE_GETBLUEKEY1,
-	YWPANEL_DATATYPE_GETBLUEKEY2,
-	YWPANEL_DATATYPE_GETBLUEKEY3,
-	YWPANEL_DATATYPE_GETBLUEKEY4, //40
-	YWPANEL_DATATYPE_GETBLUEKEY5,
-	YWPANEL_DATATYPE_SETBLUEKEY1,
-	YWPANEL_DATATYPE_SETBLUEKEY2,
-	YWPANEL_DATATYPE_SETBLUEKEY3,
-	YWPANEL_DATATYPE_SETBLUEKEY4,
-	YWPANEL_DATATYPE_SETBLUEKEY5,
-
-	YWPANEL_DATATYPE_GETPOWERONSTATE,	/* 0x77 */
-	YWPANEL_DATATYPE_SETPOWERONSTATE,	/* 0x78 */
-	YWPANEL_DATATYPE_GETSTARTUPSTATE,	/* 0x79 */
-	YWPANEL_DATATYPE_GETLOOPSTATE,		/* 0x80 */
-	YWPANEL_DATATYPE_SETLOOPSTATE,		/* 0x81 */
+	YWPANEL_DATATYPE_GETPOWERONSTATE,
+	YWPANEL_DATATYPE_SETPOWERONSTATE,
+	YWPANEL_DATATYPE_GETSTARTUPSTATE,
+	YWPANEL_DATATYPE_SETSTARTUPSTATE,
+	YWPANEL_DATATYPE_GETLOOPSTATE,
+	YWPANEL_DATATYPE_SETLOOPSTATE,
 
 	YWPANEL_DATATYPE_NUM
 } YWPANEL_DataType_t;
 
 typedef struct YWPANEL_LBDData_s
 {
-	u8	value;
+	u8 value;
 } YWPANEL_LBDData_t;
 
 typedef struct YWPANEL_LEDData_s
 {
-	u8	led1;
-	u8	led2;
-	u8	led3;
-	u8	led4;
+	u8 led1;
+	u8 led2;
+	u8 led3;
+	u8 led4;
 } YWPANEL_LEDData_t;
 
 typedef struct YWPANEL_LCDData_s
 {
-	u8	value;
+	u8 value;
 } YWPANEL_LCDData_t;
 
 typedef enum YWPANEL_VFDDataType_e
@@ -378,6 +340,25 @@
 
 } YWPANEL_VFDData_t;
 
+typedef enum YWPANEL_DVFDDataType_e
+{
+	YWPANEL_DVFD_SETTING = 0x1,
+	YWPANEL_DVFD_DISPLAY,
+	YWPANEL_DVFD_DISPLAYSTRING,
+	YWPANEL_DVFD_DISPLAYSYNC,
+	YWPANEL_DVFD_SETTIMEMODE,
+	YWPANEL_DVFD_GETTIMEMODE,
+} YWPANEL_DVFDDataType_t;
+
+typedef struct YWPANEL_DVFDData_s
+{
+	YWPANEL_DVFDDataType_t type;
+	u8 setValue;
+	u8 ulen;
+	u8 address[16];
+	u8 DisplayValue[16][5];
+} YWPANEL_DVFDData_t;
+
 typedef struct YWPANEL_IRKEY_s
 {
 	u32 customCode;
@@ -391,7 +372,7 @@
 
 typedef struct YWPANEL_StandByKey_s
 {
-	u32 	key;
+	u32 key;
 } YWPANEL_StandByKey_t;
 
 typedef enum YWPANEL_IRCODE_e
@@ -405,12 +386,12 @@
 
 typedef struct YWPANEL_IRCode_s
 {
-	YWPANEL_IRCODE_T	code;
+	YWPANEL_IRCODE_T code;
 } YWPANEL_IRCode_t;
 
 typedef enum YWPANEL_ENCRYPEMODE_e
 {
-	YWPANEL_ENCRYPEMODE_NONE =0x00,
+	YWPANEL_ENCRYPEMODE_NONE = 0x00,
 	YWPANEL_ENCRYPEMODE_ODDBIT,
 	YWPANEL_ENCRYPEMODE_EVENBIT,
 	YWPANEL_ENCRYPEMODE_RAMDONBIT
@@ -418,17 +399,17 @@
 
 typedef struct YWPANEL_EncryptMode_s
 {
-	YWPANEL_ENCRYPEMODE_T	 mode;
+	YWPANEL_ENCRYPEMODE_T    mode;
 } YWPANEL_EncryptMode_t;
 
 typedef struct YWPANEL_EncryptKey_s
 {
-	u32 	  key;
+	u32 key;
 } YWPANEL_EncryptKey_t;
 
 typedef enum YWPANEL_VERIFYSTATE_e
 {
-	YWPANEL_VERIFYSTATE_NONE =0x00,
+	YWPANEL_VERIFYSTATE_NONE = 0x00,
 	YWPANEL_VERIFYSTATE_CRC16 ,
 	YWPANEL_VERIFYSTATE_CRC32 ,
 	YWPANEL_VERIFYSTATE_CHECKSUM
@@ -436,105 +417,107 @@
 
 typedef struct YWPANEL_VerifyState_s
 {
-	YWPANEL_VERIFYSTATE_T		state;
+	YWPANEL_VERIFYSTATE_T state;
 } YWPANEL_VerifyState_t;
 
 typedef struct YWPANEL_Time_s
 {
-	u32 	second;
+	u32 second;
 } YWPANEL_Time_t;
 
 typedef struct YWPANEL_ControlTimer_s
 {
-	bool	startFlag;	  // 0 - stop  1-start
+	int startFlag; // 0 - stop  1-start
 } YWPANEL_ControlTimer_t;
 
 typedef struct YWPANEL_VfdStandbyState_s
 {
-	bool	On; 		  // 0 - off  1-on
+	int On; // 0 - off  1-on
 } YWPANEL_VfdStandbyState_T;
 
 typedef struct YWPANEL_BlueKey_s
 {
-	u32 	key;
+	u32 key;
 } YWPANEL_BlueKey_t;
 
+#if 0
 typedef struct YWVFD_Format_s
 {
-  u8 LogNum;
-  u8 LogSta;
+	u8 LogNum;
+	u8 LogSta;
 } YWVFD_Format_T;
+#endif
 
 typedef struct YWVFD_Time_s
 {
-  u8 hour;
-  u8 mint;
+	u8 hour;
+	u8 mint;
 } YWVFD_Time_T;
 
 typedef enum YWPANEL_CPUSTATE_s
 {
-    YWPANEL_CPUSTATE_UNKNOW,
-    YWPANEL_CPUSTATE_RUNNING = 0x01,
-    YWPANEL_CPUSTATE_STANDBY
+	YWPANEL_CPUSTATE_UNKNOWN,
+	YWPANEL_CPUSTATE_RUNNING = 0x01,
+	YWPANEL_CPUSTATE_STANDBY
 } YWPANEL_CPUSTATE_t;
 
 typedef enum YWPANEL_VFDSTATE_e
 {
-    YWPANEL_VFDSTATE_UNKNOW,
-    YWPANEL_VFDSTATE_STANDBYOFF = 0x01,
-    YWPANEL_VFDSTATE_STANDBYON
+	YWPANEL_VFDSTATE_UNKNOWN,
+	YWPANEL_VFDSTATE_STANDBYOFF = 0x01,
+	YWPANEL_VFDSTATE_STANDBYON
 } YWPANEL_VFDSTATE_t;
 
 typedef enum YWPANEL_POWERONSTATE_e
 {
-    YWPANEL_POWERONSTATE_UNKNOW,
-    YWPANEL_POWERONSTATE_RUNNING = 0x01,
-    YWPANEL_POWERONSTATE_CHECKPOWERBIT
+	YWPANEL_POWERONSTATE_UNKNOWN,
+	YWPANEL_POWERONSTATE_RUNNING = 0x01,
+	YWPANEL_POWERONSTATE_CHECKPOWERBIT
 } YWPANEL_POWERONSTATE_t;
 
 typedef enum YWPANEL_LBDStatus_e
 {
-    YWPANEL_LBD_STATUS_OFF,
-    YWPANEL_LBD_STATUS_ON,
-    YWPANEL_LBD_STATUS_FL
+	YWPANEL_LBD_STATUS_OFF,
+	YWPANEL_LBD_STATUS_ON,
+	YWPANEL_LBD_STATUS_FL
 } YWPANEL_LBDStatus_T;
 
 typedef enum YWPANEL_STARTUPSTATE_e
 {
-    YWPANEL_STARTUPSTATE_UNKNOW,
-    YWPANEL_STARTUPSTATE_ELECTRIFY =0x01,
-    YWPANEL_STARTUPSTATE_STANDBY,
-    YWPANEL_STARTUPSTATE_TIMER
+	YWPANEL_STARTUPSTATE_UNKNOWN,
+	YWPANEL_STARTUPSTATE_ELECTRIFY = 0x01,
+	YWPANEL_STARTUPSTATE_STANDBY,
+	YWPANEL_STARTUPSTATE_TIMER
 } YWPANEL_STARTUPSTATE_t;
 
 typedef enum YWPANEL_LOOPSTATE_e
 {
-    YWPANEL_LOOPSTATE_UNKNOW,
-    YWPANEL_LOOPSTATE_LOOPOFF =0x01,
-    YWPANEL_LOOPSTATE_LOOPON
+	YWPANEL_LOOPSTATE_UNKNOWN,
+	YWPANEL_LOOPSTATE_LOOPOFF = 0x01,
+	YWPANEL_LOOPSTATE_LOOPON
 } YWPANEL_LOOPSTATE_t;
 
 typedef struct YWPANEL_CpuState_s
 {
-    YWPANEL_CPUSTATE_t state;
+	YWPANEL_CPUSTATE_t state;
 } YWPANEL_CpuState_t;
 
 typedef struct YWVFD_FuncKey_s
 {
-  u8 key_index;
-  u32 key_value;
+	u8 key_index;
+	u32 key_value;
 } YWVFD_FuncKey_T;
 
 typedef enum YWVFD_TYPE_s
 {
-  YWVFD_UNKNOW,
-  YWVFD_COMMON,
-  YWVFD_STAND_BY
+	YWVFD_UNKNOWN,
+	YWVFD_COMMON,
+	YWVFD_STAND_BY
 } YWVFD_TYPE_t;
 
 typedef struct YWVFD_INFO_s
 {
-  YWVFD_TYPE_t vfd_type;
+	YWVFD_TYPE_t vfd_type;
 } YWVFD_INFO_t;
 
 typedef struct YWPANEL_PowerOnState_s
@@ -554,132 +537,139 @@
 
 typedef enum YWPANEL_LBDType_e
 {
-	YWPANEL_LBD_TYPE_POWER		 =  ( 1 << 0 ),
-	YWPANEL_LBD_TYPE_SIGNAL 	 =  ( 1 << 1 ),
-	YWPANEL_LBD_TYPE_MAIL		 =	( 1 << 2 ),
-	YWPANEL_LBD_TYPE_AUDIO		 =  ( 1 << 3 )
+	YWPANEL_LBD_TYPE_POWER  = (1 << 0),
+	YWPANEL_LBD_TYPE_SIGNAL = (1 << 1),
+	YWPANEL_LBD_TYPE_MAIL   = (1 << 2),
+	YWPANEL_LBD_TYPE_AUDIO  = (1 << 3)
 } YWPANEL_LBDType_T;
 
 typedef enum YWPAN_FP_MCUTYPE_E
 {
-	YWPANEL_FP_MCUTYPE_UNKNOW = 0x00,
-	YWPANEL_FP_MCUTYPE_AVR_ATTING48,	   //AVR MCU
+	YWPANEL_FP_MCUTYPE_UNKNOWN = 0x00,
+	YWPANEL_FP_MCUTYPE_AVR_ATTING48, // AVR MCU
 	YWPANEL_FP_MCUTYPE_AVR_ATTING88,
 	YWPAN_FP_MCUTYPE_MAX
 } YWPAN_FP_MCUTYPE_T;
 
-typedef	enum YWPANEL_FP_DispType_e
+typedef enum YWPANEL_FP_DispType_e
 {
 	YWPANEL_FP_DISPTYPE_UNKNOWN = 0x00,
 	YWPANEL_FP_DISPTYPE_VFD = (1 << 0),
 	YWPANEL_FP_DISPTYPE_LCD = (1 << 1),
+	YWPANEL_FP_DISPTYPE_DVFD = (3),
 	YWPANEL_FP_DISPTYPE_LED = (1 << 2),
 	YWPANEL_FP_DISPTYPE_LBD = (1 << 3)
 } YWPANEL_FP_DispType_t;
 
 typedef struct YWPANEL_Version_s
 {
-	YWPAN_FP_MCUTYPE_T	CpuType;
-
-	u8	DisplayInfo;
-	u8	scankeyNum;
-	u8	swMajorVersion;
-	u8	swSubVersion;
-
+	YWPAN_FP_MCUTYPE_T CpuType;
+	u8 DisplayInfo;
+	u8 scankeyNum;
+	u8 swMajorVersion;
+	u8 swSubVersion;
 } YWPANEL_Version_t;
 
 typedef struct YWPANEL_FPData_s
 {
-	YWPANEL_DataType_t	dataType;
+	YWPANEL_DataType_t  dataType;
 
 	union
 	{
-		YWPANEL_Version_t			version;
-		YWPANEL_LBDData_t			lbdData;
-		YWPANEL_LEDData_t			ledData;
-		YWPANEL_LCDData_t			lcdData;
-		YWPANEL_VFDData_t			vfdData;
-		YWPANEL_IRKEY_t 			IrkeyData;
-		YWPANEL_SCANKEY_t			ScanKeyData;
-		YWPANEL_CpuState_t			CpuState;
-		YWPANEL_StandByKey_t		stbyKey;
-		YWPANEL_IRCode_t			irCode;
-		YWPANEL_EncryptMode_t		EncryptMode;
-		YWPANEL_EncryptKey_t		EncryptKey;
-		YWPANEL_VerifyState_t		verifyState;
-		YWPANEL_Time_t				time;
-		YWPANEL_ControlTimer_t		TimeState;
-		YWPANEL_VfdStandbyState_T	VfdStandbyState;
-		YWPANEL_BlueKey_t			BlueKey;
-		YWPANEL_PowerOnState_t		PowerOnState;
-		YWPANEL_StartUpState_t		StartUpState;
-		YWPANEL_LoopState_t 		LoopState;
+		YWPANEL_Version_t           version;
+		YWPANEL_LBDData_t           lbdData;
+		YWPANEL_LEDData_t           ledData;
+		YWPANEL_LCDData_t           lcdData;
+		YWPANEL_VFDData_t           vfdData;
+		YWPANEL_DVFDData_t          dvfdData;
+		YWPANEL_IRKEY_t             IrkeyData;
+		YWPANEL_SCANKEY_t           ScanKeyData;
+		YWPANEL_CpuState_t          CpuState;
+		YWPANEL_StandByKey_t        stbyKey;
+		YWPANEL_IRCode_t            irCode;
+		YWPANEL_EncryptMode_t       EncryptMode;
+		YWPANEL_EncryptKey_t        EncryptKey;
+		YWPANEL_VerifyState_t       verifyState;
+		YWPANEL_Time_t              time;
+		YWPANEL_ControlTimer_t      TimeState;
+		YWPANEL_VfdStandbyState_T   VfdStandbyState;
+		YWPANEL_BlueKey_t           BlueKey;
+		YWPANEL_PowerOnState_t      PowerOnState;
+		YWPANEL_StartUpState_t      StartUpState;
+		YWPANEL_LoopState_t         LoopState;
 	} data;
 
-	bool	ack;
+	int ack;
 
 } YWPANEL_FPData_t;
 
 #define BASE_VFD_PRIVATE 0x00
 
-#define VFD_GetRevision         _IOWR('s',(BASE_VFD_PRIVATE+0),char*)
-#define VFD_ShowLog             _IOWR('s',(BASE_VFD_PRIVATE+1),YWVFD_Format_T)
-#define VFD_ShowTime            _IOWR('s',(BASE_VFD_PRIVATE+2),YWVFD_Time_T)
-#define VFD_ShowStr             _IOWR('s',(BASE_VFD_PRIVATE+3),char*)
-#define VFD_ClearTime           _IOWR('s',(BASE_VFD_PRIVATE+4),int)
-#define VFD_SetBright           _IOWR('s',(BASE_VFD_PRIVATE+5),int)
-#define VFD_GetCPUState         _IOWR('s',(BASE_VFD_PRIVATE+6),YWPANEL_CPUSTATE_t)
-#define VFD_SetCPUState         _IOWR('s',(BASE_VFD_PRIVATE+7),YWPANEL_CPUSTATE_t)
-#define VFD_GetStartUpState     _IOWR('s',(BASE_VFD_PRIVATE+8),YWPANEL_STARTUPSTATE_t)
-#define VFD_GetVFDState         _IOWR('s',(BASE_VFD_PRIVATE+9),YWPANEL_VFDSTATE_t)
-#define VFD_SetVFDState         _IOWR('s',(BASE_VFD_PRIVATE+10),YWPANEL_VFDSTATE_t)
-#define VFD_GetPOWERONState     _IOWR('s',(BASE_VFD_PRIVATE+11),YWPANEL_POWERONSTATE_t)
-#define VFD_SetPOWERONState     _IOWR('s',(BASE_VFD_PRIVATE+12),YWPANEL_POWERONSTATE_t)
-#define VFD_GetTime             _IOWR('s',(BASE_VFD_PRIVATE+13),u32)
-#define VFD_SetTime             _IOWR('s',(BASE_VFD_PRIVATE+14),u32)
-#define VFD_ControlTime         _IOWR('s',(BASE_VFD_PRIVATE+15),int)
-#define VFD_GetStandByKey       _IOWR('s',(BASE_VFD_PRIVATE+16),YWVFD_FuncKey_T)
-#define VFD_SetStandByKey       _IOWR('s',(BASE_VFD_PRIVATE+17),YWVFD_FuncKey_T)
-#define VFD_GetBlueKey          _IOWR('s',(BASE_VFD_PRIVATE+18),YWVFD_FuncKey_T)
-#define VFD_SetBlueKey          _IOWR('s',(BASE_VFD_PRIVATE+19),YWVFD_FuncKey_T)
-#define VFD_GetPowerOnTime      _IOWR('s',(BASE_VFD_PRIVATE+20),u32)
-#define VFD_SetPowerOnTime      _IOWR('s',(BASE_VFD_PRIVATE+21),u32)
-#define VFD_ControlLBD          _IOWR('s',(BASE_VFD_PRIVATE+22),YWPANEL_LBDStatus_T)
-
-int YWPANEL_VFD_DETECT(void);
-int	YWPANEL_VFD_Init(ushort *mode_digit);
-int	YWPANEL_VFD_Term(void);
-
-int utf8_count(unsigned char *utfstr, int strlength, int length);
-int utf8_len(unsigned char *utfstr, int strlength);
-
-int YWPANEL_VFD_GetRevision(char * version);
-int YWPANEL_VFD_ShowIco(LogNum_T log_num,int log_stat);
-int YWPANEL_VFD_ShowString(char* str);
-int YWVFD_LED_ShowString(const char *str); //lwj add
-int YWPANEL_VFD_ShowTime(u8 hh,u8 mm);
-int YWPANEL_VFD_ShowTimeOff(void);
-int YWPANEL_VFD_SetBrightness(int level);
+// #define VFD_GetRevision  _IOWR('s',(BASE_VFD_PRIVATE+0),char*)
+// #define VFD_ShowLog          _IOWR('s',(BASE_VFD_PRIVATE+1),YWVFD_Format_T)
+#define VFD_ShowTime        _IOWR('s',(BASE_VFD_PRIVATE+2),YWVFD_Time_T)
+#define VFD_ShowStr         _IOWR('s',(BASE_VFD_PRIVATE+3),char*)
+#define VFD_ClearTime       _IOWR('s',(BASE_VFD_PRIVATE+4),int)
+#define VFD_SetBright       _IOWR('s',(BASE_VFD_PRIVATE+5),int)
+#define VFD_GetCPUState     _IOWR('s',(BASE_VFD_PRIVATE+6),YWPANEL_CPUSTATE_t)
+#define VFD_SetCPUState     _IOWR('s',(BASE_VFD_PRIVATE+7),YWPANEL_CPUSTATE_t)
+#define VFD_GetStartUpState _IOWR('s',(BASE_VFD_PRIVATE+8),YWPANEL_STARTUPSTATE_t)
+#define VFD_GetVFDState     _IOWR('s',(BASE_VFD_PRIVATE+9),YWPANEL_VFDSTATE_t)
+#define VFD_SetVFDState     _IOWR('s',(BASE_VFD_PRIVATE+10),YWPANEL_VFDSTATE_t)
+#define VFD_GetPOWERONState _IOWR('s',(BASE_VFD_PRIVATE+11),YWPANEL_POWERONSTATE_t)
+#define VFD_SetPOWERONState _IOWR('s',(BASE_VFD_PRIVATE+12),YWPANEL_POWERONSTATE_t)
+#define VFD_GetTime         _IOWR('s',(BASE_VFD_PRIVATE+13),u32)
+#define VFD_SetTime         _IOWR('s',(BASE_VFD_PRIVATE+14),u32)
+#define VFD_ControlTime     _IOWR('s',(BASE_VFD_PRIVATE+15),int)
+#define VFD_GetStandByKey   _IOWR('s',(BASE_VFD_PRIVATE+16),YWVFD_FuncKey_T)
+#define VFD_SetStandByKey   _IOWR('s',(BASE_VFD_PRIVATE+17),YWVFD_FuncKey_T)
+#define VFD_GetBlueKey      _IOWR('s',(BASE_VFD_PRIVATE+18),YWVFD_FuncKey_T)
+#define VFD_SetBlueKey      _IOWR('s',(BASE_VFD_PRIVATE+19),YWVFD_FuncKey_T)
+#define VFD_GetPowerOnTime  _IOWR('s',(BASE_VFD_PRIVATE+20),u32)
+#define VFD_SetPowerOnTime  _IOWR('s',(BASE_VFD_PRIVATE+21),u32)
+#define VFD_ControlLBD      _IOWR('s',(BASE_VFD_PRIVATE+22),YWPANEL_LBDStatus_T)
+
+int YWPANEL_VFD_Init(void);
+extern int (*YWPANEL_VFD_Term)(void);
+extern int (*YWPANEL_VFD_Initialize)(void);
+extern int (*YWPANEL_VFD_ShowIcon)(int, int);
+extern int (*YWPANEL_VFD_ShowTime)(u8 hh, u8 mm);
+extern int (*YWPANEL_VFD_ShowTimeOff)(void);
+extern int (*YWPANEL_VFD_SetBrightness)(int);
+extern u8(*YWPANEL_VFD_ScanKeyboard)(void);
+extern int (*YWPANEL_VFD_ShowString)(char *);
+
+extern int YWPANEL_width;
+extern tLedState led_state[LED_COUNT + 1];
+
 YWPANEL_VFDSTATE_t YWPANEL_FP_GetVFDStatus(void);
-bool  YWPANEL_FP_SetVFDStatus(YWPANEL_VFDSTATE_t state);
+int YWPANEL_FP_SetVFDStatus(YWPANEL_VFDSTATE_t state);
 YWPANEL_CPUSTATE_t YWPANEL_FP_GetCpuStatus(void);
-bool  YWPANEL_FP_SetCpuStatus(YWPANEL_CPUSTATE_t state);
-bool  YWPANEL_FP_ControlTimer(bool on);
+int YWPANEL_FP_SetCpuStatus(YWPANEL_CPUSTATE_t state);
+int YWPANEL_FP_ControlTimer(int on);
 YWPANEL_POWERONSTATE_t YWPANEL_FP_GetPowerOnStatus(void);
-bool  YWPANEL_FP_SetPowerOnStatus(YWPANEL_POWERONSTATE_t state);
-u32  YWPANEL_FP_GetTime(void);
-bool  YWPANEL_FP_SetTime(u32 value);
-u32  YWPANEL_FP_GetStandByKey(u8 index);
-bool  YWPANEL_FP_SetStandByKey(u8 index,u8 key);
-u32  YWPANEL_FP_GetBlueKey(u8 index);
-bool  YWPANEL_FP_SetBlueKey(u8 index,u8 key);
-int YWPANEL_LBD_SetStatus(YWPANEL_LBDStatus_T  LBDStatus );
-bool YWPANEL_FP_GetStartUpState(YWPANEL_STARTUPSTATE_t *State);
-
-//u32  YWPANEL_FP_GetIRKey(void);
-bool YWPANEL_FP_SetPowerOnTime(u32 Value);
-u32  YWPANEL_FP_GetPowerOnTime(void);
+int YWPANEL_FP_SetPowerOnStatus(YWPANEL_POWERONSTATE_t state);
+u32 YWPANEL_FP_GetTime(void);
+int YWPANEL_FP_SetTime(u32 value);
+int YWPANEL_FP_GetKey(int blue, int key_nr, u32 *k);
+int YWPANEL_FP_SetKey(int blue, int key_nr, u32 k);
+int YWPANEL_FP_GetStartUpState(YWPANEL_STARTUPSTATE_t *State);
+int YWPANEL_FP_GetVersion(YWPANEL_Version_t *version);
+int  YWPANEL_FP_GetLoopState(YWPANEL_LOOPSTATE_t *state);
+int  YWPANEL_FP_SetLoopState(YWPANEL_LOOPSTATE_t state);
+
+int YWPANEL_FP_SetPowerOnTime(u32 Value);
+u32 YWPANEL_FP_GetPowerOnTime(void);
 int YWPANEL_VFD_GetKeyValue(void);
 int YWPANEL_VFD_SetLed(int which, int on);
 
+int utf8strlen(char *s, int len);
+int utf8charlen(unsigned char c);
+
+int vfdlen_show(struct seq_file *m, void *v);
+int vfdlen_open(struct inode *inode, struct  file *file);
+
+#endif /* __KERNEL__ */
 #endif /* __AOTOM_MAIN_H__ */
+
+// vim:ts=4
diff -Naur a/frontcontroller/aotom/aotom_procfs.c b/frontcontroller/aotom/aotom_procfs.c
--- a/frontcontroller/aotom/aotom_procfs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/frontcontroller/aotom/aotom_procfs.c	2017-05-02 14:21:10.573613522 +0200
@@ -0,0 +1,760 @@
+/*
+ * aotom_procfs.c
+ *
+ * (c) 2014 skl
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+
+#include <linux/proc_fs.h>      /* proc fs */
+#include <asm/uaccess.h>        /* copy_from_user */
+#include <linux/time.h>
+#include <linux/kernel.h>
+#include "aotom_main.h"
+
+/*
+/proc/stb/fp/aotom_led", "w"
+/proc/stb/fp/aotom_icon", "w"
+*/
+/*
+ *  /proc/
+ *             |
+ *             +--- vfd (w)
+ "             +--- progress (rw)
+ *  /proc/stb/fp
+ *             |
+ *             +--- aotom (w)
+ *             |
+ *             +--- version (r)
+ *             |
+ *             +--- rtc (w)
+ *             |
+ *             +--- rtc_offset (w)
+ *             |
+ *             +--- wakeup_time (rw)
+ *             |
+ *             +--- was_timer_wakeup (rw)
+ *             |
+ *             +--- led0_pattern (w)
+ *             |
+ *             +--- led1_pattern (w)
+ *  /proc/stb/lcd
+ *             |
+ *             +--- scroll_delay (w)
+ *             |
+ *             +--- show_symbols (w)
+ *             |
+ *             +--- symbol_network (w)
+ *             |
+ *             +--- symbol_usb (w)
+ *             |
+ *             +--- symbol_hdd (w)
+ *             |
+ *             +--- symbol_hddprogress (w)
+ *             |
+ *             +--- symbol_signal (w)
+ *             |
+ *             +--- symbol_timeshift (w)
+ *             |
+ *             +--- symbol_tv (w)
+ *             |
+ *             +--- symbol_recording (w)
+ *             |
+ *             +--- symbol_record_1 (w)
+ *             |
+ *             +--- symbol_record_2 (w)
+ *             |
+ *             +--- symbol_smartcard (w)
+ *             |
+ *             +--- symbol_parent_rating (w)
+ *             |
+ *             +--- symbol_play (w)
+ *             |
+ *             +--- oled_brightness (w)
+ *  /proc/stb/power/
+ *             |
+ *             +--- standbyled (w)
+*/
+
+extern int install_e2_procs(char *name, read_proc_t *read_proc, write_proc_t *write_proc, void *data);
+extern int remove_e2_procs(char *name, read_proc_t *read_proc, write_proc_t *write_proc);
+
+extern int aotomSetIcon(int which, int on);
+extern int aotomSetLed(int which, int on);
+extern int aotomEnableLed(int which, int on);
+extern int aotomWriteText(char *buf, size_t len);
+extern int aotomSetBrightness(int level);
+extern int aotomGetVersion();
+extern void flashLED(int led, int ms);
+
+static int rtc_offset = 0;
+static u32 wakeup_time = 0;
+static int progress = 0;
+
+static int vfd_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  int value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      ret = aotomWriteText(page, count);
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int progress_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+	char* page;
+	char* myString;
+	ssize_t ret = -ENOMEM;
+	page = (char*)__get_free_page(GFP_KERNEL);
+	if (page)
+	{
+		ret = -EFAULT;
+		if (copy_from_user(page, buf, count))
+			goto out;
+		myString = (char*) kmalloc(count+1, GFP_KERNEL);
+		strncpy(myString, page, count);
+		myString[count] = '\0';
+		sscanf(myString, "%d", &progress);
+		kfree(myString);
+		if (aotomGetVersion() != YWPANEL_FP_DISPTYPE_LED) {
+			myString = (char*) kmalloc(count+6, GFP_KERNEL);
+			if (myString) {
+				strcpy(myString, "Load ");
+				strncat(myString, page, count);
+				aotomWriteText(myString, (count+6) < 8 ? (count+6) : 8);
+				kfree(myString);
+			}
+			if (aotomGetVersion() == YWPANEL_FP_DISPTYPE_VFD) {
+				if ((progress > 0) && (progress <= 98) && (led_state[LED_SPINNER].period == 0))
+					flashLED(LED_SPINNER, 200); // start spinner
+				if ((progress > 98) && (led_state[LED_SPINNER].period > 0))
+					flashLED(LED_SPINNER, 0); // stop spinner
+			}
+		}
+		else {
+			aotomWriteText(page, count);
+		}
+	}
+	ret = count;
+out:
+	free_page((unsigned long)page);
+	return ret;
+}
+
+static int progress_read(char *page, char **start, off_t off, int count, int *eof, void *data) {
+	int len = 0;
+	if(NULL != page)
+		len = sprintf(page,"%d\n", progress);
+	return len;
+}
+
+// Proc for accessing quick control of aotom
+// String format: fxy
+// f is "l" (for led) or "i" (for icons)
+// x is 0/1 and indicates if the led/icon must be off or on
+// y is the led/icon number (between 0 and LED_COUNT-1 for leds; between 1 and 46, for icons, with y==46, all the icons are set)
+static int aotom_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  int value;
+  int ret = -ENOMEM;
+
+  printk("%s(%ld, ", __FUNCTION__, count);
+
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      printk("%s", page);
+
+      if (count>3) {
+        value = (int)simple_strtol(page+2, NULL, 10);
+        if (page[0] == 'l') {
+          if (page[1] == '0') {
+            if ((value>=0)&&(value<LED_COUNT)) aotomSetLed(value,0);
+          }
+          else if (page[1] == '1') {
+            if ((value>=0)&&(value<LED_COUNT)) aotomSetLed(value,1);
+          }
+        }
+        else if (page[0] == 'i') {
+          if (page[1] == '0') {
+            if ((value>=1)&&(value<=46)) aotomSetIcon(value,0);
+          }
+          else if (page[1] == '1') {
+            if ((value>=1)&&(value<=46)) aotomSetIcon(value,1);
+          }
+        }
+      }
+
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  printk(")\n");
+
+  return ret;
+}
+
+static int aotom_read_rtc(char *page, char **start, off_t off, int count, int *eof, void *data) {
+	int len = 0;
+	u32 rtc_time = YWPANEL_FP_GetTime();
+	if(NULL != page)
+	{
+		/* AOTOM needs time in local time so deduct rtc_offset for e2 */
+		len = sprintf(page,"%u\n", rtc_time-rtc_offset);
+	}
+	return len;
+}
+
+static int aotom_write_rtc(struct file *file, const char __user *buffer, unsigned long count, void *data) {
+	char *page = NULL;
+	ssize_t ret = -ENOMEM;
+	u32 argument = 0;
+	int test = -1;
+	char *myString = kmalloc(count + 1, GFP_KERNEL);
+	printk("%s %ld - ", __FUNCTION__, count);
+	page = (char *)__get_free_page(GFP_KERNEL);
+	if (page)
+	{
+		ret = -EFAULT;
+		if (copy_from_user(page, buffer, count))
+			goto out;
+		strncpy(myString, page, count);
+		myString[count] = '\0';
+		printk("%s -> %s\n",__FUNCTION__, myString);
+		test = sscanf (myString,"%u",&argument);
+		if(0 < test)
+		{
+			/* AOTOM needs time in local time so add rtc_offset for time from e2 */
+			YWPANEL_FP_SetTime(argument+rtc_offset);
+			YWPANEL_FP_ControlTimer(true);
+		}
+		/* always return count to avoid endless loop */
+		ret = count;
+	}
+out:
+	free_page((unsigned long)page);
+	kfree(myString);
+	return ret;
+}
+
+static int aotom_read_rtc_offset(char *page, char **start, off_t off, int count, int *eof, void *data) {
+	int len = 0;
+	if(NULL != page)
+		len = sprintf(page,"%d\n", rtc_offset);
+	return len;
+}
+
+static int aotom_write_rtc_offset(struct file *file, const char __user *buffer, unsigned long count, void *data) {
+	char *page = NULL;
+	ssize_t ret = -ENOMEM;
+	int test = -1;
+	u32 rtc_time;
+	char *myString = kmalloc(count + 1, GFP_KERNEL);
+	printk("%s %ld - ", __FUNCTION__, count);
+	page = (char *)__get_free_page(GFP_KERNEL);
+	if (page)
+	{
+		ret = -EFAULT;
+		if (copy_from_user(page, buffer, count))
+			goto out;
+		strncpy(myString, page, count);
+		myString[count] = '\0';
+		printk("%s -> %s\n",__FUNCTION__, myString);
+		rtc_time = YWPANEL_FP_GetTime()-rtc_offset;
+		test = sscanf (myString,"%d",&rtc_offset);
+		// Update time with new offset
+		YWPANEL_FP_SetTime(rtc_time+rtc_offset);
+		YWPANEL_FP_ControlTimer(true);
+		printk(" offset: %d\n",rtc_offset);
+		/* always return count to avoid endless loop */
+		ret = count;
+	}
+out:
+	free_page((unsigned long)page);
+	kfree(myString);
+	return ret;
+}
+
+static int wakeup_time_write(struct file *file, const char __user *buffer, unsigned long count, void *data) {
+	char *page = NULL;
+	ssize_t ret = -ENOMEM;
+	int test = -1;
+	char *myString = kmalloc(count + 1, GFP_KERNEL);
+	printk("%s %ld - ", __FUNCTION__, count);
+	page = (char *)__get_free_page(GFP_KERNEL);
+	if (page)
+	{
+		ret = -EFAULT;
+		if (copy_from_user(page, buffer, count))
+			goto out;
+		strncpy(myString, page, count);
+		myString[count] = '\0';
+		printk("%s -> %s\n",__FUNCTION__, myString);
+		test = sscanf (myString,"%u",&wakeup_time);
+		if(0 < test)
+		{
+			/* AOTOM needs time in local time so add rtc_offset for time from e2 */
+			YWPANEL_FP_SetPowerOnTime(wakeup_time+rtc_offset);
+		}
+		/* always return count to avoid endless loop */
+		ret = count;
+	}
+out:
+	free_page((unsigned long)page);
+	kfree(myString);
+	return ret;
+}
+
+static int wakeup_time_read(char *page, char **start, off_t off, int count, int *eof, void *data) {
+	int len = 0;
+	if(NULL != page)
+	{
+		/* AOTOM needs time in local time so deduct rtc_offset for e2 */
+		len = sprintf(page,"%u\n", wakeup_time-rtc_offset);
+	}
+	return len;
+}
+
+static int was_timer_wakeup_read(char *page, char **start, off_t off, int count, int *eof, void *data) {
+	int len = 0;
+	int res = 0;
+	YWPANEL_STARTUPSTATE_t State;
+	if(NULL != page)
+	{
+		YWPANEL_FP_GetStartUpState(&State);
+		if (State==YWPANEL_STARTUPSTATE_TIMER) res=1;
+		len = sprintf(page,"%d\n", res);
+	}
+	return len;
+}
+
+static int fp_version_read(char *page, char **start, off_t off, int count,
+                          int *eof, void *data_unused)
+{
+  int len = 0;
+  len = sprintf(page, "%d\n", aotomGetVersion());
+  return len;
+}
+
+static int lcd_symbol_usb_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(13,0);
+      else if (value == 1) aotomSetIcon(13,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_hdd_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(30,0);
+      else if (value == 1) aotomSetIcon(30,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_hddprogress_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(22,0);
+      else if (value == 1) aotomSetIcon(22,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_signal_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(42,0);
+      else if (value == 1) aotomSetIcon(42,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_timeshift_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(43,0);
+      else if (value == 1) aotomSetIcon(43,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_tv_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(27,0);
+      else if (value == 1) aotomSetIcon(27,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_record_1_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(7,0);
+      else if (value == 1) aotomSetIcon(7,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_record_2_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(15,0);
+      else if (value == 1) aotomSetIcon(15,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_smartcard_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(11,0);
+      else if (value == 1) aotomSetIcon(11,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_symbol_play_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 0);
+      if (value == 0) aotomSetIcon(3,0);
+      else if (value == 1) aotomSetIcon(3,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int led0_pattern_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 16);
+      if (value==0) aotomSetLed(0,0);
+      else if (value==0xffffffff) aotomSetLed(0,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int led1_pattern_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long value;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      value = simple_strtol(page, NULL, 16);
+      if (value==0) aotomSetLed(1,0);
+      else if (value==0xffffffff) aotomSetLed(1,1);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int lcd_oled_brightness_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  long level;
+  int ret = -ENOMEM;
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+      level = simple_strtol(page, NULL, 10);
+      aotomSetBrightness((int)level);
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int power_standbyled_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  char *page;
+  int ret = -ENOMEM;
+
+  printk("%s(%ld, ", __FUNCTION__, count);
+
+  page = (char *)__get_free_page(GFP_KERNEL);
+  if (page)
+  {
+    ret = -EFAULT;
+    if (copy_from_user(page, buf, count) == 0)
+    {
+      page[count] = '\0';
+
+      printk("%s", page);
+
+      if (strcmp(page,"on")==0) {
+        aotomEnableLed(0,1);
+        printk("on");
+      }
+      else if (strcmp(page,"off")==0) {
+        aotomEnableLed(0,0);
+        printk("off");
+      }
+      ret = count;
+    }
+    free_page((unsigned long)page);
+  }
+  return ret;
+}
+
+static int null_write(struct file *file, const char __user *buf,
+                           unsigned long count, void *data)
+{
+  return count;
+}
+
+struct fp_procs
+{
+  char *name;
+  read_proc_t *read_proc;
+  write_proc_t *write_proc;
+} fp_procs[] =
+{
+  { "vfd", NULL, vfd_write },
+  { "progress", progress_read, progress_write },
+  { "stb/fp/rtc", aotom_read_rtc, aotom_write_rtc },
+  { "stb/fp/rtc_offset", aotom_read_rtc_offset, aotom_write_rtc_offset },
+  { "stb/fp/aotom", NULL, aotom_write },
+  { "stb/fp/led0_pattern", NULL, led0_pattern_write },
+  { "stb/fp/led1_pattern", NULL, led1_pattern_write },
+  { "stb/fp/wakeup_time", wakeup_time_read, wakeup_time_write },
+  { "stb/fp/was_timer_wakeup", was_timer_wakeup_read, null_write },
+  { "stb/fp/version", fp_version_read, NULL },
+  { "stb/power/standbyled", NULL, power_standbyled_write },
+  { "stb/lcd/scroll_delay", NULL, null_write },
+  { "stb/lcd/show_symbols", NULL, null_write },
+  { "stb/lcd/symbol_network", NULL, null_write },
+  { "stb/lcd/symbol_usb", NULL, lcd_symbol_usb_write },
+  { "stb/lcd/symbol_hdd", NULL, lcd_symbol_hdd_write },
+  { "stb/lcd/symbol_hddprogress", NULL, lcd_symbol_hddprogress_write },
+  { "stb/lcd/symbol_signal", NULL, lcd_symbol_signal_write },
+  { "stb/lcd/symbol_timeshift", NULL, lcd_symbol_timeshift_write },
+  { "stb/lcd/symbol_tv", NULL, lcd_symbol_tv_write },
+  { "stb/lcd/symbol_recording", NULL, null_write },
+  { "stb/lcd/symbol_record_1", NULL, lcd_symbol_record_1_write },
+  { "stb/lcd/symbol_record_2", NULL, lcd_symbol_record_2_write },
+  { "stb/lcd/symbol_smartcard", NULL, lcd_symbol_smartcard_write },
+  { "stb/lcd/symbol_parent_rating", NULL, null_write },
+  { "stb/lcd/symbol_play", NULL, lcd_symbol_play_write },
+  { "stb/lcd/oled_brightness", NULL, lcd_oled_brightness_write },
+};
+
+void create_proc_fp(void)
+{
+  int i;
+  for(i = 0; i < sizeof(fp_procs)/sizeof(fp_procs[0]); i++)
+  {
+    install_e2_procs(fp_procs[i].name, fp_procs[i].read_proc, fp_procs[i].write_proc, NULL);
+  }
+}
+
+void remove_proc_fp(void)
+{
+  int i;
+  for(i = sizeof(fp_procs)/sizeof(fp_procs[0]) - 1; i >= 0; i--)
+  {
+    remove_e2_procs(fp_procs[i].name, fp_procs[i].read_proc, fp_procs[i].write_proc);
+  }
+}
+
diff -Naur a/frontcontroller/aotom/aotom_trace.c b/frontcontroller/aotom/aotom_trace.c
--- a/frontcontroller/aotom/aotom_trace.c	2017-05-01 20:31:14.715295257 +0200
+++ b/frontcontroller/aotom/aotom_trace.c	2017-05-02 14:19:36.517095756 +0200
@@ -23,22 +23,22 @@
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/types.h>
-//#include <asm/string.h>
+#include <asm/string.h>
 
 #include "aotom_trace.h"
 
-int trace_level = TRACE_ERROR | TRACE_FATAL|TRACE_INFO;
+int trace_level = TRACE_ERROR | TRACE_FATAL | TRACE_INFO;
 
 int YWTRACE_Init(void)
 {
-    return 0;    
+	return 0;
 }
 
-int YWTRACE_Print (const unsigned int level, const char * format, ...)
+int YWTRACE_Print(const unsigned int level, const char *format, ...)
 {
 	va_list args;
-	int r=0;
-	if(trace_level & level)
+	int r = 0;
+	if (trace_level & level)
 	{
 		va_start(args, format);
 		if (level & (TRACE_ERROR | TRACE_FATAL))
diff -Naur a/frontcontroller/aotom/aotom_trace.h b/frontcontroller/aotom/aotom_trace.h
--- a/frontcontroller/aotom/aotom_trace.h	2017-05-01 20:31:14.715295257 +0200
+++ b/frontcontroller/aotom/aotom_trace.h	2017-05-02 14:19:36.517095756 +0200
@@ -1,34 +1,34 @@
 #ifndef __AOTOM_YWTRACE_H
 #define __AOTOM_YWTRACE_H
 
-#define TRACE_TIMESTAMP			0x10000000
-#define TRACE_MODLUE_MASK		0x00FFFFFF
+#define TRACE_TIMESTAMP         0x10000000
+#define TRACE_MODLUE_MASK       0x00FFFFFF
 
 enum ywtrace_level_e
 {
-	TRACE_FATAL	= 0x01,
-	TRACE_ERROR	= 0x02,
-	TRACE_INFO	= 0x04,
-	TRACE_OK	= 0x08,
-	TRACE_MASK	= 0x0F
+	TRACE_FATAL = 0x01,
+	TRACE_ERROR = 0x02,
+	TRACE_INFO  = 0x04,
+	TRACE_OK    = 0x08,
+	TRACE_MASK  = 0x0F
 };
 
-int YWTRACE_Init ( void );
-int YWTRACE_Print (const unsigned int level, const char * format, ...);
+int YWTRACE_Init(void);
+int YWTRACE_Print(const unsigned int level, const char *format, ...);
 
 #ifdef __TRACE__
-#define	ywtrace_init		YWTRACE_Init
-#define	ywtrace_print		YWTRACE_Print
+#define ywtrace_init        YWTRACE_Init
+#define ywtrace_print       YWTRACE_Print
 #else
-#define	ywtrace_init(x...)	do{} while(0)
-#define	ywtrace_print(x...)	do{} while(0)
+#define ywtrace_init(x...)  do{} while(0)
+#define ywtrace_print(x...) do{} while(0)
 #endif
 
 #define YW_PANEL_DEBUG
 
 #ifdef YW_PANEL_DEBUG
-#define PANEL_DEBUG(x)	ywtrace_print(TRACE_ERROR,"%s() error at line: %d in file:%s ^!^\n",__FUNCTION__, __LINE__, __FILE__)
-#define PANEL_PRINT(x)	ywtrace_print x
+#define PANEL_DEBUG(x)  ywtrace_print(TRACE_ERROR,"%s() error at line: %d in file:%s ^!^\n",__FUNCTION__, __LINE__, __FILE__)
+#define PANEL_PRINT(x)  ywtrace_print x
 #else
 #define PANEL_DEBUG(x)
 #define PANEL_PRINT(x)
diff -Naur a/frontcontroller/aotom/aotom_vfd.c b/frontcontroller/aotom/aotom_vfd.c
--- a/frontcontroller/aotom/aotom_vfd.c	2017-05-01 20:31:14.716295230 +0200
+++ b/frontcontroller/aotom/aotom_vfd.c	2017-05-02 14:19:36.518095729 +0200
@@ -3,6 +3,7 @@
  *
  * (c) 2010 Spider-Team
  * (c) 2011 oSaoYa
+ * (c) 2012-2013 martii
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -32,6 +33,7 @@
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/stm/pio.h>
+#include <linux/input.h>
 
 #include "aotom_ywdefs.h"
 #include "aotom_i2csoft.h"
@@ -40,15 +42,25 @@
 
 #include "utf.h"
 
-
 YWVFD_INFO_t YWVFD_INFO;
 
+//#define DEBUG
+#ifdef DEBUG
+#ifdef MODULE
+#define YWVFD_Debug(x...) printk(x)
+#else
+#define YWVFD_Debug(x...) printf(x)
+#endif
+#else
+#define YWVFD_Debug(x...)
+#endif
+
 static SegAddrVal_T VfdSegAddr[15];
 struct semaphore vfd_sem;
 struct semaphore vfd_sem_rw;
 struct rw_semaphore vfd_rws;
 static const char Revision[] = "Revision: 0.7";
-static YWPANEL_FP_DispType_t	panel_disp_type = YWPANEL_FP_DISPTYPE_UNKNOWN;
+static YWPANEL_FP_DispType_t    panel_disp_type = YWPANEL_FP_DISPTYPE_UNKNOWN;
 
 static u8 lbdValue = 0;
 
@@ -56,310 +68,269 @@
 static struct stpio_pin *pio_sda;
 static struct stpio_pin *pio_cs;
 
-#define KEN_NUM_NEW		50
-static const u8	key_table_new[KEN_NUM_NEW][2] = {
-							  {POWER_KEY, 	0x08},
-							  {TIME_SET_KEY,0x48},
-							  {UHF_KEY, 	0x28},
-							  {VFormat_KEY, 0x18},
-							  {MUTE_KEY, 	0x88},
-							  {TVSAT_KEY, 	0xc8},
-							  {MUSIC_KEY, 	0xd0},
-							  {FIND_KEY, 	0xe8},
-							  {FAV_KEY, 	0x7a},
-							  {KEY_DIGIT1, 	0x80},
-							  {KEY_DIGIT2, 	0x40},
-							  {KEY_DIGIT3, 	0xc0},
-							  {KEY_DIGIT4, 	0x20},
-							  {KEY_DIGIT5, 	0xa0},
-							  {KEY_DIGIT6, 	0x60},
-							  {KEY_DIGIT7, 	0xe0},
-							  {KEY_DIGIT8, 	0x10},
-							  {KEY_DIGIT9, 	0x90},
-							  {KEY_DIGIT0, 	0x00},
-							  {MENU_KEY, 	0x50},
-							  {i_KEY, 		0xda},
-							  {EPG_KEY, 	0xb0},
-							  {EXIT_KEY, 	0x30},
-							  {RECALL_KEY, 	0xf0},
-							  {RECORD_KEY, 	0x70},
-							  {UP_KEY, 		0x98},
-							  {DOWN_KEY, 	0x58},
-							  {LEFT_KEY, 	0xd8},
-							  {RIGHT_KEY, 	0x38},
-							  {SELECT_KEY, 	0xb8},
-							  {PLAY_KEY, 	0xa8},
-							  {PAGE_UP_KEY, 0x68},
-							  {PAUSE_KEY, 	0x78},
-							  {PAGE_DOWN_KEY, 	0x62},
-							  {STOP_KEY, 		0x2a},
-							  {SLOW_MOTION_KEY, 0x32},
-							  {FAST_REWIND_KEY, 0x6a},
-							  {FAST_FORWARD_KEY,0xaa},
-							  {DOCMENT_KEY, 	0xea},
-							  {SWITCH_PIC_KEY,  0x1a},
-							  {PALY_MODE_KEY, 	0x9a},
-							  {USB_KEY, 	0x5a},
-							  {RADIO_KEY, 	0xca},
-							  {SAT_KEY, 	0x4a},
-							  {F1_KEY, 		0xf8},
-							  {F2_KEY, 		0xd2},
-							  {RED_KEY, 	0xc2},
-							  {GREEN_KEY, 	0x2},
-							  {YELLOW_KEY, 	0x92},
-							  {BLUE_KEY, 	0x72}	};
-
-#define KEY_NUM_TOP			48
-static const u8	key_table_top[KEY_NUM_TOP][2] = {
-							  {POWER_KEY, 	0x50},
-							  {MUTE_KEY,	0x30},
-							  {VFormat_KEY, 0x42},
-							  {UHF_KEY, 	0xc2},
-							  {TVSAT_KEY, 	0x10},
-							  {KEY_DIGIT1, 	0x88},
-							  {KEY_DIGIT2, 	0x48},
-							  {KEY_DIGIT3, 	0xc8},
-							  {KEY_DIGIT4, 	0x28},
-							  {KEY_DIGIT5, 	0xa8},
-							  {KEY_DIGIT6, 	0x68},
-							  {KEY_DIGIT7, 	0xe8},
-							  {KEY_DIGIT8, 	0x18},
-							  {KEY_DIGIT9, 	0x98},
-							  {KEY_DIGIT0, 	0x08},
-							  {RECALL_KEY, 	0x78},
-							  {i_KEY, 		0xb8},
-							  {RADIO_KEY, 	0xa0},
-							  {FIND_KEY, 	0xe0},
-							  {EPG_KEY, 	0xe2},
-							  {MENU_KEY, 	0x58},
-							  {RECORD_KEY, 	0xd8},
-							  {EXIT_KEY, 	0x38},
-							  {FAV_KEY, 	0x90},
-							  {UP_KEY, 		0x0},
-							  {DOWN_KEY, 	0x80},
-							  {LEFT_KEY, 	0xc0},
-							  {RIGHT_KEY, 	0x40},
-							  {SELECT_KEY, 	0xf8},
-							  {RED_KEY, 	0xb2},
-							  {GREEN_KEY, 	0xb0},
-							  {YELLOW_KEY, 	0x70},
-							  {BLUE_KEY, 	0xf0},
-							  {PAGE_UP_KEY, 0xa2},
-							  {PAUSE_KEY, 	0x60},
-							  {PLAY_KEY, 	0x62},
-							  {PAGE_DOWN_KEY, 	0x12},
-							  {SWITCH_PIC_KEY,  0xd2},
-							  {STOP_KEY, 		0x52},
-							  {SLOW_MOTION_KEY, 0x92},
-							  {DOCMENT_KEY, 	0x8a},
-							  {SAT_KEY, 		0x7a},
-							  {FAST_REWIND_KEY, 0xa},
-							  {FAST_FORWARD_KEY,0x4a},
-							  {PALY_MODE_KEY, 	0x32},
-							  {MUSIC_KEY, 		0x20},
-							  {USB_KEY, 		0x2},
-							  {TIME_SET_KEY,	0x22}	};
-
-#define KEY_NUM_EDI		47
-static const u8	key_table_edi[KEY_NUM_EDI][2] = {
-							  {POWER_KEY, 	0x08},
-							  {MUTE_KEY, 	0xc2},
-							  {VFormat_KEY, 0xa2},
-							  {TVSAT_KEY, 	0xca},
-							  {KEY_DIGIT1, 	0xd0},
-							  {KEY_DIGIT2, 	0x30},
-							  {KEY_DIGIT3, 	0xb0},
-							  {KEY_DIGIT4, 	0x70},
-							  {KEY_DIGIT5, 	0xf0},
-							  {KEY_DIGIT6, 	0x80},
-							  {KEY_DIGIT7, 	0x88},
-							  {KEY_DIGIT8, 	0x48},
-							  {KEY_DIGIT9, 	0xc8},
-							  {KEY_DIGIT0, 	0x50},
-							  {RECALL_KEY, 	0xa0},
-							  {i_KEY, 		0xe0},
-							  {RADIO_KEY, 	0x62},
-							  {FIND_KEY, 	0x40},
-							  {EPG_KEY, 	0x8a},
-							  {MENU_KEY, 	0x0a},
-							  {RECORD_KEY, 	0xe2},
-							  {F1_KEY, 		0x60},
-							  {EXIT_KEY, 	0x20},
-							  {FAV_KEY, 	0xc0},
-							  {UP_KEY, 		0xa8},
-							  {DOWN_KEY, 	0x68},
-							  {LEFT_KEY, 	0xe8},
-							  {RIGHT_KEY, 	0x18},
-							  {SELECT_KEY, 	0x28},
-							  {RED_KEY, 	0xf8},
-							  {GREEN_KEY, 	0x04},
-							  {YELLOW_KEY, 	0x82},
-							  {BLUE_KEY, 	0x02},
-							  {PAGE_DOWN_KEY,	0xd8},
-							  {PAUSE_KEY, 		0x92},
-							  {PLAY_KEY, 		0xb8},
-							  {PAGE_UP_KEY, 	0x38},
-							  {SWITCH_PIC_KEY,  0xf2},
-							  {STOP_KEY, 		0x78},
-							  {SLOW_MOTION_KEY, 0x12},
-							  {DOCMENT_KEY, 	0x42},
-							  {SAT_KEY, 		0x72},
-							  {FAST_FORWARD_KEY,0x58},
-							  {FAST_REWIND_KEY, 0x98},
-							  {PALY_MODE_KEY, 	0x32},
-							  {USB_KEY, 		0xd2},
-							  {TIME_SET_KEY, 	0x22}	};
-
 typedef enum PIO_Mode_e
 {
 	PIO_Out,
 	PIO_In
-}PIO_Mode_T;
+} PIO_Mode_T;
 
-u8 YWPANEL_CharArray[]=
+static u8 YWPANEL_CharArray[] =
 {
-	0x7B,0x11,0x76,0x75,0x1D,0x6D,0x6F,0x31,0xFF,0x7D/* 0~9*/
+	0x7B, 0x11, 0x76, 0x75, 0x1D, 0x6D, 0x6F, 0x31, 0xFF, 0x7D /* 0~9*/
 };
 
-//     a
-//f h j k b
-//  g i m
-//e r p n c
-//     d
+//  aaaaa
+// fh j kb
+// f hjk b
+//  ggimm
+// e rpn c
+// er p nc
+//  ddddd
 //a b c d e f g h
 
+/*               7 6 5 4 3 2 1 0 */
 /*address 0 8bit g i m c r p n e */
-/*address 1 7bit d a b f k j h    */
+/*address 1 7bit   d a b f k j h */
 
-u8 CharLib[48][2] =
+static u8 CharLib[0x37][2] =
 {
-	{0xF1, 0x38},	//A
-	{0x74, 0x72},	//B
-	{0x01, 0x68},	//C
-	{0x54, 0x72},	//D
-	{0xE1, 0x68},	//E
-	{0xE1, 0x28},	//F
-	{0x71, 0x68},	//G
-	{0xF1, 0x18},	//H
-	{0x44, 0x62},	//I
-	{0x45, 0x22},	//J
-	{0x46, 0x06},	//K
-	{0x01, 0x48},	//L
-	{0x51, 0x1D},	//M
-	{0x53, 0x19},	//N
-	{0x11, 0x78},	//O
-	{0xE1, 0x38},	//P
-	{0x13, 0x78},	//Q
-	{0xE3, 0x38},	//R
-	{0xF0, 0x68},	//S
-	{0x44, 0x22},	//T
-	{0x11, 0x58},	//U
-	{0x49, 0x0C},	//V
-	{0x5B, 0x18},	//W
-	{0x4A, 0x05},	//X
-	{0x44, 0x05},	//Y
-	{0x48, 0x64},	//Z
+	{0xF1, 0x38},   //A 00
+	{0x74, 0x72},   //B 01
+	{0x01, 0x68},   //C 02
+	{0x54, 0x72},   //D 03
+	{0xE1, 0x68},   //E 04
+	{0xE1, 0x28},   //F 05
+	{0x71, 0x68},   //G 06
+	{0xF1, 0x18},   //H 07
+	{0x44, 0x62},   //I 08
+	{0x45, 0x22},   //J 09
+	{0xC3, 0x0C},   //K 0A
+	{0x01, 0x48},   //L 0B
+	{0x51, 0x1D},   //M 0C
+	{0x53, 0x19},   //N 0D
+	{0x11, 0x78},   //O 0E
+	{0xE1, 0x38},   //P 0F
+	{0x13, 0x78},   //Q 10
+	{0xE3, 0x38},   //R 11
+	{0xF0, 0x68},   //S 12
+	{0x44, 0x22},   //T 13
+	{0x11, 0x58},   //U 14
+	{0x49, 0x0C},   //V 15
+	{0x5B, 0x18},   //W 16
+	{0x4A, 0x05},   //X 17
+	{0x44, 0x05},   //Y 18
+	{0x48, 0x64},   //Z 19
 	/* A--Z  */
 
-	{0x01, 0x68},
-	{0x42, 0x01},
-	{0x10, 0x70},	//
-	{0x43, 0x09},	//
-	{0xE0, 0x00},	//
-	{0xEE, 0x07},	//
-	{0xE4, 0x02},	//
-	{0x50, 0x00},	//
-	{0xE0, 0x00},	//
-	{0x05, 0x00},	//
-	{0x48, 0x04},	//
-
-	{0x11, 0x78},	//
-	{0x44, 0x02},	//
-	{0xE1, 0x70},	//
-	{0xF0, 0x70},	//
-	{0xF0, 0x18},	//
-	{0xF0, 0x68},	//
-	{0xF1, 0x68},	//
-	{0x10, 0x30},	//
-	{0xF1, 0x78},	//
-	{0xF0, 0x78},	//
+	{0x01, 0x68},   // [    1A
+	{0x42, 0x01},   // \    1B
+	{0x10, 0x70},   // ]    1C
+	{0x43, 0x09},   // |\   1D
+	{0x00, 0x40},   // _    1E
+	{0xEE, 0x07},   // *    1F
+	{0xE4, 0x02},   // +    20
+	{0x50, 0x00},   // .,   21
+	{0xE0, 0x00},   // -    22
+	{0x05, 0x00},   // ,,   23
+	{0x48, 0x04},   // /    24
+
+	{0x51, 0x78},   // 0    25
+	{0x44, 0x02},   // 1    26
+	{0xE1, 0x70},   // 2    27
+	{0xF0, 0x70},   // 3    28
+	{0xF0, 0x18},   // 4    29
+	{0xF0, 0x68},   // 5    2A
+	{0xF1, 0x68},   // 6    2B
+	{0x10, 0x30},   // 7    2C
+	{0xF1, 0x78},   // 8    2D
+	{0xF0, 0x78},   // 9    2E
 	/* 0--9  */
-	{0x00, 0x00}
+	{0x00, 0x00},   // ' '  2F
+	{0x44, 0x02},   // |    30
+	{0x42, 0x04},   // <{   31
+	{0x48, 0x01},   // >}   32
+	/*j00zek : missing chars*/
+	{0x04, 0x00},   // .    33
+	{0x04, 0x02},   // :    34
+	{0x00, 0x02},   // '    35
+	{0x00, 0x03},   // "    36
 };
 
-u8 NumLib[10][2] =
+static u8 NumLib[10][2] =
 {
-	{0x77, 0x77},	//{01110111, 01110111},
-	{0x24, 0x22},	//{00100100, 00010010},
-	{0x6B, 0x6D},	//{01101011, 01101101},
-	{0x6D, 0x6B},	//{01101101, 01101011},
-	{0x3C, 0x3A},	//{00111100, 00111010},
-	{0x5D, 0x5B},	//{01011101, 01011011},
-	{0x5F, 0x5F},	//{01011111, 01011111},
-	{0x64, 0x62},	//{01100100, 01100010},
-	{0x7F, 0x7F},	//{01111111, 01111111},
-	{0x7D, 0x7B}	//{01111101, 01111011},
+	{0x77, 0x77},   //{01110111, 01110111},
+	{0x24, 0x22},   //{00100100, 00010010},
+	{0x6B, 0x6D},   //{01101011, 01101101},
+	{0x6D, 0x6B},   //{01101101, 01101011},
+	{0x3C, 0x3A},   //{00111100, 00111010},
+	{0x5D, 0x5B},   //{01011101, 01011011},
+	{0x5F, 0x5F},   //{01011111, 01011111},
+	{0x64, 0x62},   //{01100100, 01100010},
+	{0x7F, 0x7F},   //{01111111, 01111111},
+	{0x7D, 0x7B}    //{01111101, 01111011},
 };
 
-enum
+static char dvfd_bitmap[95][5] =
 {
-	YWPANEL_INIT_INSTR_GETVERSION= 0x50,
+	{0x00, 0x00, 0x00, 0x00, 0x00, }, //' ' 0x20 032
+	{0x10, 0x42, 0x08, 0x01, 0x04, }, //'!' 0x21 033
+	{0x68, 0xad, 0x00, 0x00, 0x00, }, //'"' 0x22 034
+	{0x28, 0xf5, 0xd5, 0x57, 0x0a, }, //'#' 0x23 035
+	{0x10, 0x5f, 0x1c, 0x7d, 0x04, }, //'$' 0x24 036
+	{0x8c, 0x89, 0x88, 0xc8, 0x18, }, //'%' 0x25 037
+	{0x88, 0x52, 0x44, 0x4d, 0x16, }, //'&' 0x26 038
+	{0x10, 0x42, 0x00, 0x00, 0x00, }, //''' 0x27 039
+	{0x40, 0x44, 0x08, 0x41, 0x10, }, //'(' 0x28 040
+	{0x04, 0x41, 0x08, 0x11, 0x01, }, //')' 0x29 041
+	{0x90, 0xea, 0x88, 0xab, 0x04, }, //'*' 0x2a 042
+	{0x00, 0x42, 0x3e, 0x21, 0x00, }, //'+' 0x2b 043
+	{0x00, 0x00, 0x00, 0x31, 0x02, }, //',' 0x2c 044
+	{0x00, 0xf0, 0x01, 0x00, 0x00, }, //'-' 0x2d 045
+	{0x00, 0x00, 0x00, 0x61, 0x00, }, //'.' 0x2e 046
+	{0x00, 0x88, 0x88, 0x08, 0x00, }, //'/' 0x2f 047
+	{0xb8, 0x18, 0x63, 0x8c, 0x0e, }, //'0' 0x30 048
+	{0x10, 0x43, 0x08, 0x21, 0x1f, }, //'1' 0x31 049
+	{0xb8, 0x08, 0x11, 0x11, 0x1f, }, //'2' 0x32 050
+	{0x38, 0xc8, 0x20, 0x84, 0x0f, }, //'3' 0x33 051
+	{0x20, 0xa6, 0xd2, 0x47, 0x1c, }, //'4' 0x34 052
+	{0xbc, 0xf0, 0x20, 0x84, 0x0f, }, //'5' 0x35 053
+	{0x30, 0x11, 0x5e, 0x8c, 0x0e, }, //'6' 0x36 054
+	{0x7c, 0x88, 0x10, 0x22, 0x04, }, //'7' 0x37 055
+	{0xb8, 0x18, 0x5d, 0x8c, 0x0e, }, //'8' 0x38 056
+	{0xb8, 0x18, 0x3d, 0x44, 0x06, }, //'9' 0x39 057
+	{0x00, 0x46, 0x00, 0x61, 0x00, }, //':' 0x3a 058
+	{0x00, 0x46, 0x00, 0x31, 0x02, }, //';' 0x3b 059
+	{0x40, 0x26, 0x06, 0x81, 0x00, }, //'<' 0x3c 060
+	{0x80, 0x0f, 0x3e, 0x00, 0x00, }, //'=' 0x3d 061
+	{0x04, 0x83, 0x30, 0x09, 0x00, }, //'>' 0x3e 062
+	{0xb8, 0x08, 0x19, 0x01, 0x04, }, //'?' 0x3f 063
+	{0xb8, 0x98, 0x6b, 0x0e, 0x1e, }, //'@' 0x40 064
+	{0x08, 0x93, 0xe2, 0x8f, 0x11, }, //'A' 0x41 065
+	{0xbc, 0x18, 0x5f, 0x8c, 0x0f, }, //'B' 0x42 066
+	{0xb8, 0x18, 0x42, 0x88, 0x0e, }, //'C' 0x43 067
+	{0xbc, 0x18, 0x63, 0x8c, 0x0f, }, //'D' 0x44 068
+	{0xfc, 0x18, 0x4e, 0x89, 0x1f, }, //'E' 0x45 069
+	{0x78, 0x21, 0x9c, 0x12, 0x06, }, //'F' 0x46 070
+	{0xf8, 0x10, 0x42, 0x8e, 0x1e, }, //'G' 0x47 071
+	{0xc4, 0x18, 0x7f, 0x8c, 0x11, }, //'H' 0x48 072
+	{0x38, 0x42, 0x08, 0x21, 0x0e, }, //'I' 0x49 073
+	{0x70, 0x08, 0x61, 0x8c, 0x0e, }, //'J' 0x4a 074
+	{0xec, 0x54, 0x4e, 0x4a, 0x13, }, //'K' 0x4b 075
+	{0x1c, 0x21, 0x84, 0x10, 0x1f, }, //'L' 0x4c 076
+	{0xc4, 0xbd, 0x6b, 0x8d, 0x1b, }, //'M' 0x4d 077
+	{0xe4, 0x39, 0x6b, 0xce, 0x13, }, //'N' 0x4e 078
+	{0xb8, 0x18, 0x63, 0x8c, 0x0e, }, //'O' 0x4f 079
+	{0xbc, 0x18, 0x5f, 0x08, 0x03, }, //'P' 0x50 080
+	{0xb8, 0x18, 0x63, 0x4d, 0x16, }, //'Q' 0x51 081
+	{0xbc, 0x18, 0x5f, 0x49, 0x13, }, //'R' 0x52 082
+	{0xb8, 0x18, 0x1c, 0x8c, 0x0e, }, //'S' 0x53 083
+	{0xfc, 0x4a, 0x08, 0x21, 0x0e, }, //'T' 0x54 084
+	{0xec, 0x18, 0x63, 0x8c, 0x0e, }, //'U' 0x55 085
+	{0xc4, 0x18, 0xa5, 0x52, 0x04, }, //'V' 0x56 086
+	{0xc4, 0x58, 0x6b, 0x55, 0x0a, }, //'W' 0x57 087
+	{0x44, 0xa9, 0x88, 0xca, 0x11, }, //'X' 0x58 088
+	{0x44, 0xa9, 0x08, 0x21, 0x0e, }, //'Y' 0x59 089
+	{0xfc, 0x88, 0x88, 0x88, 0x1f, }, //'Z' 0x5a 090
+	{0x30, 0x42, 0x08, 0x21, 0x0c, }, //'[' 0x5b 091
+	{0x80, 0x20, 0x08, 0x82, 0x00, }, //'\' 0x5c 092
+	{0x18, 0x42, 0x08, 0x21, 0x06, }, //']' 0x5d 093
+	{0x00, 0xa2, 0x22, 0x00, 0x00, }, //'^' 0x5e 094
+	{0x00, 0x00, 0x00, 0xf8, 0x00, }, //'_' 0x5f 095
+	{0x00, 0x02, 0x00, 0x00, 0x00, }, //'`' 0x60 096
+	{0x00, 0x07, 0x7d, 0xf4, 0x00, }, //'a' 0x61 097
+	{0x08, 0xe1, 0xa4, 0x74, 0x00, }, //'b' 0x62 098
+	{0x00, 0x17, 0x43, 0xf0, 0x00, }, //'c' 0x63 099
+	{0x20, 0xe4, 0x52, 0x72, 0x00, }, //'d' 0x64 100
+	{0x00, 0x17, 0x7f, 0xf0, 0x00, }, //'e' 0x65 101
+	{0x60, 0xe2, 0x09, 0x21, 0x0e, }, //'f' 0x66 102
+	{0x00, 0x26, 0x25, 0x87, 0x0e, }, //'g' 0x67 103
+	{0x08, 0xe1, 0xa4, 0x94, 0x00, }, //'h' 0x68 104
+	{0x10, 0x60, 0x08, 0x71, 0x00, }, //'i' 0x69 105
+	{0x10, 0xe0, 0x10, 0x52, 0x0c, }, //'j' 0x6a 106
+	{0x08, 0x6d, 0x8c, 0x92, 0x00, }, //'k' 0x6b 107
+	{0x18, 0x42, 0x08, 0x61, 0x00, }, //'l' 0x6c 108
+	{0x00, 0x57, 0x6b, 0xad, 0x00, }, //'m' 0x6d 109
+	{0x00, 0x26, 0xa5, 0x94, 0x00, }, //'n' 0x6e 110
+	{0x00, 0x26, 0xa5, 0x64, 0x00, }, //'o' 0x6f 111
+	{0x00, 0x27, 0xa5, 0x13, 0x02, }, //'p' 0x70 112
+	{0x00, 0x97, 0x92, 0x43, 0x08, }, //'q' 0x71 113
+	{0x80, 0x26, 0x84, 0x10, 0x00, }, //'r' 0x72 114
+	{0x00, 0x17, 0x0c, 0x3a, 0x00, }, //'s' 0x73 115
+	{0x88, 0x27, 0x84, 0x62, 0x00, }, //'t' 0x74 116
+	{0x80, 0x1c, 0x63, 0x74, 0x00, }, //'u' 0x75 117
+	{0x80, 0x18, 0x95, 0x22, 0x00, }, //'v' 0x76 118
+	{0x80, 0x58, 0xeb, 0x56, 0x00, }, //'w' 0x77 119
+	{0x80, 0xa9, 0x88, 0x9a, 0x00, }, //'x' 0x78 120
+	{0x80, 0x29, 0x15, 0x23, 0x04, }, //'y' 0x79 121
+	{0x80, 0x8f, 0x88, 0xf8, 0x00, }, //'z' 0x7a 122
+	{0x60, 0x42, 0x04, 0x21, 0x18, }, //'{' 0x7b 123
+	{0x10, 0x42, 0x08, 0x21, 0x04, }, //'|' 0x7c 124
+	{0x0c, 0x42, 0x10, 0x21, 0x03, }, //'}' 0x7d 125
+	{0x00, 0x20, 0x2a, 0x02, 0x00, }, //'~' 0x7e 126
+};
 
+enum
+{
+	YWPANEL_INIT_INSTR_GETVERSION = 0x50,
 
 	YWPANEL_INIT_INSTR_GETCPUSTATE = 0x52,
-	YWPANEL_INIT_INSTR_SETCPUSTATE ,
+	YWPANEL_INIT_INSTR_SETCPUSTATE,
 
-	YWPANEL_INIT_INSTR_GETSTBYKEY1 ,
-	YWPANEL_INIT_INSTR_GETSTBYKEY2 ,
-	YWPANEL_INIT_INSTR_GETSTBYKEY3 ,
-	YWPANEL_INIT_INSTR_GETSTBYKEY4 ,
-	YWPANEL_INIT_INSTR_GETSTBYKEY5 ,
-
-	YWPANEL_INIT_INSTR_SETSTBYKEY1 ,
-	YWPANEL_INIT_INSTR_SETSTBYKEY2 ,
-	YWPANEL_INIT_INSTR_SETSTBYKEY3 ,
-	YWPANEL_INIT_INSTR_SETSTBYKEY4 ,
-	YWPANEL_INIT_INSTR_SETSTBYKEY5 ,
+	YWPANEL_INIT_INSTR_GETSTBYKEY1,
+	YWPANEL_INIT_INSTR_GETSTBYKEY2,
+	YWPANEL_INIT_INSTR_GETSTBYKEY3,
+	YWPANEL_INIT_INSTR_GETSTBYKEY4,
+	YWPANEL_INIT_INSTR_GETSTBYKEY5,
+
+	YWPANEL_INIT_INSTR_SETSTBYKEY1,
+	YWPANEL_INIT_INSTR_SETSTBYKEY2,
+	YWPANEL_INIT_INSTR_SETSTBYKEY3,
+	YWPANEL_INIT_INSTR_SETSTBYKEY4,
+	YWPANEL_INIT_INSTR_SETSTBYKEY5,
 
-	YWPANEL_INIT_INSTR_GETIRCODE , 			/* 0x5e */
+	YWPANEL_INIT_INSTR_GETIRCODE,           /* 0x5e */
 	YWPANEL_INIT_INSTR_SETIRCODE,
 
-
-	YWPANEL_INIT_INSTR_GETENCRYPTMODE,		/* 0x60 */
+	YWPANEL_INIT_INSTR_GETENCRYPTMODE,      /* 0x60 */
 	YWPANEL_INIT_INSTR_SETENCRYPTMODE,
 
-	YWPANEL_INIT_INSTR_GETENCRYPTKEY,		/* 0x62 */
+	YWPANEL_INIT_INSTR_GETENCRYPTKEY,       /* 0x62 */
 	YWPANEL_INIT_INSTR_SETENCRYPTKEY,
 
-
-	YWPANEL_INIT_INSTR_GETVERIFYSTATE , 	/* 0x64 */
+	YWPANEL_INIT_INSTR_GETVERIFYSTATE,      /* 0x64 */
 	YWPANEL_INIT_INSTR_SETVERIFYSTATE,
 
-	YWPANEL_INIT_INSTR_GETTIME, 			/* 0x66 */
-	YWPANEL_INIT_INSTR_SETTIME, 			/* 0x67 */
-	YWPANEL_INIT_INSTR_CONTROLTIMER,		/* 0x68 */
-	YWPANEL_INIT_INSTR_POWERONTIME, 		/* 0x69 */
-	YWPANEL_INIT_INSTR_GETPOWERONTIME,		/* 0x6a */
-
-	YWPANEL_INIT_INSTR_GETVFDSTANDBYSTATE,	/* 0x6b */
-	YWPANEL_INIT_INSTR_SETVFDSTANDBYSTATE,	/* 0x6c */
-
-	YWPANEL_INIT_INSTR_GETBLUEKEY1 ,		/* 0x6d */
-	YWPANEL_INIT_INSTR_GETBLUEKEY2 ,
-	YWPANEL_INIT_INSTR_GETBLUEKEY3 ,
-	YWPANEL_INIT_INSTR_GETBLUEKEY4 ,		/* 0x70 */
-	YWPANEL_INIT_INSTR_GETBLUEKEY5 ,
-
-	YWPANEL_INIT_INSTR_SETBLUEKEY1 ,		/* 0x72 */
-	YWPANEL_INIT_INSTR_SETBLUEKEY2 ,
-	YWPANEL_INIT_INSTR_SETBLUEKEY3 ,
-	YWPANEL_INIT_INSTR_SETBLUEKEY4 ,
-	YWPANEL_INIT_INSTR_SETBLUEKEY5 ,		/* 0x76 */
-
-	YWPANEL_INIT_INSTR_GETPOWERONSTATE, 	/* 0x77 */
-	YWPANEL_INIT_INSTR_SETPOWERONSTATE, 	/* 0x78 */
-
-	YWPANEL_INIT_INSTR_GETSTARTUPSTATE 	/* 0x79 */
+	YWPANEL_INIT_INSTR_GETTIME = 0x66,      /* 0x66 */
+	YWPANEL_INIT_INSTR_SETTIME,             /* 0x67 */
+	YWPANEL_INIT_INSTR_CONTROLTIMER,        /* 0x68 */
+	YWPANEL_INIT_INSTR_POWERONTIME,         /* 0x69 */
+	YWPANEL_INIT_INSTR_GETPOWERONTIME,      /* 0x6a */
+
+	YWPANEL_INIT_INSTR_GETVFDSTANDBYSTATE,  /* 0x6b */
+	YWPANEL_INIT_INSTR_SETVFDSTANDBYSTATE,  /* 0x6c */
+
+	YWPANEL_INIT_INSTR_GETBLUEKEY1,     /* 0x6d */
+	YWPANEL_INIT_INSTR_GETBLUEKEY2,
+	YWPANEL_INIT_INSTR_GETBLUEKEY3,
+	YWPANEL_INIT_INSTR_GETBLUEKEY4,     /* 0x70 */
+	YWPANEL_INIT_INSTR_GETBLUEKEY5,
+
+	YWPANEL_INIT_INSTR_SETBLUEKEY1,     /* 0x72 */
+	YWPANEL_INIT_INSTR_SETBLUEKEY2,
+	YWPANEL_INIT_INSTR_SETBLUEKEY3,
+	YWPANEL_INIT_INSTR_SETBLUEKEY4,
+	YWPANEL_INIT_INSTR_SETBLUEKEY5,     /* 0x76 */
+
+	YWPANEL_INIT_INSTR_GETPOWERONSTATE = 0x77,  /* 0x77 */
+	YWPANEL_INIT_INSTR_SETPOWERONSTATE,     /* 0x78 */
+
+	YWPANEL_INIT_INSTR_GETSTARTUPSTATE,     /* 0x79 */
+	YWPANEL_INIT_INSTR_GETLOOPSTATE = 0x7a, /* 0x80 */ // FIXME. Neither 0x7a nor 0x80 seem to work. Lacks documentation.
+	YWPANEL_INIT_INSTR_SETLOOPSTATE,        /* 0x81 */
+	YWPANEL_INIT_INSTR_SETMVFDDISPLAY = 0x80,       /*0x80*/
+	YWPANEL_INIT_INSTR_STRMVFDBRIGHTNESS,
+	YWPANEL_INIT_INSTR_SETMVFDTIMEMODE,
+	YWPANEL_INIT_INSTR_GETMVFDTIMEMODE,
 
 };
 enum YWPANL_READ_INSTR_e
@@ -368,7 +339,6 @@
 	YWPANEL_READ_INSTR_SCANKEY = 0x11,
 	YWPANEL_READ_INSTR_IRKEY = 0x12,
 	YWPANEL_READ_INSTR_VFDKEY = 0x13
-
 };
 
 enum YWPANL_WRITE_INSTR_e
@@ -376,1498 +346,1081 @@
 	YWPANEL_DISPLAY_INSTR_LBD = 0x30,
 	YWPANEL_DISPLAY_INSTR_LED,
 	YWPANEL_DISPLAY_INSTR_LCD,
-	YWPANEL_DISPLAY_INSTR_VFD
-
+	YWPANEL_DISPLAY_INSTR_VFD,
+	YWPANEL_DISPLAY_INSTR_MVFD_SINGLE,
+	YWPANEL_DISPLAY_INSTR_MVFD,
 };
 
-//#define YWPANEL_FP_I2C_TIMEOUT			200
 #define VFD_CS_CLR() {udelay(10);stpio_set_pin(pio_cs, 0);}
 #define VFD_CS_SET() {udelay(10);stpio_set_pin(pio_cs, 1);}
 
-//static SegAddrVal_T VfdSegAddr[15];
-static struct i2c_adapter*	panel_i2c_adapter;
-//static REMOTE_TYPE		Remote_type_use = REMOTE_NEW;
+static SegAddrVal_T VfdSegAddr[15];
+static struct i2c_adapter  *panel_i2c_adapter;
 
-//const u16 cnCRC_16 = 0x8005;
+static const u16 cnCRC_16 = 0x8005;
 // CRC-16 = X16 + X15 + X2 + X0
-const u16 cnCRC_CCITT = 0x1021;
+static const u16 cnCRC_CCITT = 0x1021;
 // CRC-CCITT = X16 + X12 + X5 + X0
 
-u32 Table_CRC[256]; // CRC
-
-//int  YWPANEL_TranslateKeyCode(u8  KeyPress)
-//{
-//	int 					iUSIF_Key = INVALID_KEY;
-//	int i;
-//
-//	if((Remote_type_use == REMOTE_NEW) || (Remote_type_use == REMOTE_GOLDEN))
-//	{
-//		for(i=0; i<KEN_NUM_NEW; ++i)
-//		{
-//			if(KeyPress== key_table_new[i][1])
-//			{
-//				iUSIF_Key = key_table_new[i][0];
-//				break;
-//			}
-//		}
-//	}
-//	else if(Remote_type_use == REMOTE_TOPFIELD)
-//	{
-//		for(i=0; i<KEY_NUM_TOP; ++i)
-//		{
-//			if(KeyPress== key_table_top[i][1])
-//			{
-//				iUSIF_Key = key_table_top[i][0];
-//				break;
-//			}
-//		}
-//	}
-//	else if((Remote_type_use == REMOTE_EDISION1) || (Remote_type_use == REMOTE_EDISION2))
-//	{
-//		for(i=0; i<KEY_NUM_EDI; ++i)
-//		{
-//			if(KeyPress== key_table_edi[i][1])
-//			{
-//				iUSIF_Key = key_table_edi[i][0];
-//				break;
-//			}
-//		}
-//	}
-//	if(iUSIF_Key == INVALID_KEY)
-//		PANEL_DEBUG("YWPANEL_TranslateKeyCode invalid key!!\n");
-//
-//	return iUSIF_Key;
-//}
-
-//bool to_primitive_key(u8 key,	u32 *prim_key_p)
-//{
-//	bool ret = false;
-//	int i;
-//	u32 tmp = 0;
-//
-//	if((Remote_type_use == REMOTE_NEW) || (Remote_type_use == REMOTE_GOLDEN))
-//	{
-//		for(i=0; i<KEN_NUM_NEW; ++i)
-//		{
-//			if(key== key_table_new[i][0])
-//			{
-//				tmp = key_table_new[i][1];
-//				tmp <<= 8;
-//				tmp |= (~key_table_new[i][1])&0x000000FF;
-//				if(Remote_type_use == REMOTE_GOLDEN)
-//					tmp |= REMOTE_SLAVE_ADDRESS_GOLDEN;
-//				else
-//					tmp |= REMOTE_SLAVE_ADDRESS_NEW;
-//				*prim_key_p = tmp;
-//				ret = true;
-//			}
-//		}
-//	}
-//	else if(Remote_type_use == REMOTE_TOPFIELD)
-//	{
-//		for(i=0; i<KEY_NUM_TOP; ++i)
-//		{
-//			if(key== key_table_top[i][0])
-//			{
-//				tmp = key_table_top[i][1];
-//				tmp <<= 8;
-//				tmp |= (~key_table_top[i][1])&0x000000FF;
-//				tmp |= REMOTE_TOPFIELD_MASK;
-//				*prim_key_p = tmp;
-//				ret = true;
-//			}
-//		}
-//	}
-//	else if((Remote_type_use == REMOTE_EDISION1) || (Remote_type_use == REMOTE_EDISION2))
-//	{
-//		for(i=0; i<KEY_NUM_EDI; ++i)
-//		{
-//			if(key== key_table_edi[i][0])
-//			{
-//				tmp = key_table_edi[i][1];
-//				tmp <<= 8;
-//				tmp |= (~key_table_new[i][1])&0x000000FF;
-//				if(Remote_type_use == REMOTE_EDISION1)
-//					tmp |= REMOTE_SLAVE_ADDRESS_EDISION1;
-//				else
-//					tmp |= REMOTE_SLAVE_ADDRESS_EDISION2;
-//				*prim_key_p = tmp;
-//				ret = true;
-//			}
-//		}
-//	}
-//
-//	return ret;
-//}
+static u32 Table_CRC[256]; // CRC
 
-void YWPANEL_BuildTable16( u16 aPoly )
+static void YWPANEL_BuildTable16(u16 aPoly)
 {
 	u16 i, j;
 	u16 nData;
 	u16 nAccum;
-	for ( i = 0; i < 256; i++ )
+	for (i = 0; i < 256; i++)
 	{
-		nData = ( u16 )( i << 8 );
+		nData = (u16)(i << 8);
 		nAccum = 0;
-		for ( j = 0; j < 8; j++ )
+		for (j = 0; j < 8; j++)
 		{
-			if ( ( nData ^ nAccum ) & 0x8000 )
-				nAccum = ( nAccum << 1 ) ^ aPoly;
+			if ((nData ^ nAccum) & 0x8000)
+				nAccum = (nAccum << 1) ^ aPoly;
 			else
 				nAccum <<= 1;
 			nData <<= 1;
 		}
-		Table_CRC[i] = ( u32 )nAccum;
-	 }
+		Table_CRC[i] = (u32)nAccum;
+	}
 }
 
-u16 YWPANEL_GenerateCRC16( u8 * buffer, u32 bufLength )
+static u16 YWPANEL_GenerateCRC16(u8 *buffer, u32 bufLength)
 {
 	u32 i;
 	u16 nAccum = 0;
-	YWPANEL_BuildTable16( cnCRC_CCITT ); // or cnCRC_CCITT
-	for ( i = 0; i < bufLength; i++ )
-		nAccum = ( nAccum << 8 ) ^ ( u16 )Table_CRC[( nAccum >> 8 ) ^ *buffer++];
+	YWPANEL_BuildTable16(cnCRC_CCITT);   // or cnCRC_CCITT
+	for (i = 0; i < bufLength; i++)
+		nAccum = (nAccum << 8) ^ (u16)Table_CRC[(nAccum >> 8) ^ *buffer++];
 	return nAccum;
 }
-bool YWPANEL_FP_SetI2cData(YWPANEL_FPData_t  *data,YWPANEL_I2CData_t   *I2CData)
+
+static void YWPANEL_FP_DvfdFillCmd(YWPANEL_FPData_t *data, YWPANEL_I2CData_t *I2CData)
+{
+	switch (data->data.dvfdData.type)
+	{
+		case YWPANEL_DVFD_DISPLAYSTRING:
+			I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_MVFD;
+			break;
+		case YWPANEL_DVFD_DISPLAYSYNC:
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETMVFDDISPLAY;
+			break;
+		case YWPANEL_DVFD_SETTIMEMODE:
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETMVFDTIMEMODE;
+			break;
+		case YWPANEL_DVFD_GETTIMEMODE:
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETMVFDTIMEMODE;
+		default:
+			break;
+	}
+}
+
+static void YWPANEL_FP_DvfdFillLen(YWPANEL_FPData_t *data, YWPANEL_I2CData_t *I2CData)
 {
-	u16 			usCRC16 = 0;
+	if (data->data.dvfdData.type == YWPANEL_DVFD_DISPLAYSTRING)
+		I2CData->writeBuff[1] = 1 + (5 + 1) * 4;
+	else
+		I2CData->writeBuff[1] = 0x4;
+}
 
-	if((data == NULL)
-		||(I2CData == NULL)
-		||(data->dataType < YWPANEL_DATATYPE_LBD)
-		||(data->dataType > YWPANEL_DATATYPE_NUM))
+static void YWPANEL_FP_DvfdFillString(YWPANEL_FPData_t *data, YWPANEL_I2CData_t *I2CData, u8 uMax)
+{
+	u8 i;
+	for (i = 0; i < uMax; i++)
 	{
-		PANEL_DEBUG("bad parameter\n");
-		return false;
+		I2CData->writeBuff[6 * i + 3] = data->data.dvfdData.address[i];
+		I2CData->writeBuff[6 * i + 4] = data->data.dvfdData.DisplayValue[i][0];
+		I2CData->writeBuff[6 * i + 5] = data->data.dvfdData.DisplayValue[i][1];
+		I2CData->writeBuff[6 * i + 6] = data->data.dvfdData.DisplayValue[i][2];
+		I2CData->writeBuff[6 * i + 7] = data->data.dvfdData.DisplayValue[i][3];
+		I2CData->writeBuff[6 * i + 8] = data->data.dvfdData.DisplayValue[i][4];
 	}
+}
 
-	switch(data->dataType)
+static void YWPANEL_FP_DvfdFillData(YWPANEL_FPData_t *data, YWPANEL_I2CData_t *I2CData)
+{
+	switch (data->data.dvfdData.type)
 	{
-		case YWPANEL_DATATYPE_LBD:
+		case YWPANEL_DVFD_DISPLAYSTRING:
 		{
-			I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LBD;
+			u8  uMax = data->data.dvfdData.ulen;
+			if (uMax > 4)
+				uMax = 4;
+			I2CData->writeBuff[2] = uMax;
+			YWPANEL_FP_DvfdFillString(data, I2CData, uMax);
+			break;
 		}
-		break;
+		case YWPANEL_DVFD_SETTIMEMODE:
+			I2CData->writeBuff[2] = data->data.dvfdData.setValue;
+		default:
+			break;
+	}
+}
 
-		case YWPANEL_DATATYPE_LCD:
-		{
-            //I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LED;
-            I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LCD;	//d48zm modify
-		}
-		break;
+static void YWPANEL_FP_DvfdFillCrc(YWPANEL_FPData_t *data, YWPANEL_I2CData_t *I2CData)
+{
+	u16 usCRC16 = 0;
+	if (data->data.dvfdData.type == YWPANEL_DVFD_DISPLAYSTRING)
+	{
+		usCRC16 = YWPANEL_GenerateCRC16(I2CData->writeBuff, 27);
+		I2CData->writeBuff[27] = (usCRC16 & 0xff);
+		I2CData->writeBuff[28] = ((usCRC16 >> 8) & 0xff);
+		I2CData->writeBuffLen = 29;
+	}
+	else
+	{
+		usCRC16 = YWPANEL_GenerateCRC16(I2CData->writeBuff, 6);
+		I2CData->writeBuff[6] = (usCRC16 & 0xff);
+		I2CData->writeBuff[7] = ((usCRC16 >> 8) & 0xff);
+		I2CData->writeBuffLen = 8;
+	}
+}
 
+static int YWPANEL_FP_SetI2cData(YWPANEL_FPData_t  *data, YWPANEL_I2CData_t   *I2CData)
+{
+	u16             usCRC16 = 0;
+	if ((data == NULL)
+			|| (I2CData == NULL)
+			|| (data->dataType < YWPANEL_DATATYPE_LBD)
+			|| (data->dataType > YWPANEL_DATATYPE_NUM))
+	{
+		PANEL_DEBUG("bad parameter\n");
+		return false;
+	}
+	switch (data->dataType)
+	{
+		case YWPANEL_DATATYPE_LBD:
+			I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LBD;
+			break;
+		case YWPANEL_DATATYPE_LCD:
+			I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LCD;
+			break;
 		case YWPANEL_DATATYPE_LED:
-		{
-            //I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LCD;
-            I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LED;	//d48zm modify
-		}
-		break;
-
+			I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_LED;
+			break;
 		case YWPANEL_DATATYPE_VFD:
-		{
 			I2CData->writeBuff[0] = YWPANEL_DISPLAY_INSTR_VFD;
-		}
-		break;
-
+			break;
+		case YWPANEL_DATATYPE_DVFD:
+			YWPANEL_FP_DvfdFillCmd(data, I2CData);
+			break;
 		case YWPANEL_DATATYPE_SCANKEY:
-		{
 			I2CData->writeBuff[0] = YWPANEL_READ_INSTR_SCANKEY;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_IRKEY:
-		{
-			I2CData->writeBuff[0] = YWPANEL_READ_INSTR_IRKEY;
-		}
-		break;
-
-		case  YWPANEL_DATATYPE_GETVERSION:
-		{
+			break;
+		case YWPANEL_DATATYPE_GETVERSION:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETVERSION;
-		}
-		break;
-
-		case  YWPANEL_DATATYPE_GETCPUSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_GETCPUSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETCPUSTATE;
-		}
-		break;
-
-		case  YWPANEL_DATATYPE_SETCPUSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_SETCPUSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETCPUSTATE;
-		}
-		break;
-
-		case  YWPANEL_DATATYPE_GETSTARTUPSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_GETSTARTUPSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETSTARTUPSTATE;
-		}
-		break;
-		case  YWPANEL_DATATYPE_GETVFDSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_GETVFDSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETVFDSTANDBYSTATE;
-		}
-		break;
-
-		case  YWPANEL_DATATYPE_SETVFDSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_SETVFDSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETVFDSTANDBYSTATE;
-		}
-		break;
-
-		case  YWPANEL_DATATYPE_GETPOWERONSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_GETPOWERONSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETPOWERONSTATE;
-		}
-		break;
-
-		case  YWPANEL_DATATYPE_SETPOWERONSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_SETPOWERONSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETPOWERONSTATE;
-		}
-		break;
-
+			break;
 		case YWPANEL_DATATYPE_GETSTBYKEY1:
 		case YWPANEL_DATATYPE_GETSTBYKEY2:
 		case YWPANEL_DATATYPE_GETSTBYKEY3:
 		case YWPANEL_DATATYPE_GETSTBYKEY4:
 		case YWPANEL_DATATYPE_GETSTBYKEY5:
-		{
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETSTBYKEY1 + (data->dataType - YWPANEL_DATATYPE_GETSTBYKEY1);
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_SETSTBYKEY1:
-		case	YWPANEL_DATATYPE_SETSTBYKEY2:
-		case	YWPANEL_DATATYPE_SETSTBYKEY3:
-		case	YWPANEL_DATATYPE_SETSTBYKEY4:
-		case	YWPANEL_DATATYPE_SETSTBYKEY5:
-		{
-			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETSTBYKEY1+data->dataType - YWPANEL_DATATYPE_SETSTBYKEY1;
-		}
-		break;
- //add for blue key
+			break;
+		case YWPANEL_DATATYPE_SETSTBYKEY1:
+		case YWPANEL_DATATYPE_SETSTBYKEY2:
+		case YWPANEL_DATATYPE_SETSTBYKEY3:
+		case YWPANEL_DATATYPE_SETSTBYKEY4:
+		case YWPANEL_DATATYPE_SETSTBYKEY5:
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETSTBYKEY1 + (data->dataType - YWPANEL_DATATYPE_SETSTBYKEY1);
+			break;
 		case YWPANEL_DATATYPE_GETBLUEKEY1:
 		case YWPANEL_DATATYPE_GETBLUEKEY2:
 		case YWPANEL_DATATYPE_GETBLUEKEY3:
 		case YWPANEL_DATATYPE_GETBLUEKEY4:
 		case YWPANEL_DATATYPE_GETBLUEKEY5:
-		{
-		  I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETBLUEKEY1 + (data->dataType - YWPANEL_DATATYPE_GETBLUEKEY1);
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_SETBLUEKEY1:
-		case	YWPANEL_DATATYPE_SETBLUEKEY2:
-		case	YWPANEL_DATATYPE_SETBLUEKEY3:
-		case	YWPANEL_DATATYPE_SETBLUEKEY4:
-		case	YWPANEL_DATATYPE_SETBLUEKEY5:
-		{
-		  I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETBLUEKEY1+data->dataType - YWPANEL_DATATYPE_SETBLUEKEY1;
-		}
-		break;
-//add end
-		case	YWPANEL_DATATYPE_GETIRCODE:
-		{
-			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETIRCODE;
-		}
-		break;
-
-
-		case	YWPANEL_DATATYPE_SETIRCODE:
-		{
-			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETIRCODE;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_GETENCRYPTMODE:
-		{
-			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETENCRYPTMODE;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_SETENCRYPTMODE:
-		{
-			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETENCRYPTMODE;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_GETENCRYPTKEY:
-		{
-			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETENCRYPTKEY;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_SETENCRYPTKEY:
-		{
-			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETENCRYPTKEY;
-		}
-		break;
-
-		case   YWPANEL_DATATYPE_GETVERIFYSTATE:
-		{
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETBLUEKEY1 + (data->dataType - YWPANEL_DATATYPE_GETBLUEKEY1);
+			break;
+		case YWPANEL_DATATYPE_SETBLUEKEY1:
+		case YWPANEL_DATATYPE_SETBLUEKEY2:
+		case YWPANEL_DATATYPE_SETBLUEKEY3:
+		case YWPANEL_DATATYPE_SETBLUEKEY4:
+		case YWPANEL_DATATYPE_SETBLUEKEY5:
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETBLUEKEY1 + (data->dataType - YWPANEL_DATATYPE_SETBLUEKEY1);
+			break;
+		case YWPANEL_DATATYPE_GETVERIFYSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETVERIFYSTATE;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_SETVERIFYSTATE:
-		{
+			break;
+		case YWPANEL_DATATYPE_SETVERIFYSTATE:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETVERIFYSTATE;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_GETTIME:
-		{
+			break;
+		case YWPANEL_DATATYPE_GETTIME:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETTIME;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_SETTIME:
-		{
+			break;
+		case YWPANEL_DATATYPE_SETTIME:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETTIME;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_CONTROLTIMER:
-		{
+			break;
+		case YWPANEL_DATATYPE_CONTROLTIMER:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_CONTROLTIMER;
-		}
-		break;
-
-		case	YWPANEL_DATATYPE_SETPOWERONTIME:
-		{
+			break;
+		case YWPANEL_DATATYPE_SETPOWERONTIME:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_POWERONTIME;
-		}
-		break;
-		case	YWPANEL_DATATYPE_GETPOWERONTIME:
-		{
+			break;
+		case YWPANEL_DATATYPE_GETPOWERONTIME:
 			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETPOWERONTIME;
-		}
-		break;
+			break;
+		case YWPANEL_DATATYPE_SETLOOPSTATE:
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_SETLOOPSTATE;
+			break;
+		case YWPANEL_DATATYPE_GETLOOPSTATE:
+			I2CData->writeBuff[0] = YWPANEL_INIT_INSTR_GETLOOPSTATE;
+			break;
 		default:
-		break;
-
+			break;
 	}
-
-	switch(data->dataType)
+	switch (data->dataType)
 	{
 		case YWPANEL_DATATYPE_VFD:
-		{
-
-			if(data->data.vfdData.type == YWPANEL_VFD_DISPLAYSTRING)
-			{
+			if (data->data.vfdData.type == YWPANEL_VFD_DISPLAYSTRING)
 				I2CData->writeBuff[1] = 0x22;
-			}
 			else
-			{
 				I2CData->writeBuff[1] = 0x4;
-			}
-		}
-		break;
-
+			break;
+		case YWPANEL_DATATYPE_DVFD:
+			YWPANEL_FP_DvfdFillLen(data, I2CData);
+			break;
 		default:
-		{
 			I2CData->writeBuff[1] = 0x4;
-		}
-		break;
+			break;
 	}
-
-	switch(data->dataType)
+	switch (data->dataType)
 	{
 		case YWPANEL_DATATYPE_LBD:
-		{
 			I2CData->writeBuff[2] = data->data.lbdData.value;
-		}
-		break;
-
+			break;
 		case YWPANEL_DATATYPE_LCD:
-		{
 			I2CData->writeBuff[2] = data->data.lcdData.value;
-		}
-		break;
-
+			break;
 		case YWPANEL_DATATYPE_LED:
-		{
 			I2CData->writeBuff[2] = data->data.ledData.led1;
 			I2CData->writeBuff[3] = data->data.ledData.led2;
 			I2CData->writeBuff[4] = data->data.ledData.led3;
 			I2CData->writeBuff[5] = data->data.ledData.led4;
-		}
-		break;
-
+			break;
 		case YWPANEL_DATATYPE_VFD:
-		{
 			I2CData->writeBuff[2] = data->data.vfdData.type;
-			switch(data->data.vfdData.type)
+			switch (data->data.vfdData.type)
 			{
 				case YWPANEL_VFD_SETTING:
-				{
 					I2CData->writeBuff[3] = data->data.vfdData.setValue;
-				}
-				break;
+					break;
 				case YWPANEL_VFD_DISPLAY:
-				{
 					I2CData->writeBuff[3] = data->data.vfdData.address[0];
 					I2CData->writeBuff[4] = data->data.vfdData.DisplayValue[0];
-				}
-				break;
+					break;
 				case YWPANEL_VFD_READKEY:
-				{
 					I2CData->writeBuff[3] = data->data.vfdData.key;
-				}
-				break;
+					break;
 				case YWPANEL_VFD_DISPLAYSTRING:
 				{
 					int i;
-					for(i=0; i<16;i++)
+					for (i = 0; i < 16; i++)
 					{
-						I2CData->writeBuff[4+2*i] = data->data.vfdData.address[i];
-						I2CData->writeBuff[4+2*i+1] = data->data.vfdData.DisplayValue[i];
+						I2CData->writeBuff[4 + 2 * i] = data->data.vfdData.address[i];
+						I2CData->writeBuff[4 + 2 * i + 1] = data->data.vfdData.DisplayValue[i];
 					}
+					break;
 				}
-				break;
 			}
-		}
-		break;
-
+			break;
+		case YWPANEL_DATATYPE_DVFD:
+			YWPANEL_FP_DvfdFillData(data, I2CData);
+			break;
 		case YWPANEL_DATATYPE_SETCPUSTATE:
-		{
 			I2CData->writeBuff[2] = data->data.CpuState.state;
-		}
-		break;
-
+			break;
 		case YWPANEL_DATATYPE_GETSTARTUPSTATE:
-		{
-			I2CData->writeBuff[2] = data->data.CpuState.state;
-		}
-		break;
-
+			I2CData->writeBuff[2] = data->data.StartUpState.State;
+			break;
 		case YWPANEL_DATATYPE_SETVFDSTATE:
-		{
-		   I2CData->writeBuff[2] = data->data.CpuState.state;
-		}
-		break;
-
+			I2CData->writeBuff[2] = data->data.VfdStandbyState.On;
+			break;
 		case YWPANEL_DATATYPE_SETPOWERONSTATE:
-		{
-			I2CData->writeBuff[2] = data->data.CpuState.state;
-		}
-		break;
-
+			I2CData->writeBuff[2] = data->data.PowerOnState.state;
+			break;
+		case YWPANEL_DATATYPE_SETLOOPSTATE:
+			I2CData->writeBuff[2] = data->data.LoopState.state;
+			break;
+		case YWPANEL_DATATYPE_SETVERIFYSTATE:
+			I2CData->writeBuff[2] = data->data.verifyState.state;
+			break;
+		case YWPANEL_DATATYPE_SETTIME:
+		case YWPANEL_DATATYPE_SETPOWERONTIME:
+			I2CData->writeBuff[2] = (u8)((data->data.time.second >> 24) & 0xff);
+			I2CData->writeBuff[3] = (u8)((data->data.time.second >> 16) & 0xff);
+			I2CData->writeBuff[4] = (u8)((data->data.time.second >> 8) & 0xff);
+			I2CData->writeBuff[5] = (u8)(data->data.time.second & 0xff);
+			break;
+		case YWPANEL_DATATYPE_CONTROLTIMER:
+			I2CData->writeBuff[2] = data->data.TimeState.startFlag;
+			break;
 		case YWPANEL_DATATYPE_SETSTBYKEY1:
 		case YWPANEL_DATATYPE_SETSTBYKEY2:
 		case YWPANEL_DATATYPE_SETSTBYKEY3:
 		case YWPANEL_DATATYPE_SETSTBYKEY4:
 		case YWPANEL_DATATYPE_SETSTBYKEY5:
-		{
-			I2CData->writeBuff[2] = (u8) ((data->data.stbyKey.key>>24)&0xff);
-			I2CData->writeBuff[3] = (u8) ((data->data.stbyKey.key >>16)&0xff);
-			I2CData->writeBuff[4] = (u8) ((data->data.stbyKey.key >>8)&0xff);
-			I2CData->writeBuff[5] = (u8) (data->data.stbyKey.key&0xff);
-		}
-		break;
-//add for blue key
 		case YWPANEL_DATATYPE_SETBLUEKEY1:
 		case YWPANEL_DATATYPE_SETBLUEKEY2:
 		case YWPANEL_DATATYPE_SETBLUEKEY3:
 		case YWPANEL_DATATYPE_SETBLUEKEY4:
 		case YWPANEL_DATATYPE_SETBLUEKEY5:
-		{
-			I2CData->writeBuff[2] = (u8) ((data->data.BlueKey.key>>24)&0xff);
-			I2CData->writeBuff[3] = (u8) ((data->data.BlueKey.key >>16)&0xff);
-			I2CData->writeBuff[4] = (u8) ((data->data.BlueKey.key >>8)&0xff);
-			I2CData->writeBuff[5] = (u8) (data->data.BlueKey.key&0xff);
-		}
-		break;
-//add end
-		case YWPANEL_DATATYPE_SETIRCODE:
-		{
-			I2CData->writeBuff[2] =  data->data.irCode.code;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_SETENCRYPTMODE:
-		{
-			I2CData->writeBuff[2] =  data->data.EncryptMode.mode;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_SETENCRYPTKEY:
-		{
-			I2CData->writeBuff[2] = (u8) ((data->data.EncryptKey.key>>24)&0xff);
-			I2CData->writeBuff[3] = (u8) ((data->data.EncryptKey.key >>16)&0xff);
-			I2CData->writeBuff[4] = (u8) ((data->data.EncryptKey.key >>8)&0xff);
-			I2CData->writeBuff[5] = (u8) (data->data.EncryptKey.key&0xff);
-		}
-		break;
-
-		case YWPANEL_DATATYPE_SETVERIFYSTATE:
-		{
-			I2CData->writeBuff[2] = data->data.verifyState.state;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_SETTIME:
-		{
-			I2CData->writeBuff[2] = (u8) ((data->data.time.second>>24)&0xff);
-			I2CData->writeBuff[3] = (u8) ((data->data.time.second >>16)&0xff);
-			I2CData->writeBuff[4] = (u8) ((data->data.time.second >>8)&0xff);
-			I2CData->writeBuff[5] = (u8) (data->data.time.second&0xff);
-		}
-		break;
-
-		case YWPANEL_DATATYPE_CONTROLTIMER:
-		{
-			I2CData->writeBuff[2] = data->data.TimeState.startFlag;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_SETPOWERONTIME:
-		{
-			I2CData->writeBuff[2] = (u8) ((data->data.time.second>>24)&0xff);
-			I2CData->writeBuff[3] = (u8) ((data->data.time.second >>16)&0xff);
-			I2CData->writeBuff[4] = (u8) ((data->data.time.second >>8)&0xff);
-			I2CData->writeBuff[5] = (u8) (data->data.time.second&0xff);
-		}
-		break;
-
+			I2CData->writeBuff[2] = (u8)((data->data.stbyKey.key >> 24) & 0xff);
+			I2CData->writeBuff[3] = (u8)((data->data.stbyKey.key >> 16) & 0xff);
+			I2CData->writeBuff[4] = (u8)((data->data.stbyKey.key >> 8) & 0xff);
+			I2CData->writeBuff[5] = (u8)(data->data.stbyKey.key & 0xff);
+			break;
 		default:
-		break;
+			break;
 	}
-
-	switch(data->dataType)
+	switch (data->dataType)
 	{
+		case YWPANEL_DATATYPE_DVFD:
+			YWPANEL_FP_DvfdFillCrc(data, I2CData);
+			break;
 		case YWPANEL_DATATYPE_VFD:
-		{
-			if(data->data.vfdData.type == YWPANEL_VFD_DISPLAYSTRING)
+			if (data->data.vfdData.type == YWPANEL_VFD_DISPLAYSTRING)
 			{
 				usCRC16 = YWPANEL_GenerateCRC16(I2CData->writeBuff, 36);
-				I2CData->writeBuff[36] =  (usCRC16 &0xff);
-				I2CData->writeBuff[37] =  ((usCRC16>>8) &0xff);
+				I2CData->writeBuff[36] = (usCRC16 & 0xff);
+				I2CData->writeBuff[37] = ((usCRC16 >> 8) & 0xff);
 				I2CData->writeBuffLen = 38;
+				break;
 			}
-			else
-			{
-				usCRC16 = YWPANEL_GenerateCRC16(I2CData->writeBuff, 6);
-				I2CData->writeBuff[6] =  (usCRC16 &0xff);
-				I2CData->writeBuff[7] =  ((usCRC16>>8) &0xff);
-				I2CData->writeBuffLen = 8;
-			}
-		}
-		break;
-
+		// fallthrough
 		default:
-		{
 			usCRC16 = YWPANEL_GenerateCRC16(I2CData->writeBuff, 6);
-			I2CData->writeBuff[6] =  (usCRC16 &0xff);
-			I2CData->writeBuff[7] =  ((usCRC16>>8) &0xff);
+			I2CData->writeBuff[6] = (usCRC16 & 0xff);
+			I2CData->writeBuff[7] = ((usCRC16 >> 8) & 0xff);
 			I2CData->writeBuffLen = 8;
-		}
-		break;
+			break;
 	}
-
 	return true;
 }
 
-bool YWPANEL_FP_ParseI2cData(YWPANEL_FPData_t  *data,YWPANEL_I2CData_t	 *I2CData)
+static int YWPANEL_FP_ParseI2cData(YWPANEL_FPData_t  *data, YWPANEL_I2CData_t     *I2CData)
 {
-	u16 	crc16Code = 0;
-	u16 	receiveCode = 0;
-
-	u8		dataType;
-	u8		datalength;
-
-	if((data == NULL) ||(I2CData == NULL))
+	u16 crc16Code = 0;
+	u16 receiveCode = 0;
+	u8  dataType;
+	u8  datalength;
+	if ((data == NULL) || (I2CData == NULL))
 	{
-		ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+		ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 		return false;
 	}
-	receiveCode =((u16)(I2CData->readBuff[7]<<8)&0xff00) |((u16)(I2CData->readBuff[6])&0xff);
+	receiveCode = ((u16)(I2CData->readBuff[7] << 8) & 0xff00) | ((u16)(I2CData->readBuff[6]) & 0xff);
 	crc16Code = YWPANEL_GenerateCRC16(I2CData->readBuff, 6);
-
-	if(receiveCode != crc16Code )
+	if (receiveCode != crc16Code)
 	{
-		ywtrace_print(TRACE_ERROR,"check crc16 is wrong! at %d \n",__LINE__);
-	    //	return false;  //YWDRIVER_MODI lwj remove
+		ywtrace_print(TRACE_ERROR, "check crc16 is wrong! at %d \n", __LINE__);
+		//  return false;  //YWDRIVER_MODI lwj remove
 	}
-
 	//ywtrace_print(TRACE_INFO,"%s::date->dateType=[0x%x]\n",__FUNCTION__,data->dataType);
 	dataType = I2CData->readBuff[0];
 	datalength = I2CData->readBuff[1];
-//	if (dataType != 80 && dataType != 17) {
-//	printk("VFD-> commanda %x read %x, len %d\n", data->dataType, dataType, datalength);
-//	}
 	//zy 2008-10-07
-	switch(data->dataType)
+	switch (data->dataType)
 	{
 		case YWPANEL_DATATYPE_LBD:
 		case YWPANEL_DATATYPE_LCD:
 		case YWPANEL_DATATYPE_LED:
 		case YWPANEL_DATATYPE_SETCPUSTATE:
-		case YWPANEL_DATATYPE_SETSTBYKEY1:
-		case YWPANEL_DATATYPE_SETSTBYKEY2:
-		case YWPANEL_DATATYPE_SETSTBYKEY3:
-		case YWPANEL_DATATYPE_SETSTBYKEY4:
-		case YWPANEL_DATATYPE_SETSTBYKEY5:
-		case YWPANEL_DATATYPE_SETIRCODE:
-		case YWPANEL_DATATYPE_SETENCRYPTMODE:
-		case YWPANEL_DATATYPE_SETENCRYPTKEY:
 		case YWPANEL_DATATYPE_SETVERIFYSTATE:
 		case YWPANEL_DATATYPE_SETTIME:
 		case YWPANEL_DATATYPE_CONTROLTIMER:
 		case YWPANEL_DATATYPE_SETPOWERONTIME:
 		case YWPANEL_DATATYPE_SETVFDSTANDBYSTATE:
+		case YWPANEL_DATATYPE_SETPOWERONSTATE:
+		case YWPANEL_DATATYPE_SETLOOPSTATE:
+		case YWPANEL_DATATYPE_SETSTBYKEY1:
+		case YWPANEL_DATATYPE_SETSTBYKEY2:
+		case YWPANEL_DATATYPE_SETSTBYKEY3:
+		case YWPANEL_DATATYPE_SETSTBYKEY4:
+		case YWPANEL_DATATYPE_SETSTBYKEY5:
 		case YWPANEL_DATATYPE_SETBLUEKEY1:
 		case YWPANEL_DATATYPE_SETBLUEKEY2:
 		case YWPANEL_DATATYPE_SETBLUEKEY3:
 		case YWPANEL_DATATYPE_SETBLUEKEY4:
 		case YWPANEL_DATATYPE_SETBLUEKEY5:
-		case YWPANEL_DATATYPE_SETPOWERONSTATE:
-		case YWPANEL_DATATYPE_SETLOOPSTATE:
-		{
-			if(dataType != YWPANEL_READ_INSTR_ACK)
+			if (dataType != YWPANEL_READ_INSTR_ACK)
 			{
-				ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+				ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 				return false;
 			}
-		}
-		break;
-
+			break;
 		case YWPANEL_DATATYPE_SCANKEY:
-		{
-			if(dataType != 0x11)
+			if (dataType != YWPANEL_READ_INSTR_SCANKEY)
 			{
-				ywtrace_print(TRACE_ERROR,"%s::error @%d dataType = %d\n",__FUNCTION__,__LINE__, dataType);
+				ywtrace_print(TRACE_ERROR, "%s::error @%d dataType = %d\n", __FUNCTION__, __LINE__, dataType);
 				return false;
 			}
-		}
-		break;
-
-
+			break;
 		case YWPANEL_DATATYPE_VFD:
-		{
-			if(data->data.vfdData.type == YWPANEL_VFD_READKEY)
+			if (data->data.vfdData.type == YWPANEL_VFD_READKEY)
 			{
-				if(dataType != YWPANEL_READ_INSTR_VFDKEY)
+				if (dataType != YWPANEL_READ_INSTR_VFDKEY)
 				{
-					ywtrace_print(TRACE_ERROR,"%s::error @%d dataType = %d\n",__FUNCTION__,__LINE__, dataType);
+					ywtrace_print(TRACE_ERROR, "%s::error @%d dataType = %d\n", __FUNCTION__, __LINE__, dataType);
 					return false;
 				}
 			}
 			else
 			{
-				if(dataType != YWPANEL_READ_INSTR_ACK)
+				if (dataType != YWPANEL_READ_INSTR_ACK)
 				{
-					ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+					ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 					return false;
 				}
 			}
-		}
-		break;
-
+			break;
+		case YWPANEL_DATATYPE_DVFD:
+			if (data->data.dvfdData.type == YWPANEL_DVFD_DISPLAYSTRING)
+			{
+				if (dataType != YWPANEL_READ_INSTR_ACK)
+					return false;
+			}
+			else if (data->data.dvfdData.type == YWPANEL_DVFD_SETTIMEMODE)
+			{
+				if (dataType != YWPANEL_READ_INSTR_ACK)
+					return false;
+			}
+			else if (data->data.dvfdData.type == YWPANEL_DVFD_GETTIMEMODE)
+			{
+				if (dataType != YWPANEL_INIT_INSTR_GETMVFDTIMEMODE)
+					return false;
+			}
+			else if (dataType != YWPANEL_READ_INSTR_ACK)
+				return false;
+			break;
+		case YWPANEL_DATATYPE_GETPOWERONTIME:
+			if (dataType != YWPANEL_INIT_INSTR_GETPOWERONTIME)
+				return false;
+			break;
+		case YWPANEL_DATATYPE_GETPOWERONSTATE:
+			if (dataType != YWPANEL_INIT_INSTR_GETPOWERONSTATE)
+				return false;
+			break;
+		case YWPANEL_DATATYPE_GETSTARTUPSTATE:
+			if (dataType != YWPANEL_INIT_INSTR_GETSTARTUPSTATE)
+				return false;
+			break;
+		case YWPANEL_DATATYPE_GETLOOPSTATE:
+			printk("%s:%d: dataType == %d\n", __FUNCTION__, __LINE__, dataType);
+			if (dataType != YWPANEL_INIT_INSTR_GETLOOPSTATE)
+				return false;
+			break;
+		case YWPANEL_DATATYPE_GETTIME:
+			if (dataType != YWPANEL_INIT_INSTR_GETTIME)
+			{
+				ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
+				return false;
+			}
+			break;
 		case YWPANEL_DATATYPE_GETSTBYKEY1:
 		case YWPANEL_DATATYPE_GETSTBYKEY2:
 		case YWPANEL_DATATYPE_GETSTBYKEY3:
 		case YWPANEL_DATATYPE_GETSTBYKEY4:
 		case YWPANEL_DATATYPE_GETSTBYKEY5:
-		{
-			if(dataType != (YWPANEL_INIT_INSTR_GETSTBYKEY1+ data->dataType -YWPANEL_DATATYPE_GETSTBYKEY1))
+			if (dataType != (YWPANEL_INIT_INSTR_GETSTBYKEY1 + data->dataType - YWPANEL_DATATYPE_GETSTBYKEY1))
 			{
-				ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+				ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 				return false;
 			}
-		}
-		break;
-
-		case YWPANEL_DATATYPE_GETPOWERONTIME:
-		{
-			if(dataType != YWPANEL_INIT_INSTR_GETPOWERONTIME)
-				return false;
-		}
-		break;
-
+			break;
 		case YWPANEL_DATATYPE_GETBLUEKEY1:
 		case YWPANEL_DATATYPE_GETBLUEKEY2:
 		case YWPANEL_DATATYPE_GETBLUEKEY3:
 		case YWPANEL_DATATYPE_GETBLUEKEY4:
 		case YWPANEL_DATATYPE_GETBLUEKEY5:
-		{
-			if(dataType != (YWPANEL_INIT_INSTR_GETBLUEKEY1+ data->dataType -YWPANEL_DATATYPE_GETBLUEKEY1))
-			{
-				ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
-				return false;
-			}
-		}
-		break;
-		case YWPANEL_DATATYPE_GETPOWERONSTATE:
-		{
-			if(dataType != 0x77)
-				return false;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_GETSTARTUPSTATE:
-		{
-			if(dataType != 0x79)
-				return false;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_GETLOOPSTATE:
-		{
-			if(dataType != 0x7a)
-				return false;
-		}
-		break;
-
-		case YWPANEL_DATATYPE_GETTIME:
-		{
-			if(dataType != YWPANEL_INIT_INSTR_GETTIME)
+			if (dataType != (YWPANEL_INIT_INSTR_GETBLUEKEY1 + data->dataType - YWPANEL_DATATYPE_GETBLUEKEY1))
 			{
-				ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+				ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 				return false;
 			}
-		}
-		break;
-
-		case YWPANEL_DATATYPE_IRKEY:
+			break;
 		case YWPANEL_DATATYPE_GETVERSION:
 		case YWPANEL_DATATYPE_GETCPUSTATE:
-		case YWPANEL_DATATYPE_GETIRCODE:
-		case YWPANEL_DATATYPE_GETENCRYPTKEY:
-		case YWPANEL_DATATYPE_GETENCRYPTMODE:
 		case YWPANEL_DATATYPE_GETVERIFYSTATE:
 		default:
-		{
-
-		}
-		break;
-
+			;
 	}
-
-
-	switch(dataType)
+	switch (dataType)
 	{
 		case YWPANEL_READ_INSTR_ACK:  //ACK
-		{
 			data->ack = true;
-		}
-		break;
-
+			break;
 		case YWPANEL_READ_INSTR_SCANKEY:  //scan key
-		{
-			data->data.ScanKeyData.keyValue= I2CData->readBuff[2];
-			data->ack = true;
-		}
-		break;
-
-		case YWPANEL_READ_INSTR_IRKEY:
-		{
-			data->data.IrkeyData.customCode = ((I2CData->readBuff[3] <<8)&0xff00)|(I2CData->readBuff[2]);
-			data->data.IrkeyData.dataCode = ((I2CData->readBuff[5] <<8)&0xff00)|(I2CData->readBuff[4]);
+			data->data.ScanKeyData.keyValue = I2CData->readBuff[2];
 			data->ack = true;
-		}
-		break;
-
+			break;
 		case YWPANEL_READ_INSTR_VFDKEY:
-		{
 			data->data.vfdData.key = I2CData->readBuff[2];
 			data->ack = true;
-		}
-		break;
-
+			break;
 		case YWPANEL_INIT_INSTR_GETVERSION: /*get version */
-		{
-			if(data->dataType != YWPANEL_DATATYPE_GETVERSION)
+			if (data->dataType != YWPANEL_DATATYPE_GETVERSION)
 			{
-				ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+				ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 				return false;
 			}
 			data->data.version.CpuType = I2CData->readBuff[2];
-			data->data.version.DisplayInfo = (I2CData->readBuff[3]>>4)&0x0f;
-			data->data.version.scankeyNum = I2CData->readBuff[3]&0x0f;
+			data->data.version.DisplayInfo = (I2CData->readBuff[3] >> 4) & 0x0f;
+			data->data.version.scankeyNum = I2CData->readBuff[3] & 0x0f;
 			data->data.version.swMajorVersion = I2CData->readBuff[4];
 			data->data.version.swSubVersion = I2CData->readBuff[5];
-
 			data->ack = true;
-		}
-		break;
-
+			break;
 		case YWPANEL_INIT_INSTR_GETCPUSTATE: /*get cpu state*/
-		{
-			if(data->dataType == YWPANEL_DATATYPE_GETCPUSTATE)
+			if (data->dataType == YWPANEL_DATATYPE_GETCPUSTATE)
 			{
-				data->data.CpuState.state= I2CData->readBuff[2];
+				data->data.CpuState.state = I2CData->readBuff[2];
 				data->ack = true;
 			}
 			else
 			{
-				ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+				ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 				return false;
 			}
-		}
-		break;
-
+			break;
 		case YWPANEL_INIT_INSTR_GETVFDSTANDBYSTATE: /*get vfd state*/
-		{
-			   data->data.CpuState.state= I2CData->readBuff[2];
-			   data->ack = true;
-		}
-		break;
+			data->data.VfdStandbyState.On = I2CData->readBuff[2];
+			data->ack = true;
+			break;
 		case YWPANEL_INIT_INSTR_GETPOWERONSTATE: /*get power on  state*/
-		{
-		   if(data->dataType == YWPANEL_DATATYPE_GETPOWERONSTATE)
-		   {
-			   data->data.CpuState.state= I2CData->readBuff[2];
-			   data->ack = true;
-		   }
-		   else
-		   {
-			   ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
-			   return false;
-		   }
-		}
-		break;
-
-
-		case YWPANEL_INIT_INSTR_GETSTBYKEY1: /*get standby key*/
-		case YWPANEL_INIT_INSTR_GETSTBYKEY2: /*get standby key*/
-		case YWPANEL_INIT_INSTR_GETSTBYKEY3: /*get standby key*/
-		case YWPANEL_INIT_INSTR_GETSTBYKEY4: /*get standby key*/
-		case YWPANEL_INIT_INSTR_GETSTBYKEY5: /*get standby key*/
-		{
-			data->data.stbyKey.key = ((I2CData->readBuff[2]<<24)&0xff000000)
-												|((I2CData->readBuff[3]<<16)&0xff0000)
-												|((I2CData->readBuff[4]<<8)&0xff00)
-												|((I2CData->readBuff[5])&0xff);
+			if (data->dataType == YWPANEL_DATATYPE_GETPOWERONSTATE)
+			{
+				data->data.PowerOnState.state = I2CData->readBuff[2];
+				data->ack = true;
+			}
+			else
+			{
+				ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
+				return false;
+			}
+			break;
+		case YWPANEL_INIT_INSTR_GETBLUEKEY1:
+		case YWPANEL_INIT_INSTR_GETBLUEKEY2:
+		case YWPANEL_INIT_INSTR_GETBLUEKEY3:
+		case YWPANEL_INIT_INSTR_GETBLUEKEY4:
+		case YWPANEL_INIT_INSTR_GETBLUEKEY5:
+		case YWPANEL_INIT_INSTR_GETSTBYKEY1:
+		case YWPANEL_INIT_INSTR_GETSTBYKEY2:
+		case YWPANEL_INIT_INSTR_GETSTBYKEY3:
+		case YWPANEL_INIT_INSTR_GETSTBYKEY4:
+		case YWPANEL_INIT_INSTR_GETSTBYKEY5:
+			data->data.stbyKey.key = ((I2CData->readBuff[2] << 24) & 0xff000000)
+						 | ((I2CData->readBuff[3] << 16) & 0xff0000)
+						 | ((I2CData->readBuff[4] << 8) & 0xff00)
+						 | ((I2CData->readBuff[5]) & 0xff);
 			data->ack = true;
-		}
-		break;
-		case YWPANEL_INIT_INSTR_GETBLUEKEY1: /*get blue key*/
-		case YWPANEL_INIT_INSTR_GETBLUEKEY2: /*get blue key*/
-		case YWPANEL_INIT_INSTR_GETBLUEKEY3: /*get blue key*/
-		case YWPANEL_INIT_INSTR_GETBLUEKEY4: /*get blue key*/
-		case YWPANEL_INIT_INSTR_GETBLUEKEY5: /*get blue key*/
-		{
-			data->data.stbyKey.key = ((I2CData->readBuff[2]<<24)&0xff000000)
-												|((I2CData->readBuff[3]<<16)&0xff0000)
-												|((I2CData->readBuff[4]<<8)&0xff00)
-												|((I2CData->readBuff[5])&0xff);
+			break;
+		case YWPANEL_INIT_INSTR_GETSTARTUPSTATE: /*get vfd state*/
+			data->data.StartUpState.State = I2CData->readBuff[2];
 			data->ack = true;
-		}
-		break;
-		case YWPANEL_INIT_INSTR_GETIRCODE: /*get ir protocoll*/
-		{
-			data->data.irCode.code = I2CData->readBuff[2];
-		}
-		break;
-
-		case YWPANEL_INIT_INSTR_GETENCRYPTMODE: /*get encrypt mode */
-		{
-			data->data.EncryptMode.mode = I2CData->readBuff[2];
-		}
-		break;
-
-		case YWPANEL_INIT_INSTR_GETENCRYPTKEY: /*get encrypt key */
-		{
-			data->data.EncryptKey.key = (u32)I2CData->readBuff[2] |(u32) I2CData->readBuff[3]<<8
-												 |(u32)I2CData->readBuff[4]<<16 |(u32)I2CData->readBuff[5]<<24;
-		}
-		break;
-
+			break;
+		case YWPANEL_INIT_INSTR_GETLOOPSTATE: /*get vfd state*/
+			data->data.LoopState.state = I2CData->readBuff[2];
+			data->ack = true;
+			break;
 		case YWPANEL_INIT_INSTR_GETVERIFYSTATE: /*get verify state */
-		{
 			data->data.verifyState.state = I2CData->readBuff[2];
-		}
-		break;
+			break;
 		case YWPANEL_INIT_INSTR_GETPOWERONTIME:
 		case YWPANEL_INIT_INSTR_GETTIME:
-		{
-			data->data.time.second = ((I2CData->readBuff[2]<<24)&0xff000000)
-									|((I2CData->readBuff[3]<<16)&0xff0000)
-									|((I2CData->readBuff[4]<<8)&0xff00)
-									|((I2CData->readBuff[5])&0xff);
+			data->data.time.second = ((I2CData->readBuff[2] << 24) & 0xff000000)
+						 | ((I2CData->readBuff[3] << 16) & 0xff0000)
+						 | ((I2CData->readBuff[4] << 8) & 0xff00)
+						 | ((I2CData->readBuff[5]) & 0xff);
 			data->ack = true;
-		}
-		break;
-
+			break;
 		default:
 		{
-			ywtrace_print(TRACE_ERROR,"%s::error @%d\n",__FUNCTION__,__LINE__);
+			ywtrace_print(TRACE_ERROR, "%s::error @%d\n", __FUNCTION__, __LINE__);
 			return false;
 		}
 	}
-
 	return true;
 }
 
 #ifdef CONFIG_CPU_SUBTYPE_STX7105
-static bool YWPANEL_FPWriteDataToI2c(	struct i2c_adapter* I2CHandle,
-										u8 * writeBufer,
-										u32 writeBufLen,
-										u8 *readBuffer,
-										u32 readBufLen)
+static int YWPANEL_FPWriteDataToI2c(struct i2c_adapter *I2CHandle,
+				    u8 *writeBuffer,
+				    u32 writeBufLen,
+				    u8 *readBuffer,
+				    u32 readBufLen)
 {
-
-	if (!isofti2c_write(writeBufer, writeBufLen))
-	{
+	if (!isofti2c_write(writeBuffer, writeBufLen))
 		return false;
-	}
 	msleep(1);
 	if (!isofti2c_read(readBuffer, readBufLen))
-	{
 		return false;
-	}
 	return true;
 }
 #else
-static bool YWPANEL_FPWriteDataToI2c(	struct i2c_adapter* I2CHandle,
-										u8 * writeBufer,
-										u32 writeBufLen,
-										u8 *readBuffer,
-										u32 readBufLen)
-{
-	int		ret	 = 0;
-	struct i2c_msg i2c_msg[] = {{ .addr = I2C_BUS_ADD, .flags = 0, .buf = writeBufer, .len = writeBufLen},
-								{ .addr = I2C_BUS_ADD, .flags = I2C_M_RD, .buf = readBuffer, .len = readBufLen}};
-
-	if(NULL == panel_i2c_adapter)
+static int YWPANEL_FPWriteDataToI2c(struct i2c_adapter *I2CHandle,
+				    u8 *writeBuffer,
+				    u32 writeBufLen,
+				    u8 *readBuffer,
+				    u32 readBufLen)
+{
+	int ret = 0;
+	struct i2c_msg i2c_msg[] = {{ .addr = I2C_BUS_ADD, .flags = 0, .buf = writeBuffer, .len = writeBufLen},
+		{ .addr = I2C_BUS_ADD, .flags = I2C_M_RD, .buf = readBuffer, .len = readBufLen}
+	};
+	if (NULL == panel_i2c_adapter)
 	{
 		PANEL_DEBUG("panel i2c failed\n");
 		return -ENODEV;
 	}
 	//printk("%s:%d\n", __FUNCTION__, __LINE__);
 	ret = i2c_transfer(panel_i2c_adapter, &i2c_msg[0], 1);
-
 	if (ret != 1)
 	{
-		ywtrace_print(TRACE_ERROR,"I2C read error for at %d\n", __LINE__);
+		ywtrace_print(TRACE_ERROR, "I2C read error for at %d\n", __LINE__);
 		return false;
 	}
-
 	msleep(1);
 	//printk("%s:%d\n", __FUNCTION__, __LINE__);
-    ret = i2c_transfer(panel_i2c_adapter, &i2c_msg[1], 1);
-
-    if (ret != 1)
-    {
-            ywtrace_print(TRACE_ERROR,"I2C read error for at %d\n", __LINE__);
-            return false;
-    }
-
+	ret = i2c_transfer(panel_i2c_adapter, &i2c_msg[1], 1);
+	if (ret != 1)
+	{
+		ywtrace_print(TRACE_ERROR, "I2C read error for at %d\n", __LINE__);
+		return false;
+	}
 	return true;
 }
 #endif  /* 0 */
 
-bool YWPANEL_FP_SendData(YWPANEL_FPData_t  *data)
+int YWPANEL_FP_SendData(YWPANEL_FPData_t  *data)
 {
-	bool				ret = false;
-	YWPANEL_I2CData_t	I2CData;
+	int ret = false;
+	YWPANEL_I2CData_t   I2CData;
 	if (down_interruptible(&vfd_sem_rw))
 	{
-	   ywtrace_print(TRACE_ERROR,"SendData is busy U will be next!!\n");
-	   return false;
+		ywtrace_print(TRACE_ERROR, "SendData is busy U will be next!!\n");
+		return false;
 	}
-	if(data == NULL)
+	if (data == NULL)
 	{
-		ywtrace_print(TRACE_ERROR,"bad parameter @ %d\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "bad parameter @ %d\n", __LINE__);
 		up(&vfd_sem_rw);
 		return false;
 	}
-
 	memset(&I2CData, 0, sizeof(I2CData));
-	if(YWPANEL_FP_SetI2cData(data,&I2CData) != true)
+	if (YWPANEL_FP_SetI2cData(data, &I2CData) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"SetI2cData @ %d\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "SetI2cData @ %d\n", __LINE__);
 		up(&vfd_sem_rw);
 		return false;
 	}
 	//printk("%s:%d\n", __FUNCTION__, __LINE__);
 	ret = YWPANEL_FPWriteDataToI2c(panel_i2c_adapter,
-					I2CData.writeBuff,
-					I2CData.writeBuffLen,
-					I2CData.readBuff,
-					YWPANEL_FP_INFO_MAX_LENGTH);
-	if(ret != true)
+				       I2CData.writeBuff,
+				       I2CData.writeBuffLen,
+				       I2CData.readBuff,
+				       YWPANEL_FP_INFO_MAX_LENGTH);
+	if (ret != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FPWriteDataToI2c @ %d\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FPWriteDataToI2c @ %d\n", __LINE__);
 		up(&vfd_sem_rw);
 		return false;
 	}
-
 	ret = YWPANEL_FP_ParseI2cData(data, &I2CData);
-	if(ret != true)
+	if (ret != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_ParseI2cData @ %d\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_ParseI2cData @ %d\n", __LINE__);
 		up(&vfd_sem_rw);
 		return false;
 	}
-
 	up(&vfd_sem_rw);
 	return ret;
 }
 
-//YWPANEL_VFDSTATE_t YWPANEL_FP_GetVFDStatus(void)
-//{
-//	YWPANEL_FPData_t   data;
-//
-//	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-//	data.dataType = YWPANEL_DATATYPE_GETVFDSTATE;
-//
-//	if(YWPANEL_FP_SendData(&data) != true)
-//	{
-//		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d] \n",__LINE__);
-//		return false;
-//	}
-//	if((data.data.CpuState.state < YWPANEL_VFDSTATE_STANDBYOFF) ||(data.data.CpuState.state > YWPANEL_VFDSTATE_STANDBYON) )
-//	{
-//		return YWPANEL_VFDSTATE_UNKNOW;
-//	}
-//
-//	return data.data.CpuState.state;
-//}
+YWPANEL_VFDSTATE_t YWPANEL_FP_GetVFDStatus(void)
+{
+	YWPANEL_FPData_t   data;
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_GETVFDSTATE;
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d] \n", __LINE__);
+		return false;
+	}
+	if ((data.data.VfdStandbyState.On < YWPANEL_VFDSTATE_STANDBYOFF) || (data.data.VfdStandbyState.On > YWPANEL_VFDSTATE_STANDBYON))
+	{
+		return YWPANEL_VFDSTATE_UNKNOWN;
+	}
+	return data.data.VfdStandbyState.On;
+}
 
-//bool  YWPANEL_FP_SetVFDStatus(YWPANEL_VFDSTATE_t state)
-//{
-//	YWPANEL_FPData_t   data;
-//
-//
-//	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-//	data.dataType = YWPANEL_DATATYPE_SETVFDSTATE;
-//	data.data.CpuState.state = state;
-//
-//	if(YWPANEL_FP_SendData(&data) != true)
-//	{
-//		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-//		return false;
-//	}
-//	return true;
-//}
+int  YWPANEL_FP_SetVFDStatus(YWPANEL_VFDSTATE_t On)
+{
+	YWPANEL_FPData_t   data;
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_SETVFDSTATE;
+	data.data.VfdStandbyState.On = On;
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		return false;
+	}
+	return true;
+}
 
 YWPANEL_POWERONSTATE_t YWPANEL_FP_GetPowerOnStatus(void)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_GETPOWERONSTATE;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return false;
 	}
-	if((data.data.CpuState.state < YWPANEL_POWERONSTATE_RUNNING) || (data.data.CpuState.state > YWPANEL_POWERONSTATE_CHECKPOWERBIT))
+	if ((data.data.PowerOnState.state < YWPANEL_POWERONSTATE_RUNNING) || (data.data.PowerOnState.state > YWPANEL_POWERONSTATE_CHECKPOWERBIT))
 	{
-		return YWPANEL_POWERONSTATE_UNKNOW;
+		return YWPANEL_POWERONSTATE_UNKNOWN;
 	}
-
-	return data.data.CpuState.state;
+	return data.data.PowerOnState.state;
 }
 
-bool  YWPANEL_FP_SetPowerOnStatus(YWPANEL_POWERONSTATE_t state)
+int YWPANEL_FP_SetLoopState(YWPANEL_LOOPSTATE_t state)
 {
 	YWPANEL_FPData_t   data;
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_SETLOOPSTATE;
+	data.data.LoopState.state = state;
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		return false;
+	}
+	return true;
+}
 
+int YWPANEL_FP_GetLoopState(YWPANEL_LOOPSTATE_t *state)
+{
+	YWPANEL_FPData_t   data;
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_GETLOOPSTATE;
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		return false;
+	}
+	if ((data.data.LoopState.state < YWPANEL_LOOPSTATE_UNKNOWN) || (data.data.LoopState.state > YWPANEL_LOOPSTATE_LOOPON))
+	{
+		return false;
+	}
+	*state = data.data.LoopState.state;
+	return true;
+}
 
+int  YWPANEL_FP_SetPowerOnStatus(YWPANEL_POWERONSTATE_t state)
+{
+	YWPANEL_FPData_t   data;
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_SETPOWERONSTATE;
-	data.data.CpuState.state = state;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	data.data.PowerOnState.state = state;
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return false;
 	}
 	return true;
 }
 
-bool YWPANEL_FP_GetStartUpState(YWPANEL_STARTUPSTATE_t *State)
+int YWPANEL_FP_GetStartUpState(YWPANEL_STARTUPSTATE_t *State)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_GETSTARTUPSTATE;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-	  ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-	  return false;
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		return false;
 	}
-
-	*State = data.data.CpuState.state;
+	*State = data.data.StartUpState.State;
 	return true;
 }
 
 YWPANEL_CPUSTATE_t YWPANEL_FP_GetCpuStatus(void)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_GETCPUSTATE;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return false;
 	}
-	if((data.data.CpuState.state <YWPANEL_CPUSTATE_RUNNING) ||(data.data.CpuState.state> YWPANEL_CPUSTATE_STANDBY) )
+	if ((data.data.CpuState.state < YWPANEL_CPUSTATE_RUNNING) || (data.data.CpuState.state > YWPANEL_CPUSTATE_STANDBY))
 	{
-		return YWPANEL_CPUSTATE_UNKNOW;
+		return YWPANEL_CPUSTATE_UNKNOWN;
 	}
-
 	return data.data.CpuState.state;
 }
 
-bool  YWPANEL_FP_SetCpuStatus(YWPANEL_CPUSTATE_t state)
+int YWPANEL_FP_SetCpuStatus(YWPANEL_CPUSTATE_t state)
 {
 	YWPANEL_FPData_t   data;
-
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_SETCPUSTATE;
 	data.data.CpuState.state = state;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return false;
 	}
 	return true;
 }
 
-bool  YWPANEL_FP_GetVersion(YWPANEL_Version_t *version)
+int YWPANEL_FP_GetVersion(YWPANEL_Version_t *version)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_GETVERSION;
-
 	//printk("%s:%d\n", __FUNCTION__, __LINE__);
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return false;
 	}
 	//printk("%s:%d\n", __FUNCTION__, __LINE__);
 	memcpy(version, &(data.data.version), sizeof(YWPANEL_Version_t));
-
 	return true;
 }
 
-#if 0
-u32  YWPANEL_FP_GetIRKey(void)
-{
-	YWPANEL_FPData_t   data;
-
-	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-	data.dataType = YWPANEL_DATATYPE_IRKEY;
-	if(YWPANEL_FP_SendData(&data) != true)
-	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-		return false;
-	}
-	return (data.data.IrkeyData.dataCode|data.data.IrkeyData.customCode);
-}
-#endif
-
-//u32  YWPANEL_FP_GetStandByKey(u8 index)
-//{
-//	YWPANEL_FPData_t   data;
-//	u8 key;
-//
-//	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-//	data.dataType = YWPANEL_DATATYPE_GETSTBYKEY1+index;
-//
-//	if(YWPANEL_FP_SendData(&data) != true)
-//	{
-//		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-//		return false;
-//	}
-//	key = (u8)(data.data.stbyKey.key>>8);
-//
-//	return YWPANEL_TranslateKeyCode(key);
-//}
-
-//bool  YWPANEL_FP_SetStandByKey(u8 index,u8 key)
-//{
-//	YWPANEL_FPData_t   data;
-//	u32 value;
-//
-//	if(!to_primitive_key(key, &value))
-//	{
-//		ywtrace_print(TRACE_INFO,"to_primitive_key is failed!![%d]\n",__LINE__);
-//		return false;
-//	}
-//
-//	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-//
-//	data.dataType = YWPANEL_DATATYPE_SETSTBYKEY1+index;
-//	data.data.stbyKey.key = value;
-//
-//	if(YWPANEL_FP_SendData(&data) != true)
-//	{
-//		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-//		return false;
-//	}
-//	return true;
-//}
-
-//u32  YWPANEL_FP_GetBlueKey(u8 index)
-//{
-//	YWPANEL_FPData_t   data;
-//	u8 key;
-//
-//	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-//	data.dataType = YWPANEL_DATATYPE_GETBLUEKEY1+index;
-//
-//	if(YWPANEL_FP_SendData(&data) != true)
-//	{
-//		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-//		return false;
-//	}
-//	key = (u8)(data.data.stbyKey.key>>8);
-//	return YWPANEL_TranslateKeyCode(key);
-//}
-
-//bool  YWPANEL_FP_SetBlueKey(u8 index,u8 key)
-//{
-//	YWPANEL_FPData_t   data;
-//	u32 value;
-//
-//	if(!to_primitive_key(key, &value))
-//	{
-//		ywtrace_print(TRACE_INFO,"to_primitive_key is failed!![%d]\n",__LINE__);
-//		return false;
-//	}
-//
-//	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-//
-//	data.dataType = YWPANEL_DATATYPE_SETBLUEKEY1+index;
-//	data.data.stbyKey.key = value;
-//
-//	if(YWPANEL_FP_SendData(&data) != true)
-//	{
-//		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-//		return false;
-//	}
-//	return true;
-//}
-
-u32  YWPANEL_FP_GetTime(void)
+u32 YWPANEL_FP_GetTime(void)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_GETTIME;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return false;
 	}
 	return data.data.time.second;
 }
 
-bool  YWPANEL_FP_SetTime(u32 value)
+int  YWPANEL_FP_SetTime(u32 value)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_SETTIME;
 	data.data.time.second = value;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return false;
 	}
 	return true;
 }
 
-bool  YWPANEL_FP_SetPowerOnTime(u32 Value)
+int YWPANEL_FP_SetPowerOnTime(u32 Value)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_SETPOWERONTIME;
 	data.data.time.second = Value;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 	}
 	return true;
 }
 
-u32  YWPANEL_FP_GetPowerOnTime(void)
+u32 YWPANEL_FP_GetPowerOnTime(void)
 {
 	YWPANEL_FPData_t   data;
-
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_GETPOWERONTIME;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		return 0;
 	}
 	return data.data.time.second;
 }
 
-bool  YWPANEL_FP_ControlTimer(bool on)
+int YWPANEL_FP_GetKey(int blue, int key_nr, u32 *k)
 {
-	YWPANEL_FPData_t   data;
+	if (key_nr > -1 && key_nr < 5)
+	{
+		YWPANEL_FPData_t    data;
+		memset(&data, 0, sizeof(YWPANEL_FPData_t));
+		data.dataType = (blue ? YWPANEL_DATATYPE_GETBLUEKEY1 : YWPANEL_DATATYPE_GETSTBYKEY1) + key_nr;
+		if (YWPANEL_FP_SendData(&data))
+		{
+			*k = data.data.stbyKey.key;
+			return true;
+		}
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]", __LINE__);
+	}
+	return false;
+}
+
+int YWPANEL_FP_SetKey(int blue, int key_nr, u32 k)
+{
+	if (key_nr > -1 && key_nr < 5)
+	{
+		YWPANEL_FPData_t    data;
+		memset(&data, 0, sizeof(YWPANEL_FPData_t));
+		data.dataType = (blue ? YWPANEL_DATATYPE_SETBLUEKEY1 : YWPANEL_DATATYPE_SETSTBYKEY1) + key_nr;
+		data.data.stbyKey.key = k;
+		if (YWPANEL_FP_SendData(&data))
+			return true;
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]", __LINE__);
+	}
+	msleep(100); // Looks like the controller is returning junk data. Wait a couple of milliseconds, or the next i2c response will be messed up --martii
+	return false;
+}
 
+int YWPANEL_FP_ControlTimer(int on)
+{
+	YWPANEL_FPData_t   data;
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
 	data.dataType = YWPANEL_DATATYPE_CONTROLTIMER;
 	data.data.TimeState.startFlag = on;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]", __LINE__);
 		return false;
 	}
 	return true;
 }
 
-//int YWPANEL_LBD_SetStatus(YWPANEL_LBDStatus_T  LBDStatus )
-//{
-//	YWPANEL_FPData_t	data;
-//	int 		ErrorCode = 0;
-//
-//	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-//	data.dataType = YWPANEL_DATATYPE_LBD;
-//	if(LBDStatus == YWPANEL_LBD_STATUS_ON)
-//	{
-//		lbdValue |= YWPANEL_LBD_TYPE_POWER;
-//	}
-//	else
-//	{
-//		lbdValue &= ~(YWPANEL_LBD_TYPE_POWER);
-//	}
-//
-//	data.data.lbdData.value = lbdValue;
-//
-//	if(YWPANEL_FP_SendData(&data) != true)
-//	{
-//		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-//		ErrorCode = -ETIME;
-//	}
-//	return ErrorCode;
-//}
+#if 0
+int YWPANEL_LBD_SetStatus(YWPANEL_LBDStatus_T  LBDStatus)
+{
+	YWPANEL_FPData_t data;
+	int ErrorCode = 0;
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_LBD;
+	if (LBDStatus == YWPANEL_LBD_STATUS_ON)
+	{
+		lbdValue |= YWPANEL_LBD_TYPE_POWER;
+	}
+	else
+	{
+		lbdValue &= ~(YWPANEL_LBD_TYPE_POWER);
+	}
+	data.data.lbdData.value = lbdValue;
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		ErrorCode = -ETIME;
+	}
+	return ErrorCode;
+}
+#endif
 
 int YWPANEL_VFD_SetLed(int which, int on)
 {
-	int 				ErrorCode = 0;
-	YWPANEL_FPData_t	data;
-
+	int ErrorCode = 0;
+	YWPANEL_FPData_t data;
 	memset(&data, 0, sizeof(YWPANEL_FPData_t));
-
 	data.dataType = YWPANEL_DATATYPE_LBD;
 	switch (which)
 	{
 		case 0:
 		{
-			if(on == YWPANEL_LBD_STATUS_ON)
-			{
+			if (on)
 				lbdValue |= YWPANEL_LBD_TYPE_POWER;
-			}
 			else
-			{
 				lbdValue &= ~(YWPANEL_LBD_TYPE_POWER);
-			}
 			break;
 		}
 		case 1:
 		{
-			if(on == YWPANEL_LBD_STATUS_ON)
-			{
+			if (panel_disp_type == YWPANEL_FP_DISPTYPE_VFD)
+				return YWPANEL_VFD_ShowIcon(AOTOM_DOT2, on); // green LED not available
+			if (on)
 				lbdValue |= YWPANEL_LBD_TYPE_SIGNAL;
-			}
 			else
-			{
 				lbdValue &= ~(YWPANEL_LBD_TYPE_SIGNAL);
-			}
 			break;
 		}
-
 	}
-
 	data.data.lbdData.value = lbdValue;
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
 		ErrorCode = -ETIME;
 	}
 	return ErrorCode;
 }
 
-int YWPANEL_VFD_SetPIOMode(PIO_Mode_T Mode_PIO)
+static int YWPANEL_VFD_SetPIOMode(PIO_Mode_T Mode_PIO)
 {
-   int ST_ErrCode = 0 ;
-
-   if(Mode_PIO == PIO_Out)
-   {
-	   stpio_configure_pin(pio_sda, STPIO_OUT);
-   }
-   else if(Mode_PIO == PIO_In)
-   {
-	   stpio_configure_pin(pio_sda, STPIO_IN);
-   }
-   stpio_configure_pin(pio_scl, STPIO_OUT);
-   stpio_configure_pin(pio_cs,  STPIO_OUT);
-
-   return ST_ErrCode;
+	int ST_ErrCode = 0 ;
+	if (Mode_PIO == PIO_Out)
+	{
+		stpio_configure_pin(pio_sda, STPIO_OUT);
+	}
+	else if (Mode_PIO == PIO_In)
+	{
+		stpio_configure_pin(pio_sda, STPIO_IN);
+	}
+	stpio_configure_pin(pio_scl, STPIO_OUT);
+	stpio_configure_pin(pio_cs,  STPIO_OUT);
+	return ST_ErrCode;
 }
 
-int YWPANEL_VFD_WR(u8 data)
+static int YWPANEL_VFD_WR(u8 data)
 {
 	int  ErrorCode = 0;
 	int i;
 	down_write(&vfd_rws);
-	for(i = 0; i < 8; i++)
+	for (i = 0; i < 8; i++)
 	{
 		stpio_set_pin(pio_scl, 0);
 		udelay(1);
-		if(data & 0x01)
-		{
-			stpio_set_pin(pio_sda, 1);
-		}
-		else
-		{
-			stpio_set_pin(pio_sda, 0);
-		}
+		stpio_set_pin(pio_sda, data & 0x01);
 		stpio_set_pin(pio_scl, 1);
 		udelay(1);
 		data >>= 1;
 	}
-
 	up_write(&vfd_rws);
 	return ErrorCode;
 }
 
-u8	YWPANEL_VFD_RD(void)
+static u8 YWPANEL_VFD_RD(void)
 {
 	int ret = 0 ;
 	int i;
 	u8  val = 0;
-
 	down_read(&vfd_rws);
-
 	YWPANEL_VFD_SetPIOMode(PIO_In);
 	for (i = 0; i < 8; i++)
 	{
 		val >>= 1;
 		stpio_set_pin(pio_scl, 0);
 		udelay(1);
-
 		ret = stpio_get_pin(pio_sda);
-		if(ret)
+		if (ret)
 		{
 			val |= 0x80;
 		}
@@ -1880,20 +1433,19 @@
 	return val;
 }
 
-int YWPANEL_VFD_SegDigSeg(u8 dignum, SegNum_T segnum, u8 val)
+static int YWPANEL_VFD_SegDigSeg(u8 dignum, SegNum_T segnum, u8 val)
 {
-	int  ST_ErrCode = 0;
-	u8	 addr=0;
-	if(segnum < 0 || segnum > 1)
+	int ST_ErrCode = 0;
+	u8  addr = 0;
+	if (segnum < 0 && segnum > 1)
 		ST_ErrCode = -EINVAL;
-
 	VFD_CS_CLR();
-	if(segnum == SEGNUM1)
+	if (segnum == SEGNUM1)
 	{
 		addr = VfdSegAddr[dignum].Segaddr1;
 		VfdSegAddr[dignum].CurrValue1 = val ;
 	}
-	else if(segnum == SEGNUM2)
+	else if (segnum == SEGNUM2)
 	{
 		addr = VfdSegAddr[dignum].Segaddr2;
 		VfdSegAddr[dignum].CurrValue2 = val ;
@@ -1902,23 +1454,21 @@
 	udelay(10);
 	ST_ErrCode = YWPANEL_VFD_WR(val);
 	VFD_CS_SET();
-	return	ST_ErrCode;
+	return  ST_ErrCode;
 }
 
-int YWPANEL_VFD_SetMode(VFDMode_T mode)
+static int YWPANEL_VFD_SetMode(VFDMode_T mode)
 {
-
-	int 	ST_ErrCode = 0;
-	u8		data = 0;
-
-	if(mode == VFDWRITEMODE)
+	int ST_ErrCode = 0;
+	u8  data = 0;
+	if (mode == VFDWRITEMODE)
 	{
 		data = 0x44;
 		VFD_CS_CLR();
 		ST_ErrCode = YWPANEL_VFD_WR(data);
 		VFD_CS_SET();
 	}
-	else if(mode == VFDREADMODE)
+	else if (mode == VFDREADMODE)
 	{
 		data = 0x46;
 		ST_ErrCode = YWPANEL_VFD_WR(data);
@@ -1927,167 +1477,92 @@
 	return ST_ErrCode;
 }
 
-int YWPANEL_VFD_ShowContent(void)
+#if 0 // unused
+static int YWPANEL_VFD_ShowContent(void)
 {
-	int 	 ST_ErrCode = 0;
+	int ST_ErrCode = 0;
 	VFD_CS_CLR();
 	ST_ErrCode = YWPANEL_VFD_WR(0x8F);
 	VFD_CS_SET();
 	return ST_ErrCode;
 }
 
-int YWPANEL_VFD_ShowContentOff(void)
+static int YWPANEL_VFD_ShowContentOff(void)
 {
-	int 	 ST_ErrCode = 0;
+	int ST_ErrCode = 0;
 	ST_ErrCode = YWPANEL_VFD_WR(0x87);
-
 	return ST_ErrCode;
 }
+#endif
 
-
-void YWPANEL_VFD_ClearAll(void)
+static void YWPANEL_VFD_ClearAll(void)
 {
 	int i;
-	for(i = 0; i < 13; i++)
+	for (i = 0; i < 13; i++)
 	{
-		YWPANEL_VFD_SegDigSeg(i + 1,SEGNUM1,0x00);
+		YWPANEL_VFD_SegDigSeg(i + 1, SEGNUM1, 0x00);
 		VfdSegAddr[i + 1].CurrValue1 = 0x00;
-		YWPANEL_VFD_SegDigSeg(i + 1,SEGNUM2,0x00);
+		YWPANEL_VFD_SegDigSeg(i + 1, SEGNUM2, 0x00);
 		VfdSegAddr[i + 1].CurrValue2 = 0;
 	}
 }
 
-void utf8_symbol(u8 *c1, u8 *c2, u8 *v1, u8 *v2)
-{
-	switch(*c1)
-	{
-		case 0xc2:
-			*v1 = UTF_C2[*c2 & 0x3f][0];
-			*v2 = UTF_C2[*c2 & 0x3f][1];
-		break;
-		case 0xc3:
-			*v1 = UTF_C3[*c2 & 0x3f][0];
-			*v2 = UTF_C3[*c2 & 0x3f][1];
-		break;
-		case 0xc4:
-			*v1 = UTF_C4[*c2 & 0x3f][0];
-			*v2 = UTF_C4[*c2 & 0x3f][1];
-		break;
-		case 0xc5:
-			*v1 = UTF_C5[*c2 & 0x3f][0];
-			*v2 = UTF_C5[*c2 & 0x3f][1];
-		break;
-		case 0xd0:
-			*v1 = UTF_D0[*c2 & 0x3f][0];
-			*v2 = UTF_D0[*c2 & 0x3f][1];
-		break;
-		case 0xd1:
-			*v1 = UTF_D1[*c2 & 0x3f][0];
-			*v2 = UTF_D1[*c2 & 0x3f][1];
-	}
-}
-
-
-//count of bytes in utf8 substring with specified length
-int utf8_count(unsigned char *utfstr, int strlength, int length)
-{
-	int len = 0, i = 0;
-	for(i = 0; i < strlength && len < length; i++)
-	{
-		if(utfstr[i] >= 128)
-		{
-			i++;
-		}
-		len++;
-	}
-	ywtrace_print(TRACE_INFO, "%s %d\n", __func__, i);
-	return i;
-}
-
-//utf8 string length
-int utf8_len(unsigned char *utfstr, int strlength)
-{
-	int len = 0, i = 0;
-	for(i = 0; i < strlength; i++)
-	{
-		if(utfstr[i] >= 128)
-		{
-			i++;
-			if (i == strlength)
-				break;
-		}
-		len++;
-	}
-	ywtrace_print(TRACE_INFO, "%s %d\n", __func__, len);
-	return len;
-}
-
-void YWPANEL_VFD_DrawChar(char c, u8 position)
+static u8 ywpanel_vfd_map[0x80] =
 {
-	if(position < 1 || position > 8)
-	{
-		PANEL_PRINT((TRACE_ERROR, "char position error! %d\n", position));
-		return;
-	}
-	if(c >= 65 && c <= 95)
-		c = c - 65;
-	else if(c >= 97 && c <= 122)
-		c = c - 97;
-	else if(c >= 42 && c <= 57)
-		c = c - 11;
-	else if(c == 32)
-		c = 47;
-	else
-	{
-		PANEL_PRINT((TRACE_ERROR, "unknown char! make it as space!!\n"));
-		c = 47;
-	}
-	YWPANEL_VFD_SegDigSeg(position, SEGNUM1, CharLib[(u8)c][0]);
-	YWPANEL_VFD_SegDigSeg(position, SEGNUM2, CharLib[(u8)c][1]);
-
-}
+	0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+	0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+	//     !     "      #     $     %     &     '     (     )     *     +     ,     -     .     /
+	0x2f, 0x2f, 0x36, 0x2f, 0x2f, 0x2f, 0x2f, 0x35, 0x1a, 0x1c, 0x1f, 0x20, 0x33, 0x22, 0x33, 0x24,
+	// 0    1     2     3     4     5     6     7     8     9     :     ;     <     =     >     ?
+	0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x34, 0x2f, 0x31, 0x2f, 0x32, 0x2f,
+	// @    A     B     C     D     E     F     G     H     I     J     K     L     M     N     O
+	0x2f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
+	// P    Q     R     S     T     U     V     W     X     Y     Z     [     \     ]     ^     _
+	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
+	// `    a     b     c
+	0x2f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
+	// p                                                          z     {     |     }     ~
+	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x31, 0x30, 0x32, 0x2f, 0x2f
+};
 
-void YWPANEL_VFD_DrawNum(u8 c, u8 position)
+static void YWPANEL_VFD_DrawNum(u8 c, u8 position)
 {
 	int dignum;
-
-	if(position < 1 || position > 4)
+	if (position < 1 || position > 4)
 	{
 		PANEL_PRINT((TRACE_ERROR, "num position error! %d\n", position));
 		return;
 	}
-	if(c >	9)
+	if (c > 9)
 	{
 		PANEL_PRINT((TRACE_ERROR, "unknown num!\n"));
 		return;
 	}
-	dignum =10 - position / 3;
-	if(position % 2 == 1)
+	dignum = 10 - position / 3;
+	if (position % 2 == 1)
 	{
-		if(NumLib[c][1] & 0x01)
+		if (NumLib[c][1] & 0x01)
 			YWPANEL_VFD_SegDigSeg(dignum, SEGNUM1, VfdSegAddr[dignum].CurrValue1 | 0x80);
 		else
 			YWPANEL_VFD_SegDigSeg(dignum, SEGNUM1, VfdSegAddr[dignum].CurrValue1 & 0x7F);
-			VfdSegAddr[dignum].CurrValue2 = VfdSegAddr[dignum].CurrValue2 & 0x40;
-			YWPANEL_VFD_SegDigSeg(dignum, SEGNUM2, (NumLib[c][1] >> 1) | VfdSegAddr[dignum].CurrValue2);
+		VfdSegAddr[dignum].CurrValue2 = VfdSegAddr[dignum].CurrValue2 & 0x40;
+		YWPANEL_VFD_SegDigSeg(dignum, SEGNUM2, (NumLib[c][1] >> 1) | VfdSegAddr[dignum].CurrValue2);
 	}
-	else if(position % 2 == 0)
+	else if (position % 2 == 0)
 	{
-	   if((NumLib[c][0] & 0x01))
-		{
+		if ((NumLib[c][0] & 0x01))
 			YWPANEL_VFD_SegDigSeg(dignum, SEGNUM2, VfdSegAddr[dignum].CurrValue2 | 0x40);
-		}
-	   else
+		else
 			YWPANEL_VFD_SegDigSeg(dignum, SEGNUM2, VfdSegAddr[dignum].CurrValue2 & 0x3F);
-			VfdSegAddr[dignum].CurrValue1 = VfdSegAddr[dignum].CurrValue1 & 0x80;
-			YWPANEL_VFD_SegDigSeg(dignum, SEGNUM1, (NumLib[c][0] >>1 ) | VfdSegAddr[dignum].CurrValue1 );
+		VfdSegAddr[dignum].CurrValue1 = VfdSegAddr[dignum].CurrValue1 & 0x80;
+		YWPANEL_VFD_SegDigSeg(dignum, SEGNUM1, (NumLib[c][0] >> 1) | VfdSegAddr[dignum].CurrValue1);
 	}
 }
 
 void YWPANEL_Seg_Addr_Init(void)
 {
 	u8 i, addr = 0xC0;//adress flag
-	for(i = 0; i < 13; i++)
+	for (i = 0; i < 13; i++)
 	{
 		VfdSegAddr[i + 1].CurrValue1 = 0;
 		VfdSegAddr[i + 1].CurrValue2 = 0;
@@ -2097,143 +1572,104 @@
 	}
 }
 
-int YWPANEL_VFD_ShowTime_StandBy(u8 hh,u8 mm)
+static int YWPANEL_VFD_ShowTime_StandBy(u8 hh, u8 mm)
 {
-	int 				ErrorCode = 0;
-	YWPANEL_FPData_t	data;
-	u8					digitNum1,digitNum2,temp;
+	int ErrorCode = 0;
+	YWPANEL_FPData_t data;
+	u8 digitNum1, digitNum2, temp;
 	if (down_interruptible(&vfd_sem))
+		return -EBUSY;
+//show hour
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_VFD;
+	digitNum2 = YWPANEL_CharArray[hh / 10 ];
+	digitNum1 = YWPANEL_CharArray[hh % 10];
+	temp = digitNum2;
+	digitNum2 = (digitNum2 & 0xbf) | (digitNum1 & 0x40);
+	digitNum1 = (digitNum1 & 0x3c) | ((temp & 0x40) << 1) | ((digitNum1 & 0x01) << 1) | ((digitNum1 & 0x02) >> 1);
+	data.data.vfdData.type = YWPANEL_VFD_DISPLAY;
+	data.data.vfdData.address[0] = VfdSegAddr[10].Segaddr2;
+	data.data.vfdData.DisplayValue[0] = digitNum2;
+	VfdSegAddr[10].CurrValue2 = data.data.vfdData.DisplayValue[0];
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-	   return -EBUSY;
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		ErrorCode = -ETIME;
 	}
-//show hour
+	data.data.vfdData.address[0] = VfdSegAddr[10].Segaddr1;
+	data.data.vfdData.DisplayValue[0] = digitNum1;
+	VfdSegAddr[10].CurrValue1 = data.data.vfdData.DisplayValue[0];
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		memset(&data, 0, sizeof(YWPANEL_FPData_t));
-
-		data.dataType = YWPANEL_DATATYPE_VFD;
-
-		digitNum2 = YWPANEL_CharArray[hh/10 ];
-		digitNum1 = YWPANEL_CharArray[hh%10];
-
-		temp = digitNum2;
-		digitNum2 = (digitNum2&0xbf)|(digitNum1&0x40);
-		digitNum1 = (digitNum1&0x3c)|((temp&0x40)<<1)|((digitNum1&0x01)<<1)|((digitNum1&0x02)>>1);
-
-
-		data.data.vfdData.type = YWPANEL_VFD_DISPLAY;
-		data.data.vfdData.address[0] = VfdSegAddr[10].Segaddr2;
-
-		data.data.vfdData.DisplayValue[0] = digitNum2;
-		VfdSegAddr[10].CurrValue2 = data.data.vfdData.DisplayValue[0];
-
-		if(YWPANEL_FP_SendData(&data) != true)
-		{
-			ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-			ErrorCode = -ETIME;
-		}
-
-		data.data.vfdData.address[0] = VfdSegAddr[10].Segaddr1;
-
-		data.data.vfdData.DisplayValue[0] = digitNum1;
-		VfdSegAddr[10].CurrValue1= data.data.vfdData.DisplayValue[0];
-
-		if(YWPANEL_FP_SendData(&data) != true)
-		{
-			ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-			ErrorCode = -ETIME;
-		}
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		ErrorCode = -ETIME;
 	}
-//show minite
+//show minute
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_VFD;
+	digitNum2 = YWPANEL_CharArray[mm / 10 ];
+	digitNum1 = YWPANEL_CharArray[mm % 10];
+	temp = digitNum2;
+	digitNum2 = (digitNum2 & 0xbf) | (digitNum1 & 0x40);
+	digitNum1 = (digitNum1 & 0x3c) | ((temp & 0x40) << 1) | ((digitNum1 & 0x01) << 1) | ((digitNum1 & 0x02) >> 1);
+	data.data.vfdData.type = YWPANEL_VFD_DISPLAY;
+	data.data.vfdData.address[0] = VfdSegAddr[9].Segaddr2;
+	data.data.vfdData.DisplayValue[0] = digitNum2;
+	VfdSegAddr[9].CurrValue2 = data.data.vfdData.DisplayValue[0];
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-
-		memset(&data, 0, sizeof(YWPANEL_FPData_t));
-		data.dataType = YWPANEL_DATATYPE_VFD;
-		digitNum2 = YWPANEL_CharArray[mm/10 ];
-		digitNum1 = YWPANEL_CharArray[mm%10];
-
-		temp = digitNum2;
-		digitNum2 = (digitNum2&0xbf)|(digitNum1&0x40);
-		digitNum1 = (digitNum1&0x3c)|((temp&0x40)<<1)|((digitNum1&0x01)<<1)|((digitNum1&0x02)>>1);
-		data.data.vfdData.type = YWPANEL_VFD_DISPLAY;
-		data.data.vfdData.address[0] = VfdSegAddr[9].Segaddr2;
-
-		data.data.vfdData.DisplayValue[0] = digitNum2;
-		VfdSegAddr[9].CurrValue2 = data.data.vfdData.DisplayValue[0];
-
-		if(YWPANEL_FP_SendData(&data) != true)
-		{
-			ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-			ErrorCode = -ETIME;
-		}
-
-		data.data.vfdData.address[0] = VfdSegAddr[9].Segaddr1;
-
-		data.data.vfdData.DisplayValue[0] = digitNum1;
-		VfdSegAddr[9].CurrValue1= data.data.vfdData.DisplayValue[0];
-
-		if(YWPANEL_FP_SendData(&data) != true)
-		{
-			ywtrace_print(TRACE_ERROR,"YWPANEL_FP_SendData not seccussfully!![%d]\n",__LINE__);
-			ErrorCode = -ETIME;
-		}
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		ErrorCode = -ETIME;
+	}
+	data.data.vfdData.address[0] = VfdSegAddr[9].Segaddr1;
+	data.data.vfdData.DisplayValue[0] = digitNum1;
+	VfdSegAddr[9].CurrValue1 = data.data.vfdData.DisplayValue[0];
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
+		ywtrace_print(TRACE_ERROR, "YWPANEL_FP_SendData failed [%d]\n", __LINE__);
+		ErrorCode = -ETIME;
 	}
 	up(&vfd_sem);
 	return ErrorCode;
 }
 
-int YWPANEL_VFD_ShowTime_Common(u8 hh,u8 mm)
+static int YWPANEL_VFD_ShowTime_Common(u8 hh, u8 mm)
 {
 	int  ErrorCode = 0;
 	if (down_interruptible(&vfd_sem))
 	{
-	   ErrorCode =-EBUSY;
-	   return ErrorCode;
+		ErrorCode = -EBUSY;
+		return ErrorCode;
 	}
-	if( (hh > 24) && (mm > 60))
+	if ((hh > 24) && (mm > 60))
 	{
 		ErrorCode = -EINVAL ;
 	}
-	YWPANEL_VFD_DrawNum((hh/10), 1);
-	YWPANEL_VFD_DrawNum((hh%10), 2);
-	YWPANEL_VFD_DrawNum((mm/10), 3);
-	YWPANEL_VFD_DrawNum((mm%10), 4);
+	YWPANEL_VFD_DrawNum((hh / 10), 1);
+	YWPANEL_VFD_DrawNum((hh % 10), 2);
+	YWPANEL_VFD_DrawNum((mm / 10), 3);
+	YWPANEL_VFD_DrawNum((mm % 10), 4);
 	up(&vfd_sem);
 	return ErrorCode;
 }
 
-
-int YWPANEL_VFD_ShowTime(u8 hh,u8 mm)
+static int YWPANEL_VFD_ShowTime_Unknown(u8 hh, u8 mm)
 {
-	int ErrorCode = 0 ;
-	switch (YWVFD_INFO.vfd_type)
-	{
-		case YWVFD_STAND_BY:
-			ErrorCode = YWPANEL_VFD_ShowTime_StandBy(hh,mm);
-			break;
-		case YWVFD_COMMON:
-			ErrorCode = YWPANEL_VFD_ShowTime_Common(hh,mm);
-			break;
-		default:
-			ErrorCode = -ENODEV;
-			break;
-	}
-	return ErrorCode;
+	return -ENODEV;
 }
 
-int YWPANEL_VFD_ShowTimeOff_StandBy(void)
+static int YWPANEL_VFD_ShowTimeOff_StandBy(void)
 {
-	int   ST_ErrCode = 0;
-	ST_ErrCode = YWPANEL_VFD_ShowTime(0,0);
-	return ST_ErrCode;
+	return YWPANEL_VFD_ShowTime(0, 0);
 }
 
-int YWPANEL_VFD_ShowTimeOff_Common(void)
+static int YWPANEL_VFD_ShowTimeOff_Common(void)
 {
 	int   ST_ErrCode = 0;
 	if (down_interruptible(&vfd_sem))
 	{
-	   ST_ErrCode =-EBUSY;
-	   return ST_ErrCode;
+		ST_ErrCode = -EBUSY;
+		return ST_ErrCode;
 	}
 	ST_ErrCode = YWPANEL_VFD_SegDigSeg(9, SEGNUM1, 0x00);
 	ST_ErrCode = YWPANEL_VFD_SegDigSeg(9, SEGNUM2, 0x00);
@@ -2243,147 +1679,128 @@
 	return ST_ErrCode;
 }
 
-int YWPANEL_VFD_ShowTimeOff(void)
+static int YWPANEL_VFD_ShowTimeOff_Unknown(void)
 {
-	int ErrorCode = 0 ;
-	switch (YWVFD_INFO.vfd_type)
-	{
-		case YWVFD_STAND_BY:
-			ErrorCode = YWPANEL_VFD_ShowTimeOff_StandBy();
-			break;
-
-		case YWVFD_COMMON:
-			ErrorCode = YWPANEL_VFD_ShowTimeOff_Common();
-			break;
-		default:
-			ErrorCode = -ENODEV;
-			break;
-	}
-	return ErrorCode;
+	return -ENODEV;
 }
 
-int YWPANEL_VFD_SetBrightness_StandBy(int level)
+static int YWPANEL_VFD_SetBrightness_StandBy(int level)
 {
-	int 		ST_ErrCode = 0;
-	YWPANEL_FPData_t	data;
+	int         ST_ErrCode = 0;
+	YWPANEL_FPData_t    data;
 	if (down_interruptible(&vfd_sem))
 	{
-	   ST_ErrCode =-EBUSY;
-	   return ST_ErrCode;
+		ST_ErrCode = -EBUSY;
+		return ST_ErrCode;
 	}
-	if(level <=0)
+	if (level < 0)
 		level = 0;
-	else if(level >= 7)
+	else if (level > 7)
 		level = 7;
 	data.dataType = YWPANEL_DATATYPE_VFD;
 	data.data.vfdData.type = YWPANEL_VFD_SETTING;
-	data.data.vfdData.setValue = level+0x88;
-	if(YWPANEL_FP_SendData(&data) != true)
+	data.data.vfdData.setValue = level | 0x88;
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		ywtrace_print(TRACE_ERROR,"SetBrightness wrong!!\n");
+		ywtrace_print(TRACE_ERROR, "SetBrightness wrong!!\n");
 		ST_ErrCode = -ETIME;
 	}
 	up(&vfd_sem);
-	return ST_ErrCode ;
+	return ST_ErrCode;
 }
 
-int YWPANEL_VFD_SetBrightness_Common(int level)
+static int YWPANEL_VFD_SetBrightness_Common(int level)
 {
-	int 		ST_ErrCode = 0;
-	if(level <=0)
+	int         ST_ErrCode = 0;
+	if (level < 0)
 		level = 0;
-	else if(level >= 7)
+	else if (level > 7)
 		level = 7;
-
 	VFD_CS_CLR();
-	YWPANEL_VFD_WR(0x88+level);
+	YWPANEL_VFD_WR(0x88 | level);
 	VFD_CS_SET();
-	return ST_ErrCode ;
+	return ST_ErrCode;
 }
 
-int YWPANEL_VFD_SetBrightness(int level)
+static int YWPANEL_VFD_SetBrightness_Unknown(int level)
 {
-	int ErrorCode = 0 ;
-	switch (YWVFD_INFO.vfd_type)
-	{
-		case YWVFD_STAND_BY:
-			ErrorCode = YWPANEL_VFD_SetBrightness_StandBy(level);
-			break;
-
-		case YWVFD_COMMON:
-			ErrorCode = YWPANEL_VFD_SetBrightness_Common(level);
-			break;
-		default:
-			ErrorCode = -ENODEV;
-			break;
-	}
-	return ErrorCode;
+	return -ENODEV;
 }
 
-u8 YWPANEL_VFD_ScanKeyboard_StandBy(void)
+static u8 YWPANEL_VFD_ScanKeyboard_StandBy(void)
 {
-	YWPANEL_FPData_t		data;
-
+	YWPANEL_FPData_t        data;
 	memset(&data, 0 , sizeof(data));
 	//printk("panel_disp_type = %d\n", panel_disp_type);
-	switch(panel_disp_type)
-	{
-	case YWPANEL_FP_DISPTYPE_VFD:
-		data.dataType = YWPANEL_DATATYPE_VFD;
-		data.data.vfdData.type = YWPANEL_VFD_READKEY;
-		break;
-	case YWPANEL_FP_DISPTYPE_LED:
-		data.dataType = YWPANEL_DATATYPE_SCANKEY;
-		break;
-	case YWPANEL_FP_DISPTYPE_LCD:
-	case YWPANEL_FP_DISPTYPE_LBD:
-	default:
-		break;
-	}
-
-	if(YWPANEL_FP_SendData(&data) == true)
+	switch (panel_disp_type)
 	{
-		//printk("data.data.vfdData.key = %d\n", data.data.vfdData.key);
-		switch(panel_disp_type)
-		{
 		case YWPANEL_FP_DISPTYPE_VFD:
-			return data.data.vfdData.key;
-		case YWPANEL_FP_DISPTYPE_LED:
-			return data.data.ScanKeyData.keyValue;
+			data.dataType = YWPANEL_DATATYPE_VFD;
+			data.data.vfdData.type = YWPANEL_VFD_READKEY;
+			break;
 		case YWPANEL_FP_DISPTYPE_LCD:
+			break;
+		case YWPANEL_FP_DISPTYPE_DVFD:
+			data.dataType = YWPANEL_DATATYPE_SCANKEY;
+			break;
+		case YWPANEL_FP_DISPTYPE_LED:
+			data.dataType = YWPANEL_DATATYPE_SCANKEY;
+			break;
 		case YWPANEL_FP_DISPTYPE_LBD:
+			break;
 		default:
 			break;
+	}
+	if (YWPANEL_FP_SendData(&data) == true)
+	{
+		//printk("data.data.vfdData.key = %d\n", data.data.vfdData.key);
+		switch (panel_disp_type)
+		{
+			case YWPANEL_FP_DISPTYPE_VFD:
+				return data.data.vfdData.key;
+			case YWPANEL_FP_DISPTYPE_LCD:
+				break;
+			case YWPANEL_FP_DISPTYPE_DVFD:
+				return data.data.ScanKeyData.keyValue;
+			case YWPANEL_FP_DISPTYPE_LED:
+				return data.data.ScanKeyData.keyValue;
+			case YWPANEL_FP_DISPTYPE_LBD:
+				break;
+			default:
+				break;
 		}
 	}
 	else
 	{
-		printk("YWPANEL_FP_SendData FALSE\n");
+		//  printk("YWPANEL_FP_SendData FALSE\n");
 	}
 	return INVALID_KEY;
 }
-u8 YWPANEL_VFD_ScanKeyboard_Common(void)
+
+static u8 YWPANEL_VFD_ScanKeyboard_Unknown(void)
 {
-	int   ST_ErrCode = 0;
+	return INVALID_KEY;
+}
+
+static u8 YWPANEL_VFD_ScanKeyboard_Common(void)
+{
+	int ST_ErrCode = 0;
 	u8 key_val[6] ;
 	u8 i = 0;
-
 	VFD_CS_CLR();
 	ST_ErrCode = YWPANEL_VFD_SetMode(VFDREADMODE);
-	if(ST_ErrCode != 0)
+	if (ST_ErrCode != 0)
 	{
 		PANEL_DEBUG(ST_ErrCode);
 		return INVALID_KEY;
 	}
-
 	for (i = 0; i < 6; i++)
 	{
 		key_val[i] = YWPANEL_VFD_RD();
 	}
 	VFD_CS_SET();
-
 	ST_ErrCode = YWPANEL_VFD_SetMode(VFDWRITEMODE);
-	if(ST_ErrCode != 0)
+	if (ST_ErrCode != 0)
 	{
 		PANEL_DEBUG(ST_ErrCode);
 		return INVALID_KEY;
@@ -2396,147 +1813,272 @@
 	int byte = 0;
 	int key_val = INVALID_KEY;
 	if (down_interruptible(&vfd_sem))
-	{
-	   return key_val;
-	}
+		return key_val;
 	switch (YWVFD_INFO.vfd_type)
 	{
 		case YWVFD_STAND_BY:
-			byte = YWPANEL_VFD_ScanKeyboard_StandBy();
-			break;
-
 		case YWVFD_COMMON:
-			byte = YWPANEL_VFD_ScanKeyboard_Common();
+			byte = YWPANEL_VFD_ScanKeyboard();
 			break;
 		default:
 			break;
 	}
-	switch(byte)
+	switch (byte)
 	{
-//		case 0x01:
-//			key_val = EXIT_KEY;
-//			break;
+		case 0x01:
+			key_val = KEY_EXIT;
+			break;
 		case 0x02:
-			key_val = LEFT_KEY;
+			key_val = KEY_LEFT;
 			break;
 		case 0x04:
-			key_val = UP_KEY;
+			key_val = KEY_UP;
 			break;
 		case 0x08:
-			key_val = SELECT_KEY;
+			key_val = KEY_OK;
 			break;
 		case 0x10:
-			key_val = RIGHT_KEY;
+			key_val = KEY_RIGHT;
 			break;
 		case 0x20:
-			key_val = DOWN_KEY;
+			key_val = KEY_DOWN;
 			break;
 		case 0x40:
-			key_val = POWER_KEY;
+			key_val = KEY_POWER;
 			break;
 		case 0x80:
-			key_val = MENU_KEY;
+			key_val = KEY_MENU;
 			break;
 		default:
-			PANEL_PRINT((TRACE_ERROR,"Key 0x%s is INVALID\n",byte));
+			PANEL_PRINT((TRACE_ERROR, "Key 0x%s is INVALID\n", byte));
 		case 0x00:
-			key_val = INVALID_KEY;
+			key_val = KEY_UNKNOWN;
 			break;
 	}
 	up(&vfd_sem);
 	return key_val;
 }
 
+static int  bTimeMode = 1;
+static char strDvfd[16][5];
 
-//lwj add begin  for LED panel
+static void YWVFDi_DVFDCleanChar(u8 i)
+{
+	u8  j;
+	int off = 0;
+	if (i >= 16)
+		return;
+	if (bTimeMode && i >= 10)
+		return;
+	if (bTimeMode)
+		off = 6;
+	for (j = 0; j < 5; j++)
+		strDvfd[i + off][j] = 0;
+}
 
-#define YWPANEL_MAX_LED_LEGNTH	4
-#define YWPANEL_LOWER_START	10
-#define YWPANEL_UPPER_START	36
-
-//   a
-//f     b
-//   g
-//e     c
-//   d      h
-//a b c d e f g h
-u8 YWPANEL_LedCharArray[]=
+static void YWVFDi_DVFDFillAsciiChar(u8 i, int iChar)
 {
-	0xfc,0x60,0xda,0xf2,0x66,0xb6,0xbe,0xe0,0xfe,0xf6,/* 0~9*/
-	0xee,0x3e,0x1a,0x7a,0xde,0x8e,0xf6,0x2e,0x60,0x70,/*a~j*/
-	0x0e,0x1c,0xec,0x2a,0x3a,0xce,0xe6,0x0a,0xb6,0x1e,/* k~t*/
-	0x38,0x46,0x56,0x6e,0x76,0xda, /*u-z*/
-	0xee,0x3e,0x9c,0x7a,0x9e,0x8e,0xf6,0x2e,0x60,0x70,/*A-J*/
-	0x0e,0x1c,0xec,0x2a,0x3a,0xce,0xe6,0x0a,0xb6,0x1e,/*K-T*/
-	0x38,0x46,0x56,0x6e,0x76,0xda/*U-Z*/
-};	//d48zm modify
+	u8  j;
+	int off = 0;
+	if (i >= 16)
+		return;
+	if (bTimeMode  && i >= 10)
+		return;
+	if (bTimeMode)
+		off = 6;
+	for (j = 0; j < 5; j++)
+		strDvfd[i + off][j] = dvfd_bitmap[iChar][j];
+}
 
-u8  YWPANEL_LedDisplayData[YWPANEL_MAX_LED_LEGNTH];
+static void YWVFDi_DVFDFillChar(u8 i, u8 c)
+{
+	if ((c >= 32) && (c <= 126))
+		YWVFDi_DVFDFillAsciiChar(i, c - 32);
+	else
+		YWVFDi_DVFDCleanChar(i);
+}
 
-void YWPANEL_LEDSetString(const char *LEDStrBuf)
+static void YWVFDi_DVFDFillString(char *str)
 {
-	int             i;
-	char		tempData;
-	char 		c;
+	int number_of_utf8_characters = utf8strlen(str, strlen(str));
+	int i;
+	if (number_of_utf8_characters > 15)
+		number_of_utf8_characters = 16;
+	for (i = 0; i < number_of_utf8_characters; i++)
+	{
+		int size = utf8charlen(*str);
+		if (size == 1)
+			YWVFDi_DVFDFillChar(i, *str);
+		else
+			YWVFDi_DVFDCleanChar(i);
+		str += size;
+	}
+	for (; i < 16; i++)
+		YWVFDi_DVFDCleanChar(i);
+}
 
-	u16 StrLen = strlen(LEDStrBuf);
-	for(i=0; i<YWPANEL_MAX_LED_LEGNTH; i++)
-	{
-		c = LEDStrBuf[i];
+static int YWVFDi_DVFDDisplaySync(void)
+{
+	int ret = 0 ;
+	YWPANEL_FPData_t data;
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_DVFD;
+	data.data.dvfdData.type = YWPANEL_DVFD_DISPLAYSYNC;
+	if (YWPANEL_FP_SendData(&data) != true)
+		ret = -2;
+	return ret;
+}
 
-		if(c>='0' && c<='9')
-		{
-			tempData = YWPANEL_LedCharArray[(LEDStrBuf[i]-'0')];
-		}
-		else if(c>='A' && c<='Z')
-		{
-			tempData = YWPANEL_LedCharArray[(c-'A'+YWPANEL_UPPER_START)];
-		}
-		else if(c>='a' && c<='z')
-		{
-			tempData = YWPANEL_LedCharArray[(c-'a'+YWPANEL_LOWER_START)];
-		}
-		else if(c == '-')
-		{
-			tempData = 0x02;
+static int YWVFDi_DVFDSendString(void)
+{
+	int ret = 0;
+	u8  i, j;
+	YWPANEL_FPData_t data;
+	memset(&data, 0, sizeof(YWPANEL_FPData_t));
+	data.dataType = YWPANEL_DATATYPE_DVFD;
+	data.data.dvfdData.type = YWPANEL_DVFD_DISPLAYSTRING;
+	for (i = 0; i < 4; i++)
+	{
+		data.data.dvfdData.ulen = 4;
+		for (j = 0; j < 4; j++)
+		{
+			u8 address = i * 4 + j;
+			data.data.dvfdData.address[j] = address;
+			data.data.dvfdData.DisplayValue[j][0] = strDvfd[address][0];
+			data.data.dvfdData.DisplayValue[j][1] = strDvfd[address][1];
+			data.data.dvfdData.DisplayValue[j][2] = strDvfd[address][2];
+			data.data.dvfdData.DisplayValue[j][3] = strDvfd[address][3];
+			data.data.dvfdData.DisplayValue[j][4] = strDvfd[address][4];
 		}
-		else
+		YWVFD_Debug("%s:%d\n", __FUNCTION__, __LINE__);
+		if (YWPANEL_FP_SendData(&data) != true)
 		{
-			tempData = 0;
+			printk("%s:%d: YWPANEL_FP_SendData() failed\n", __FUNCTION__, __LINE__);
+			ret = -2;
 		}
+	}
+	return ret;
+}
+
+static int YWVFDi_DVFDDisplayString(void)
+{
+	int ret = YWVFDi_DVFDSendString();
+	YWVFD_Debug("%s:%d\n", __FUNCTION__, __LINE__);
+	ret = YWVFDi_DVFDDisplaySync();
+	return ret;
+}
+
+static int YWVFD_STANDBY_DvfdShowString(char *str)
+{
+	int ret = 0;
+	YWVFD_Debug("%s:%d\n", __FUNCTION__, __LINE__);
+	YWVFDi_DVFDFillString(str);
+	YWVFD_Debug("%s:%d\n", __FUNCTION__, __LINE__);
+	ret = YWVFDi_DVFDDisplayString();
+	return ret;
+}
+
+#if 0 //unused
+static int YWPANEL_FP_DvfdSetTimeMode(int on)
+{
+	YWPANEL_FPData_t   Data;
+	memset(&Data, 0, sizeof(YWPANEL_FPData_t));
+	Data.dataType = YWPANEL_DATATYPE_DVFD;
+	Data.data.dvfdData.type = YWPANEL_DVFD_SETTIMEMODE;
+	Data.data.dvfdData.setValue = on;
+	if (YWPANEL_FP_SendData(&Data) != true)
+		return false;
+	bTimeMode = on;
+	return true;
+}
+#endif
+
+static int YWPANEL_FP_DvfdGetTimeMode(int *pOn)
+{
+	YWPANEL_FPData_t   Data;
+	memset(&Data, 0, sizeof(YWPANEL_FPData_t));
+	Data.dataType = YWPANEL_DATATYPE_DVFD;
+	Data.data.dvfdData.type = YWPANEL_DVFD_GETTIMEMODE;
+	if (YWPANEL_FP_SendData(&Data) != true)
+		return false;
+	(*pOn) = Data.data.dvfdData.setValue;
+	bTimeMode = Data.data.dvfdData.setValue;
+	return true;
+}
 
-		if(i<StrLen)
-		{
-			YWPANEL_LedDisplayData[i] = tempData;
-		}
-		else
+//lwj add begin  for LED panel
+
+//  aaaaa
+// f     b
+// f     b
+//  ggggg
+// e     c
+// e     c
+//  ddddd   h
+//
+// a    b    c    d    e    f    g    h
+// 0x80 0x40 0x20 0x10 0x08 0x04 0x02 0x01
+//
+// LED segments: 88.88
+
+static u8 ywpanel_led_map[0x80] =
+{
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0xf0, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00,
+	0xfc, 0x60, 0xda, 0xf2, 0x66, 0xb6, 0xbe, 0xe0, 0xfe, 0xf6, 0x00, 0x00, 0x00, 0x12, 0x00, 0xca,
+	0x00, 0xee, 0x3e, 0x9c, 0x7a, 0x9e, 0x8e, 0xf6, 0x2e, 0x60, 0x70, 0x0e, 0x1c, 0xec, 0x2a, 0x3a,
+	0xce, 0xe6, 0x0a, 0xb6, 0x1e, 0x38, 0x46, 0x56, 0x6e, 0x76, 0xda, 0x9c, 0x00, 0xf0, 0x00, 0x10,
+	0x00, 0xee, 0x3e, 0x1a, 0x7a, 0xde, 0x8e, 0xf6, 0x2e, 0x20, 0x70, 0x0e, 0x1c, 0xec, 0x2a, 0x3a,
+	0xce, 0xe6, 0x0a, 0xb6, 0x1e, 0x38, 0x46, 0x56, 0x6e, 0x76, 0xda, 0x9c, 0x0c, 0xf0, 0x00, 0x00
+};
+
+#define YWPANEL_MAX_LED_LENGTH 4
+static u8  YWPANEL_LedDisplayData[YWPANEL_MAX_LED_LENGTH];
+
+static void YWPANEL_LEDSetString(char *str)
+{
+	int i;
+	int number_of_utf8_characters = utf8strlen(str, strlen(str));
+	for (i = 0; i < YWPANEL_MAX_LED_LENGTH; i++)
+	{
+		YWPANEL_LedDisplayData[i] = 0;
+		if (i < number_of_utf8_characters)
 		{
-			YWPANEL_LedDisplayData[i] = 0;
+			int size = utf8charlen(*str);
+			if (size == 1)
+			{
+				YWPANEL_LedDisplayData[i] = ywpanel_led_map[(unsigned char) * str];
+				if ((i == 1) && ((*(str + 1) == '.') || (*(str + 1) == ',')) && !(YWPANEL_LedDisplayData[i] & 1))
+				{
+					YWPANEL_LedDisplayData[i] |= 1;
+					str++;
+					number_of_utf8_characters--;
+				}
+			}
+			str += size;
 		}
-    }
+	}
 }
-int YWPANEL_LEDDisplayString(void)
+
+static int YWPANEL_LEDDisplayString(void)
 {
 	int ret = 0;
-	YWPANEL_FPData_t    data;
-
+	YWPANEL_FPData_t data;
 	data.dataType = YWPANEL_DATATYPE_LED;
-
-    data.data.ledData.led1 = YWPANEL_LedDisplayData[0];
-    data.data.ledData.led2 = YWPANEL_LedDisplayData[1];
-    data.data.ledData.led3 = YWPANEL_LedDisplayData[2];
-    data.data.ledData.led4 = YWPANEL_LedDisplayData[3];
-
-    if(YWPANEL_FP_SendData(&data)!= true)
-    {
+	data.data.ledData.led1 = YWPANEL_LedDisplayData[0];
+	data.data.ledData.led2 = YWPANEL_LedDisplayData[1];
+	data.data.ledData.led3 = YWPANEL_LedDisplayData[2];
+	data.data.ledData.led4 = YWPANEL_LedDisplayData[3];
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
 		ret = -1;
-        ywtrace_print(TRACE_ERROR, "[ERROR][YWPANEL_LEDDisplayString] TIME OUT\n");
-    }
-
+		ywtrace_print(TRACE_ERROR, "[ERROR][YWPANEL_LEDDisplayString] TIME OUT\n");
+	}
 	return ret;
 }
 
-int YWVFD_LED_ShowString(const char *str)
+static int YWVFD_LED_ShowString(char *str)
 {
 	YWPANEL_FP_ControlTimer(false);
 	YWPANEL_LEDSetString(str);
@@ -2545,288 +2087,211 @@
 
 //lwj add end
 
-int YWPANEL_VFD_ShowString_StandBy(char* str)
+static int lookup_utf8(unsigned char *str, int *v1, int *v2)
 {
-	int ST_ErrCode = 0, pos = 0;
-	u8 lenth;
-	u8 i,c;
-
-	YWPANEL_FPData_t	data;
-
-	if (down_interruptible(&vfd_sem))
-	{
-	   ST_ErrCode =-EBUSY;
-	   return ST_ErrCode;
+	// str is guaranteed to start with a valid UTF-8 character, no UTF-8 validation required
+	int size = utf8charlen(*str);
+	*v1 = *v2 = 0;
+	// Plain ASCII
+	if (size == 1)
+	{
+		u8 c = ywpanel_vfd_map[*str];
+		*v1 = CharLib[c][0];
+		*v2 = CharLib[c][1];
+		return size;
 	}
-	lenth = utf8_len(str, strlen(str));
-	if(lenth > 8)
+	// UTF+0400 to 047F
+	switch (*str)
 	{
-		ST_ErrCode = -EINVAL ;
-		PANEL_DEBUG(ST_ErrCode);
+		case 0xc4:
+			str++;
+			*v1 = UTF_C4[*str & 0x3f][0];
+			*v2 = UTF_C4[*str & 0x3f][1];
+			break;
+		case 0xc5:
+			str++;
+			*v1 = UTF_C5[*str & 0x3f][0];
+			*v2 = UTF_C5[*str & 0x3f][1];
+			break;
+		case 0xd0:
+			str++;
+			*v1 = UTF_D0[*str & 0x3f][0];
+			*v2 = UTF_D0[*str & 0x3f][1];
+			break;
+		case 0xd1:
+			str++;
+			*v1 = UTF_D1[*str & 0x3f][0];
+			*v2 = UTF_D1[*str & 0x3f][1];
+			break;
+	}
+	return size;
+}
 
-		up(&vfd_sem);
+static int YWPANEL_VFD_ShowString_StandBy(char *str)
+{
+	int ST_ErrCode = 0 ;
+	int number_of_utf8_characters, i;
+	YWPANEL_FPData_t    data;
+	if (down_interruptible(&vfd_sem))
+	{
+		ST_ErrCode = -EBUSY;
 		return ST_ErrCode;
 	}
+	number_of_utf8_characters = utf8strlen(str, strlen(str));
 	data.dataType = YWPANEL_DATATYPE_VFD;
-	for(i = 0; i < 8; i++)
+	for (i = 0; i < 8; i++)
 	{
+		int v1 = 0, v2 = 0;
 		data.data.vfdData.type = YWPANEL_VFD_DISPLAYSTRING;
-		if(i < lenth)
+		if (number_of_utf8_characters)
 		{
-			c = str[pos] ;
-			//single char
-			if (c < 128) {
-			if(c >= 65 && c <= 95)
-				c = c - 65;
-			else if(c >= 97 && c <= 122)
-				c = c - 97;
-			else if(c >= 42 && c <= 57)
-				c = c - 11;
-			else if(c == 32)
-				c = 47;
-			else
+			int usedbytes = lookup_utf8((unsigned char *)str, &v1, &v2);
+			if (usedbytes)
 			{
-				c = 47;
+				number_of_utf8_characters--;
+				str += usedbytes;
 			}
-			VfdSegAddr[i+1].CurrValue1 = CharLib[c][0] ;
-			VfdSegAddr[i+1].CurrValue2 = CharLib[c][1] ;
-			pos += 1;
-
-			//double char
-			} else {
-				u8 val1, val2;
-				utf8_symbol(&str[pos], &str[pos+1], &val1, &val2);
-				VfdSegAddr[i+1].CurrValue1 = val1;
-				VfdSegAddr[i+1].CurrValue2 = val2;
-				pos += 2;
-			}
-		}
-		else
-		{
-			VfdSegAddr[i+1].CurrValue1 = 0;
-			VfdSegAddr[i+1].CurrValue2 = 0;
+			else
+				number_of_utf8_characters = 0;
 		}
-		data.data.vfdData.address[2*i] = VfdSegAddr[i+1].Segaddr1;
-		data.data.vfdData.DisplayValue[2*i] = VfdSegAddr[i+1].CurrValue1;
-		data.data.vfdData.address[2*i+1] = VfdSegAddr[i+1].Segaddr2;
-		data.data.vfdData.DisplayValue[2*i+1] = VfdSegAddr[i+1].CurrValue2;
+		VfdSegAddr[i + 1].CurrValue1 = v1;
+		VfdSegAddr[i + 1].CurrValue2 = v2;
+		data.data.vfdData.address[2 * i] = VfdSegAddr[i + 1].Segaddr1;
+		data.data.vfdData.DisplayValue[2 * i] = VfdSegAddr[i + 1].CurrValue1;
+		data.data.vfdData.address[2 * i + 1] = VfdSegAddr[i + 1].Segaddr2;
+		data.data.vfdData.DisplayValue[2 * i + 1] = VfdSegAddr[i + 1].CurrValue2;
 	}
-
-	if(YWPANEL_FP_SendData(&data) != true)
+	if (YWPANEL_FP_SendData(&data) != true)
 	{
-		PANEL_DEBUG("VFD show stings is wrong!!\n");
+		PANEL_DEBUG("VFD show strings is wrong!!\n");
 		ST_ErrCode = -ETIME;
 	}
 	up(&vfd_sem);
 	return ST_ErrCode;
- }
+}
 
-int YWPANEL_VFD_ShowString_Common(char* str)
+static int YWPANEL_VFD_ShowString_Common(char *str)
 {
 	int ST_ErrCode = 0 ;
-	u8 lenth;
-	u8 i;
-
+	int number_of_utf8_characters, i;
 	if (down_interruptible(&vfd_sem))
 	{
-	   ST_ErrCode =-EBUSY;
-	   return ST_ErrCode;
-	}
-	lenth = strlen(str);
-	if(lenth > 8)
-	{
-		ST_ErrCode = -EINVAL ;
-		PANEL_DEBUG(ST_ErrCode);
+		ST_ErrCode = -EBUSY;
 		return ST_ErrCode;
 	}
-	for(i = 0; i < 8; i++)
+	number_of_utf8_characters = utf8strlen(str, strlen(str));
+	for (i = 1; i < 9; i++)
 	{
-		if(i < lenth)
-		{
-			YWPANEL_VFD_DrawChar(*str, i + 1);
-			str++;
-		}
-		else
+		int v1 = 0, v2 = 0;
+		if (number_of_utf8_characters)
 		{
-			YWPANEL_VFD_DrawChar(' ', i + 1);
+			int usedbytes = lookup_utf8((unsigned char *)str, &v1, &v2);
+			if (usedbytes)
+			{
+				number_of_utf8_characters--;
+				str += usedbytes;
+			}
+			else
+				number_of_utf8_characters = 0;
 		}
+		YWPANEL_VFD_SegDigSeg(i, SEGNUM1, v1);
+		YWPANEL_VFD_SegDigSeg(i, SEGNUM2, v2);
 	}
 	up(&vfd_sem);
 	return ST_ErrCode;
- }
-
-//lwj modify begin
-#if 0
-int YWPANEL_VFD_ShowString(char* str)
-{
-	int ErrorCode = 0 ;
-	switch (YWVFD_INFO.vfd_type)
-	{
-		case YWVFD_STAND_BY:
-			ErrorCode = YWPANEL_VFD_ShowString_StandBy(str);
-			break;
-
-		case YWVFD_COMMON:
-			ErrorCode = YWPANEL_VFD_ShowString_Common(str);
-			break;
-		default:
-			ErrorCode = -ENODEV;
-			break;
-	}
-	return ErrorCode;
 }
-#else
-int YWPANEL_VFD_ShowString(char* str)
-{
-	int ret = 0;
-
-	if(YWVFD_INFO.vfd_type == YWVFD_STAND_BY)
-	{
-		switch(panel_disp_type)
-		{
-			case YWPANEL_FP_DISPTYPE_VFD:
-                		ywtrace_print(TRACE_INFO, "YWPANEL_VFD_ShowString_StandBy ====\n");
-				ret = YWPANEL_VFD_ShowString_StandBy(str);
-				break;
 
-			case YWPANEL_FP_DISPTYPE_LED:
-            		    	ywtrace_print(TRACE_INFO, "YWVFD_LED_ShowString ====\n");
-				ret = YWVFD_LED_ShowString(str);
-				break;
-
-			default:
-				ret = -1;
-				break;
-		}
-	}
-	else
-	{
-		ret = YWPANEL_VFD_ShowString_Common(str);
-	}
-
-	return ret;
+static int YWPANEL_VFD_ShowString_Unknown(char *str)
+{
+	return -ENODEV;
 }
-#endif
-//lwj remove end
 
-int YWPANEL_VFD_ShowIco_StandBy(LogNum_T log_num,int log_stat)
+static int YWPANEL_VFD_ShowIcon_StandBy(int which, int on)
 {
 	int ST_ErrCode = 0 ;
-	int dig_num = 0,seg_num = 0;
+	int dig_num = 0, seg_num = 0;
 	SegNum_T seg_part = 0;
-	u8	seg_offset = 0;
-	YWPANEL_FPData_t		data;
-
+	u8 seg_offset = 0;
+	YWPANEL_FPData_t data;
 	data.dataType = YWPANEL_DATATYPE_VFD;
-
 	if (down_interruptible(&vfd_sem))
+		return -EBUSY;
+	if (which < AOTOM_FIRST || which > AOTOM_LAST)
 	{
-	   ST_ErrCode =-EBUSY;
-	   return ST_ErrCode;
-	}
-
-	if(log_num >= LogNum_Max)
-	{
-		ST_ErrCode = -EINVAL ;
 		PANEL_DEBUG(ST_ErrCode);
-
 		up(&vfd_sem);
-		return ST_ErrCode;
+		return -EINVAL;
 	}
-	dig_num = log_num/16;
-	seg_num = log_num%16;
-	seg_part = seg_num/9;
-
+	dig_num = which / 16;
+	seg_num = which % 16;
+	seg_part = seg_num / 9;
 	data.data.vfdData.type = YWPANEL_VFD_DISPLAY;
-
-	if(seg_part == SEGNUM1)
+	if (seg_part == SEGNUM1)
 	{
-		seg_offset = 0x01 << ((seg_num%9) - 1);
+		seg_offset = 0x01 << ((seg_num % 9) - 1);
 		data.data.vfdData.address[0] = VfdSegAddr[dig_num].Segaddr1;
-		if(log_stat == LOG_ON)
-		{
-		   VfdSegAddr[dig_num].CurrValue1 |= seg_offset;
-		}
-		if(log_stat == LOG_OFF)
-		{
-		   VfdSegAddr[dig_num].CurrValue1 &= (0xFF-seg_offset);
-		}
+		if (on)
+			VfdSegAddr[dig_num].CurrValue1 |= seg_offset;
+		else
+			VfdSegAddr[dig_num].CurrValue1 &= (0xFF - seg_offset);
 		data.data.vfdData.DisplayValue[0] = VfdSegAddr[dig_num].CurrValue1 ;
 	}
-	else if(seg_part == SEGNUM2)
+	else if (seg_part == SEGNUM2)
 	{
-		seg_offset = 0x01 << ((seg_num%8) - 1);
+		seg_offset = 0x01 << ((seg_num % 8) - 1);
 		data.data.vfdData.address[0] = VfdSegAddr[dig_num].Segaddr2;
-		if(log_stat == LOG_ON)
-		{
-		   VfdSegAddr[dig_num].CurrValue2 |= seg_offset;
-		}
-		if(log_stat == LOG_OFF)
-		{
-		   VfdSegAddr[dig_num].CurrValue2 &= (0xFF-seg_offset);
-		}
+		if (on)
+			VfdSegAddr[dig_num].CurrValue2 |= seg_offset;
+		else
+			VfdSegAddr[dig_num].CurrValue2 &= (0xFF - seg_offset);
 		data.data.vfdData.DisplayValue[0] = VfdSegAddr[dig_num].CurrValue2 ;
 	}
-   if(YWPANEL_FP_SendData(&data) != true)
-   {
-		ywtrace_print(TRACE_ERROR,"Show a Ico wrong!!\n");
+	if (YWPANEL_FP_SendData(&data) != true)
+	{
+		ywtrace_print(TRACE_ERROR, "Show a Icon wrong!!\n");
 		ST_ErrCode = -ETIME;
-   }
+	}
 	up(&vfd_sem);
 	return ST_ErrCode ;
 }
 
-int YWPANEL_VFD_ShowIco_Common(LogNum_T log_num,int log_stat)
+static int YWPANEL_VFD_ShowIcon_Common(int which, int on)
 {
 	int ST_ErrCode = 0 ;
-	int dig_num = 0,seg_num = 0;
+	int dig_num = 0, seg_num = 0;
 	SegNum_T seg_part = 0;
-	u8	seg_offset = 0;
-	u8	addr = 0,val = 0;
-
+	u8  seg_offset = 0;
+	u8  addr = 0, val = 0;
 	if (down_interruptible(&vfd_sem))
+		return -EBUSY;
+	if (which < AOTOM_FIRST || which > AOTOM_LAST)
 	{
-	   ST_ErrCode =-EBUSY;
-	   return ST_ErrCode;
-	}
-
-	if(log_num >= LogNum_Max)
-	{
-		ST_ErrCode = -EINVAL ;
 		PANEL_DEBUG(ST_ErrCode);
-		return ST_ErrCode;
+		up(&vfd_sem);
+		return -EINVAL;
 	}
-	dig_num = log_num/16;
-	seg_num = log_num%16;
-	seg_part = seg_num/9;
-
+	dig_num = which / 16;
+	seg_num = which % 16;
+	seg_part = seg_num / 9;
 	VFD_CS_CLR();
-	if(seg_part == SEGNUM1)
+	if (seg_part == SEGNUM1)
 	{
-		seg_offset = 0x01 << ((seg_num%9) - 1);
+		seg_offset = 0x01 << ((seg_num % 9) - 1);
 		addr = VfdSegAddr[dig_num].Segaddr1;
-		if(log_stat == LOG_ON)
-		{
-		   VfdSegAddr[dig_num].CurrValue1 |= seg_offset;
-		}
-		if(log_stat == LOG_OFF)
-		{
-		   VfdSegAddr[dig_num].CurrValue1 &= (0xFF-seg_offset);
-		}
+		if (on)
+			VfdSegAddr[dig_num].CurrValue1 |= seg_offset;
+		else
+			VfdSegAddr[dig_num].CurrValue1 &= (0xFF - seg_offset);
 		val = VfdSegAddr[dig_num].CurrValue1 ;
 	}
-	else if(seg_part == SEGNUM2)
+	else if (seg_part == SEGNUM2)
 	{
-		seg_offset = 0x01 << ((seg_num%8) - 1);
+		seg_offset = 0x01 << ((seg_num % 8) - 1);
 		addr = VfdSegAddr[dig_num].Segaddr2;
-		if(log_stat == LOG_ON)
-		{
-		   VfdSegAddr[dig_num].CurrValue2 |= seg_offset;
-		}
-		if(log_stat == LOG_OFF)
-		{
-		   VfdSegAddr[dig_num].CurrValue2 &= (0xFF-seg_offset);
-		}
+		if (on)
+			VfdSegAddr[dig_num].CurrValue2 |= seg_offset;
+		else
+			VfdSegAddr[dig_num].CurrValue2 &= (0xFF - seg_offset);
 		val = VfdSegAddr[dig_num].CurrValue2 ;
 	}
 	ST_ErrCode = YWPANEL_VFD_WR(addr);
@@ -2837,29 +2302,15 @@
 	return ST_ErrCode ;
 }
 
-int YWPANEL_VFD_ShowIco(LogNum_T log_num,int log_stat)
+static int YWPANEL_VFD_ShowIcon_Unknown(int which __attribute__((unused)), int on __attribute__((unused)))
 {
-	int ErrorCode = 0 ;
-	switch (YWVFD_INFO.vfd_type)
-	{
-		case YWVFD_STAND_BY:
-			ErrorCode = YWPANEL_VFD_ShowIco_StandBy(log_num,log_stat);
-			break;
-
-		case YWVFD_COMMON:
-			ErrorCode = YWPANEL_VFD_ShowIco_Common(log_num,log_stat);
-			break;
-		default:
-			ErrorCode = -ENODEV;
-			break;
-	}
-	return ErrorCode;
+	return -ENODEV;
 }
 
 #ifdef CONFIG_CPU_SUBTYPE_STX7105
-int YWPANEL_VFD_DETECT(void)
+static int YWPANEL_VFD_DETECT(void)
 {
-	int 	ret = 0;
+	int     ret = 0;
 	softi2c_init();
 	if (softi2c_online())
 	{
@@ -2874,213 +2325,196 @@
 	return ret;
 }
 #else
-int YWPANEL_VFD_DETECT(void)
+static int YWPANEL_VFD_DETECT(void)
 {
-	int 	ret = 0;
-	u8	localBuff[2] = {0xaa, 0xaa};
-
+	int     ret = 0;
+	u8  localBuff[2] = {0xaa, 0xaa};
 	struct i2c_msg i2c_msg = { .addr = I2C_BUS_ADD, .flags = 0, .buf = localBuff, .len = 2 };
-
-	YWVFD_INFO.vfd_type = YWVFD_UNKNOW;
+	YWVFD_INFO.vfd_type = YWVFD_UNKNOWN;
 	//printk("%s:%d\n", __FUNCTION__, __LINE__);
 	panel_i2c_adapter = i2c_get_adapter(I2C_BUS_NUM);
-	if(NULL == panel_i2c_adapter)
+	if (NULL == panel_i2c_adapter)
 	{
-		ywtrace_print(TRACE_ERROR,"i2c_get_adapter failed\n");
+		ywtrace_print(TRACE_ERROR, "i2c_get_adapter failed\n");
 		return -ENODEV;
 	}
 	/* use i2c write to detect */
-
 	//printk("%s:%d\n", __FUNCTION__, __LINE__);
 	ret = i2c_transfer(panel_i2c_adapter, &i2c_msg, 1);
-	if(ret == 1)
-	{
+	if (ret == 1)
 		YWVFD_INFO.vfd_type = YWVFD_STAND_BY;
-		ret = 0;
-	}
 	else
-	{
 		YWVFD_INFO.vfd_type = YWVFD_COMMON;
-		ret = -EINVAL;
-	}
-
 	return 0;
-
 }
 #endif
 
-int YWPANEL_VFD_GetRevision(char * version)
+static int YWPANEL_VFD_Init_Unknown(void)
 {
-	int ErrorCode = 0 ;
-	char *DispType = "VFD";	// VFD default
-
-	switch (YWVFD_INFO.vfd_type)
-	{
-		case YWVFD_STAND_BY:
-		{
-			switch(panel_disp_type)
-			{
-			case YWPANEL_FP_DISPTYPE_VFD:
-				DispType = "VFD";
-				break;
-			case YWPANEL_FP_DISPTYPE_LCD:
-				DispType = "LCD";
-				break;
-			case YWPANEL_FP_DISPTYPE_LED:
-				DispType = "LED";
-				break;
-			case YWPANEL_FP_DISPTYPE_LBD:
-				DispType = "LBD";
-				break;
-			default:
-				break;
-			}
-			sprintf(version,"%s Type:%s-%s",Revision,"StandBy", DispType);
-			break;
-		}
-		case YWVFD_COMMON:
-			sprintf(version,"%s Type:%s",Revision,"Common");
-			break;
-		default:
-			ErrorCode = -ENODEV;
-			break;
-	}
-	return ErrorCode;
+	return 0;
 }
 
-int YWPANEL_VFD_Init_StandBy(void)
+static int YWPANEL_VFD_Init_StandBy(void)
 {
 	int ErrorCode = 0 ;
 	init_MUTEX(&vfd_sem);
 	init_MUTEX(&vfd_sem_rw);
-
 	YWPANEL_Seg_Addr_Init();
 	return ErrorCode;
- }
+}
 
-int YWPANEL_VFD_Init_Common(void)
+static int YWPANEL_VFD_Init_Common(void)
 {
 	int ErrorCode = 0 ;
-
 	init_MUTEX(&vfd_sem);
 	init_rwsem(&vfd_rws);
-
-	pio_sda = stpio_request_pin(3,2, "pio_sda", STPIO_OUT);
-	pio_scl = stpio_request_pin(3,4, "pio_scl", STPIO_OUT);
-	pio_cs  = stpio_request_pin(3,5, "pio_cs",  STPIO_OUT);
-	if (!pio_sda || !pio_scl || !pio_cs )
+	pio_sda = stpio_request_pin(3, 2, "pio_sda", STPIO_OUT);
+	pio_scl = stpio_request_pin(3, 4, "pio_scl", STPIO_OUT);
+	pio_cs  = stpio_request_pin(3, 5, "pio_cs",  STPIO_OUT);
+	if (!pio_sda || !pio_scl || !pio_cs)
 	{
-	   return ErrorCode;
+		return -ENODEV;
 	}
 	stpio_set_pin(pio_scl, 1);
 	stpio_set_pin(pio_cs,  1);
-
 	VFD_CS_CLR();
 	ErrorCode = YWPANEL_VFD_WR(0x0C);
 	VFD_CS_SET();
-
 	ErrorCode = YWPANEL_VFD_SetMode(VFDWRITEMODE);
 	YWPANEL_Seg_Addr_Init();
 	YWPANEL_VFD_ClearAll();
 	//YWPANEL_VFD_ShowContent();
-	YWPANEL_VFD_ShowString("welcome!");
-
+	//YWPANEL_VFD_ShowString("welcome!");
 	return ErrorCode;
- }
-
-int YWPANEL_VFD_Init(ushort *mode_digit)
-{
-	int ErrorCode = 0 ;
-	YWPANEL_Version_t panel_version;
+}
 
+static int  YWPANEL_VFD_Term_Unknown(void);
+static int  YWPANEL_VFD_Term_StandBy(void);
+static int  YWPANEL_VFD_Term_Common(void);
+
+int (*YWPANEL_VFD_Term)(void);
+int (*YWPANEL_VFD_Initialize)(void);
+int (*YWPANEL_VFD_ShowIcon)(int, int);
+int (*YWPANEL_VFD_ShowTime)(u8 hh, u8 mm);
+int (*YWPANEL_VFD_ShowTimeOff)(void);
+int (*YWPANEL_VFD_SetBrightness)(int);
+u8(*YWPANEL_VFD_ScanKeyboard)(void);
+int (*YWPANEL_VFD_ShowString)(char *);
+
+int YWPANEL_width = 8;
+
+YWPANEL_Version_t panel_version;
+
+int YWPANEL_VFD_Init(void)
+{
+	int ErrorCode = -ENODEV;
+	YWPANEL_VFD_Initialize = YWPANEL_VFD_Init_Unknown;
+	YWPANEL_VFD_Term = YWPANEL_VFD_Term_Unknown;
+	YWPANEL_VFD_ShowIcon = YWPANEL_VFD_ShowIcon_Unknown;
+	YWPANEL_VFD_ShowTime = YWPANEL_VFD_ShowTime_Unknown;
+	YWPANEL_VFD_ShowTimeOff = YWPANEL_VFD_ShowTimeOff_Unknown;
+	YWPANEL_VFD_SetBrightness = YWPANEL_VFD_SetBrightness_Unknown;
+	YWPANEL_VFD_ScanKeyboard = YWPANEL_VFD_ScanKeyboard_Unknown;
+	YWPANEL_VFD_ShowString = YWPANEL_VFD_ShowString_Unknown;
 	if (YWPANEL_VFD_DETECT() != 0)
 	{
 		ywtrace_print(TRACE_ERROR, "vfd detect failed\n");
-		return 0;
+		return ErrorCode;
 	}
-
-	//printk("%s:%d\n", __FUNCTION__, __LINE__);
-
-
+	printk("VfdType = %d\n", YWVFD_INFO.vfd_type);
 	switch (YWVFD_INFO.vfd_type)
 	{
 		case YWVFD_STAND_BY:
-			ErrorCode = YWPANEL_VFD_Init_StandBy();
+			YWPANEL_VFD_Initialize = YWPANEL_VFD_Init_StandBy;
+			YWPANEL_VFD_Term = YWPANEL_VFD_Term_StandBy;
+			YWPANEL_VFD_ShowIcon = YWPANEL_VFD_ShowIcon_StandBy;
+			YWPANEL_VFD_ShowTime = YWPANEL_VFD_ShowTime_StandBy;
+			YWPANEL_VFD_ShowTimeOff = YWPANEL_VFD_ShowTimeOff_StandBy;
+			YWPANEL_VFD_SetBrightness = YWPANEL_VFD_SetBrightness_StandBy;
+			YWPANEL_VFD_ScanKeyboard = YWPANEL_VFD_ScanKeyboard_StandBy;
+			YWPANEL_VFD_ShowString = YWPANEL_VFD_ShowString_StandBy;
 			break;
-
 		case YWVFD_COMMON:
-			ErrorCode = YWPANEL_VFD_Init_Common();
+			YWPANEL_VFD_Initialize = YWPANEL_VFD_Init_Common;
+			YWPANEL_VFD_Term = YWPANEL_VFD_Term_Common;
+			YWPANEL_VFD_ShowIcon = YWPANEL_VFD_ShowIcon_Common;
+			YWPANEL_VFD_ShowTime = YWPANEL_VFD_ShowTime_Common;
+			YWPANEL_VFD_ShowTimeOff = YWPANEL_VFD_ShowTimeOff_Common;
+			YWPANEL_VFD_SetBrightness = YWPANEL_VFD_SetBrightness_Common;
+			YWPANEL_VFD_ScanKeyboard = YWPANEL_VFD_ScanKeyboard_Common;
+			YWPANEL_VFD_ShowString = YWPANEL_VFD_ShowString_Common;
 			break;
 		default:
-			ErrorCode = -ENODEV;
-			break;
+			return ErrorCode;
 	}
-
-	//printk("%s:%d\n", __FUNCTION__, __LINE__);
-
+	ErrorCode = YWPANEL_VFD_Initialize();
 	memset(&panel_version, 0, sizeof(YWPANEL_Version_t));
-
-	if(YWPANEL_FP_GetVersion(&panel_version))
+	if (YWPANEL_FP_GetVersion(&panel_version))
 	{
+		int i;
+		u32 k;
 		panel_disp_type = panel_version.DisplayInfo;
-		if(panel_disp_type<YWPANEL_FP_DISPTYPE_UNKNOWN || panel_disp_type>YWPANEL_FP_DISPTYPE_LBD)
-		{
+		if (panel_disp_type < YWPANEL_FP_DISPTYPE_UNKNOWN || panel_disp_type > YWPANEL_FP_DISPTYPE_LBD)
 			panel_disp_type = YWPANEL_FP_DISPTYPE_VFD;
-		}
-		if (*mode_digit == DIGITNO)
+		switch (panel_disp_type)
 		{
-		    if (panel_disp_type == YWPANEL_FP_DISPTYPE_VFD) *mode_digit = DIGIT8;
-		    if (panel_disp_type == YWPANEL_FP_DISPTYPE_LED) *mode_digit = DIGIT4;
+			case YWPANEL_FP_DISPTYPE_VFD:
+				YWPANEL_VFD_ShowString = YWPANEL_VFD_ShowString_StandBy;
+				break;
+			case YWPANEL_FP_DISPTYPE_DVFD:
+			{
+				int bOn;
+				YWPANEL_FP_DvfdGetTimeMode(&bOn);
+				YWPANEL_VFD_ShowString = YWVFD_STANDBY_DvfdShowString;
+				break;
+			}
+			case YWPANEL_FP_DISPTYPE_LED:
+				YWPANEL_width = 4;
+				YWPANEL_VFD_ShowString = YWVFD_LED_ShowString;
+				break;
+			default:
+				break;
 		}
+		printk("CpuType = %d\n", panel_version.CpuType);
+		printk("DisplayInfo = %d\n", panel_version.DisplayInfo);
+		printk("scankeyNum = %d\n", panel_version.scankeyNum);
+		printk("swMajorVersion = %d\n", panel_version.swMajorVersion);
+		printk("swSubVersion = %d\n", panel_version.swSubVersion);
+		for (i = 0; i < 5; i++)
+			if (YWPANEL_FP_GetKey(0, i, &k))
+				printk("stby key %d = %.8x\n", i, k);
+		for (i = 0; i < 5; i++)
+			if (YWPANEL_FP_GetKey(1, i, &k))
+				printk("blue key %d = %.8x\n", i, k);
 	}
 	else
-	{
 		ErrorCode = -ENODEV;
-	}
-
-	printk("CpuType = %d\n", panel_version.CpuType);
-	printk("DisplayInfo = %d\n", panel_version.DisplayInfo);
-	printk("scankeyNum = %d\n", panel_version.scankeyNum);
-	printk("swMajorVersion = %d\n", panel_version.swMajorVersion);
-	printk("swSubVersion = %d\n", panel_version.swSubVersion);
-	if (*mode_digit == DIGITNO )
-	{
-	    printk("Auto = (none)\n");
-	}
-	else 
-	    printk("Auto = %d digit\n", *mode_digit);
 	return ErrorCode;
 }
 
-//int  YWPANEL_VFD_Term_StandBy(void)
-//{
-//	return 0;
-//}
-//int  YWPANEL_VFD_Term_Common(void)
-//{
-//	return 0;
-//}
-//
-//int YWPANEL_VFD_Term(void)
-//{
-//	int ErrorCode = 0 ;
-//	switch (YWVFD_INFO.vfd_type)
-//	{
-//		case YWVFD_STAND_BY:
-//			ErrorCode = YWPANEL_VFD_Term_StandBy();
-//			break;
-//
-//		case YWVFD_COMMON:
-//			ErrorCode = YWPANEL_VFD_Term_Common();
-//			break;
-//		default:
-//			ErrorCode = -ENODEV;
-//			break;
-//	}
-//#ifdef CONFIG_CPU_SUBTYPE_STX7105
-//	softi2c_cleanup();
-//#else
-//	i2c_put_adapter(panel_i2c_adapter);
-//#endif
-//	return ErrorCode;
-//}
+static int YWPANEL_VFD_Term_Unknown(void)
+{
+	return -ENODEV;
+}
+
+static int  YWPANEL_VFD_Term_StandBy(void)
+{
+#ifdef CONFIG_CPU_SUBTYPE_STX7105
+	softi2c_cleanup();
+#else
+	i2c_put_adapter(panel_i2c_adapter);
+#endif
+	return 0;
+}
+
+static int  YWPANEL_VFD_Term_Common(void)
+{
+#ifdef CONFIG_CPU_SUBTYPE_STX7105
+	softi2c_cleanup();
+#else
+	i2c_put_adapter(panel_i2c_adapter);
+#endif
+	return 0;
+}
+
+// vim:ts=4
diff -Naur a/frontcontroller/aotom/aotom_ywdefs.h b/frontcontroller/aotom/aotom_ywdefs.h
--- a/frontcontroller/aotom/aotom_ywdefs.h	2017-05-01 20:31:14.716295230 +0200
+++ b/frontcontroller/aotom/aotom_ywdefs.h	2017-05-02 14:19:36.518095729 +0200
@@ -2,54 +2,54 @@
 #ifndef __AOTOM_YWDEFS_H__
 #define __AOTOM_YWDEFS_H__
 
-#define YW_K              		(1024)
-#define YW_M              		(YW_K * YW_K)
-#define YW_G              		(YW_K * YW_K * YW_K)
+#define YW_K                    (1024)
+#define YW_M                    (YW_K * YW_K)
+#define YW_G                    (YW_K * YW_K * YW_K)
 #define YW_ENDIAN_LITTLE
 
 #define YWOS_MODULE_PUBLIC_ID               300
 #define YWOS_MODULE_SYSTEMEVT_ID            305
 #define YWOS_MODULE_EVT_ID                  310
-#define	YWOS_MODULE_LIB_ID				    311
+#define YWOS_MODULE_LIB_ID                  311
 
-#define	YWHAL_MODULE_PUBLIC_ID  			400
-#define	YWHAL_MODULE_SYSTEM_ID  			410
-#define	YWHAL_MODULE_PTI_ID  				411
-#define	YWHAL_MODULE_VIDEO_ID  				412
-#define	YWHAL_MODULE_AUDIO_ID  				413
-#define	YWHAL_MODULE_ENCODER_ID  			414
-#define	YWHAL_MODULE_CANVAS_ID  			415
-#define	YWHAL_MODULE_AVOS_ID  				416
-#define	YWHAL_MODULE_TUNER_ID  				417
-#define	YWHAL_MODULE_FLASH_ID  				418
-#define	YWHAL_MODULE_VFS_ID  				419
-#define	YWHAL_MODULE_USB_ID  				420
-#define	YWHAL_MODULE_UART_ID  				421
-#define	YWHAL_MODULE_RTC_ID  				422
-#define	YWHAL_MODULE_PANEL_ID 				423
-#define	YWHAL_MODULE_PHY_ID  				424
-#define	YWHAL_MODULE_PCM_ID  				425
-#define	YWHAL_MODULE_SMART_ID  				426
-#define	YWHAL_MODULE_I2C_ID  				427
-#define	YWHAL_MODULE_GPIO_ID				428
-#define	YWHAL_MODULE_HDD_ID					429
-#define	YWHAL_MODULE_INJECT_ID				430
-#define	YWHAL_MODULE_PVR_ID                 431
-#define	YWHAL_MODULE_TCPIP_ID  				432
-#define	YWHAL_MODULE_PLUGINSWP_ID  			433
-#define	YWHAL_MODULE_CA_ID  				434
+#define YWHAL_MODULE_PUBLIC_ID              400
+#define YWHAL_MODULE_SYSTEM_ID              410
+#define YWHAL_MODULE_PTI_ID                 411
+#define YWHAL_MODULE_VIDEO_ID               412
+#define YWHAL_MODULE_AUDIO_ID               413
+#define YWHAL_MODULE_ENCODER_ID             414
+#define YWHAL_MODULE_CANVAS_ID              415
+#define YWHAL_MODULE_AVOS_ID                416
+#define YWHAL_MODULE_TUNER_ID               417
+#define YWHAL_MODULE_FLASH_ID               418
+#define YWHAL_MODULE_VFS_ID                 419
+#define YWHAL_MODULE_USB_ID                 420
+#define YWHAL_MODULE_UART_ID                421
+#define YWHAL_MODULE_RTC_ID                 422
+#define YWHAL_MODULE_PANEL_ID               423
+#define YWHAL_MODULE_PHY_ID                 424
+#define YWHAL_MODULE_PCM_ID                 425
+#define YWHAL_MODULE_SMART_ID               426
+#define YWHAL_MODULE_I2C_ID                 427
+#define YWHAL_MODULE_GPIO_ID                428
+#define YWHAL_MODULE_HDD_ID                 429
+#define YWHAL_MODULE_INJECT_ID              430
+#define YWHAL_MODULE_PVR_ID                 431
+#define YWHAL_MODULE_TCPIP_ID               432
+#define YWHAL_MODULE_PLUGINSWP_ID           433
+#define YWHAL_MODULE_CA_ID                  434
 
 /*yw mid */
-#define	YWMID_MODULE_PUBLIC_ID  			500
-#define	YWMID_MODULE_DBASE_ID  				501
-#define	YWMID_MODULE_EPG_ID  				504
-#define	YWMID_MODULE_TTX_ID  				505
-#define	YWMID_MODULE_SUBT_ID  				506
-#define	YWMID_MODULE_TIMER_ID  				509
-#define	YWMID_MODULE_NIM_ID  				511
-#define	YWMID_MODULE_NVM_ID  				514
-#define	YWMID_MODULE_CI_ID  				527
-#define	YWMID_MODULE_TCPIP_ID  				528
+#define YWMID_MODULE_PUBLIC_ID              500
+#define YWMID_MODULE_DBASE_ID               501
+#define YWMID_MODULE_EPG_ID                 504
+#define YWMID_MODULE_TTX_ID                 505
+#define YWMID_MODULE_SUBT_ID                506
+#define YWMID_MODULE_TIMER_ID               509
+#define YWMID_MODULE_NIM_ID                 511
+#define YWMID_MODULE_NVM_ID                 514
+#define YWMID_MODULE_CI_ID                  527
+#define YWMID_MODULE_TCPIP_ID               528
 
 #define YWMID_MODULE_PRM_ID                 529
 #define YWMID_MODULE_CHANNEL_ID             530
@@ -67,12 +67,12 @@
 #define YWMID_MODULE_ABM_ID                 541
 #define YWMID_MODULE_SHOUTCAST_ID           542
 #define YWMID_MODULE_YOUTUBE_ID             543
-#define YWMID_MODULE_AVCTL_ID             	544
+#define YWMID_MODULE_AVCTL_ID               544
 
 /*yw app */
-#define	YWAPP_MODULE_PUBLIC_ID  		    600
-#define	YWAPP_MODULE_INSTALL_ID  			611
-#define	YWAPP_MODULE_SERVICE_ID  			612
+#define YWAPP_MODULE_PUBLIC_ID              600
+#define YWAPP_MODULE_INSTALL_ID             611
+#define YWAPP_MODULE_SERVICE_ID             612
 
 #define YW_MODULE_SET_ID(a)     (a << 16)
 #define YW_MODULE_GET_ID(a)     ((a >> 16) & 0xFFFF)
@@ -80,95 +80,91 @@
 #define YW_INVALID_HANDLE       0xffffffff
 
 /*Error type*/
-#define YW_NO_ERROR				0
-#define YW_ERROR_CODE(a,b)  	((b==0)?0:(YW_MODULE_SET_ID(a) +b))
+#define YW_NO_ERROR             0
+#define YW_ERROR_CODE(a,b)      ((b==0)?0:(YW_MODULE_SET_ID(a) +b))
 
 /*Event Type*/
-#define YW_EVENT_CODE(a,b)  	((b==0)?0:(YW_MODULE_SET_ID(a) +b))
-
+#define YW_EVENT_CODE(a,b)      ((b==0)?0:(YW_MODULE_SET_ID(a) +b))
 
 #ifndef TRUE
-    #define TRUE (1 == 1)
+#define TRUE (1 == 1)
 #endif
 #ifndef FALSE
-    #define FALSE (!TRUE)
+#define FALSE (!TRUE)
 #endif
 
 #ifndef NULL
-	#define NULL 0
+#define NULL 0
 #endif
 
 /*mid public error*/
 enum
 {
-    YWMID_ERROR_BAD_PARAMETER  = YW_MODULE_SET_ID(YWMID_MODULE_PUBLIC_ID ),   /* Bad parameter passed       */
-    YWMID_ERROR_NO_MEMORY,                 		/* Memory allocation failed   */
-    YWMID_ERROR_ALREADY_INITIALIZED,       		/* Device already initialized */
-    YWMID_ERROR_NO_INITIALIZED,					/* Device has not been initialized*/
-    YWMID_ERROR_NO_FREE_HANDLES,          		/* Cannot open device again   */
-    YWMID_ERROR_OPEN_HANDLE,               		/* At least one open handle   */
-    YWMID_ERROR_INVALID_HANDLE,            		/* Handle is not valid        */
-    YWMID_ERROR_FEATURE_NOT_SUPPORTED   		/* Feature unavailable        */
+	YWMID_ERROR_BAD_PARAMETER  = YW_MODULE_SET_ID(YWMID_MODULE_PUBLIC_ID),    /* Bad parameter passed       */
+	YWMID_ERROR_NO_MEMORY,                      /* Memory allocation failed   */
+	YWMID_ERROR_ALREADY_INITIALIZED,            /* Device already initialized */
+	YWMID_ERROR_NO_INITIALIZED,                 /* Device has not been initialized*/
+	YWMID_ERROR_NO_FREE_HANDLES,                /* Cannot open device again   */
+	YWMID_ERROR_OPEN_HANDLE,                    /* At least one open handle   */
+	YWMID_ERROR_INVALID_HANDLE,                 /* Handle is not valid        */
+	YWMID_ERROR_FEATURE_NOT_SUPPORTED           /* Feature unavailable        */
 };
 
 /*Hal public error*/
 enum
 {
-    YWHAL_ERROR_BAD_PARAMETER  = YW_MODULE_SET_ID(YWHAL_MODULE_PUBLIC_ID ),   /* Bad parameter passed  */
-    YWHAL_ERROR_NO_MEMORY,                 			/* Memory allocation failed   */
-    YWHAL_ERROR_UNKNOWN_DEVICE,            		/* Unknown device */
-    YWHAL_ERROR_ALREADY_INITIALIZED,      		/* Device already initialized */
-    YWHAL_ERROR_NO_INITIALIZED,					/* Device has not been initialized*/
-    YWHAL_ERROR_NO_FREE_HANDLES,          		/* Cannot open device again   */
-    YWHAL_ERROR_OPEN_HANDLE,              		/* At least one open handle   */
-    YWHAL_ERROR_INVALID_HANDLE,            		/* Handle is not valid        */
-    YWHAL_ERROR_FEATURE_NOT_SUPPORTED,   		/* Feature unavailable        */
-    YWHAL_ERROR_TIMEOUT,                  		/* Timeout occured            */
-    YWHAL_ERROR_DEVICE_BUSY,              		/* Device is currently busy   */
-    YWHAL_ERROR_NOT_OPEN,						/*Device is not open*/
-    YWHAL_ERROR_NOT_ENOUGH_DEVICE				/*Device is all opened*/
+	YWHAL_ERROR_BAD_PARAMETER  = YW_MODULE_SET_ID(YWHAL_MODULE_PUBLIC_ID),    /* Bad parameter passed  */
+	YWHAL_ERROR_NO_MEMORY,                          /* Memory allocation failed   */
+	YWHAL_ERROR_UNKNOWN_DEVICE,                 /* Unknown device */
+	YWHAL_ERROR_ALREADY_INITIALIZED,            /* Device already initialized */
+	YWHAL_ERROR_NO_INITIALIZED,                 /* Device has not been initialized*/
+	YWHAL_ERROR_NO_FREE_HANDLES,                /* Cannot open device again   */
+	YWHAL_ERROR_OPEN_HANDLE,                    /* At least one open handle   */
+	YWHAL_ERROR_INVALID_HANDLE,                 /* Handle is not valid        */
+	YWHAL_ERROR_FEATURE_NOT_SUPPORTED,          /* Feature unavailable        */
+	YWHAL_ERROR_TIMEOUT,                        /* Timeout occured            */
+	YWHAL_ERROR_DEVICE_BUSY,                    /* Device is currently busy   */
+	YWHAL_ERROR_NOT_OPEN,                       /*Device is not open*/
+	YWHAL_ERROR_NOT_ENOUGH_DEVICE               /*Device is all opened*/
 };
 
-
 /*variable type*******************************************************/
-typedef	signed char		    S8;
-typedef	unsigned char		U8;
-typedef	signed short		S16;
-typedef unsigned short		U16;
-typedef	signed int			S32;
-typedef	unsigned int		U32;
-
-typedef U32					BOOL;
-typedef U32 				YW_ErrorType_T;
-typedef U32       			YW_EventType_T;
-
+typedef signed char         S8;
+typedef unsigned char       U8;
+typedef signed short        S16;
+typedef unsigned short      U16;
+typedef signed int          S32;
+typedef unsigned int        U32;
+
+typedef U32                 BOOL;
+typedef U32                 YW_ErrorType_T;
+typedef U32                 YW_EventType_T;
 
 #ifdef ARCHITECTURE_ST40
 typedef struct U64_s
 {
-    unsigned int LSW;
-    unsigned int MSW;
-}U64;
+	unsigned int LSW;
+	unsigned int MSW;
+} U64;
 
 typedef U64 S64;
 
-
 /*Value=A+B, where A & B is U64 type*/
 #define YWI64_Add(A,B,Value)      { register long long T1,T2,Val; \
-                                T1  = (long long)(A).MSW << 32 | (A).LSW; \
-                                T2  = (long long)(B).MSW << 32 | (B).LSW; \
-                                Val = T1 + T2; \
-                                (Value).MSW = Val >> 32; \
-                                (Value).LSW = (U32)Val; \
-                                }
+		T1  = (long long)(A).MSW << 32 | (A).LSW; \
+		T2  = (long long)(B).MSW << 32 | (B).LSW; \
+		Val = T1 + T2; \
+		(Value).MSW = Val >> 32; \
+		(Value).LSW = (U32)Val; \
+	}
 
 /*Value=A+B, where A is U64 type & B is 32-bit atmost*/
 #define YWI64_AddLit(A,B,Value)   { register long long T1,Val; \
-                                T1 = (long long)(A).MSW << 32 | (A).LSW; \
-                                Val=T1+(B); \
-                                (Value).MSW = Val >> 32; \
-                                (Value).LSW = (U32)Val; \
-                                }
+		T1 = (long long)(A).MSW << 32 | (A).LSW; \
+		Val=T1+(B); \
+		(Value).MSW = Val >> 32; \
+		(Value).LSW = (U32)Val; \
+	}
 
 /*A==B, A & B are U64 type*/
 #define YWI64_IsEqual(A,B)                (((A).LSW == (B).LSW) && ((A).MSW == (B).MSW))
@@ -177,19 +173,19 @@
 
 /*A>=B, A & B are U64 type*/
 #define YWI64_IsGreaterOrEqual(A,B)       ( ((A).MSW >  (B).MSW) || \
-                                         (((A).MSW == (B).MSW) && ((A).LSW >= (B).LSW)))
+					    (((A).MSW == (B).MSW) && ((A).LSW >= (B).LSW)))
 
 /*A>B, A & B are U64 type*/
 #define YWI64_IsGreaterThan(A,B)          ( ((A).MSW >  (B).MSW) || \
-                                         (((A).MSW == (B).MSW) && ((A).LSW > (B).LSW)))
+					    (((A).MSW == (B).MSW) && ((A).LSW > (B).LSW)))
 
 /*A<B, A & B are U64 type*/
 #define YWI64_IsLessThan(A,B)             ( ((A).MSW <  (B).MSW) || \
-                                         (((A).MSW == (B).MSW) && ((A).LSW < (B).LSW)))
+					    (((A).MSW == (B).MSW) && ((A).LSW < (B).LSW)))
 
 /*A<=B, A & B are U64 type*/
 #define YWI64_IsLessOrEqual(A,B)          ( ((A).MSW <  (B).MSW) || \
-                                         (((A).MSW == (B).MSW) && ((A).LSW <= (B).LSW)))
+					    (((A).MSW == (B).MSW) && ((A).LSW <= (B).LSW)))
 
 #define YWI64_IsNegative(A)               ((A).MSW & 0X80000000)
 
@@ -203,68 +199,68 @@
 
 /*Value=A-B, where A & B are U64 type*/
 #define YWI64_Sub(A,B,Value)              ((Value).MSW  = (A).MSW - (B).MSW - (((A).LSW < (B).LSW)?1:0), \
-                                         (Value).LSW  = (A).LSW - (B).LSW)
+					   (Value).LSW  = (A).LSW - (B).LSW)
 
 /*Value=A-B, where A is U64 type & B is 32-bit atmost*/
 #define YWI64_SubLit(A,B,Value)           ((Value).MSW  = (A).MSW - (((A).LSW < (B))?1:0), \
-                                         (Value).LSW  = (A).LSW - (B))
+					   (Value).LSW  = (A).LSW - (B))
 /*Value=A/B, where A ,B is U64 type */
 #define YWI64_Div(A,B,Value)           { register long long T1,T2, Val;\
-                                        T1 = (long long)(A).MSW << 32 | (A).LSW;\
-                                        T2 = (long long)(B).MSW << 32 | (B).LSW;\
-                                        Val = T1/T2;\
-                                        (Value).MSW = Val >> 32;\
-                                        (Value).LSW = (U32)Val;\
-                                        }
+		T1 = (long long)(A).MSW << 32 | (A).LSW;\
+		T2 = (long long)(B).MSW << 32 | (B).LSW;\
+		Val = T1/T2;\
+		(Value).MSW = Val >> 32;\
+		(Value).LSW = (U32)Val;\
+	}
 
 /*Value=A/B, where A is U64 type & B is 32-bit atmost*/
 #define YWI64_DivLit(A,B,Value)           { register long long T1, Val;\
-                                        T1 = (long long)(A).MSW << 32 | (A).LSW;\
-                                        Val = T1/(B);\
-                                        (Value).MSW = Val >> 32;\
-                                        (Value).LSW = (U32)Val;\
-                                        }
+		T1 = (long long)(A).MSW << 32 | (A).LSW;\
+		Val = T1/(B);\
+		(Value).MSW = Val >> 32;\
+		(Value).LSW = (U32)Val;\
+	}
 
 /*Value=A%B, where A is U64 type & B is 32-bit atmost*/
 #define YWI64_ModLit(A,B,Value)           { register long long T1, Val;\
-                                        T1 = (long long)(A).MSW << 32 | (A).LSW;\
-                                        Val=T1%(B);\
-                                        (Value).MSW = Val >> 32;\
-                                        (Value).LSW = (U32)Val;\
-                                        }
+		T1 = (long long)(A).MSW << 32 | (A).LSW;\
+		Val=T1%(B);\
+		(Value).MSW = Val >> 32;\
+		(Value).LSW = (U32)Val;\
+	}
 
 /*Value=A*B, where A & B are U64 type*/
 #define YWI64_Mul(A,B,Value)              { register long long T1, T2, Val; \
-                                        T1 = (long long)(A).MSW << 32 | (A).LSW; \
-                                        T2 = (long long)(B).MSW << 32 | (B).LSW; \
-                                        Val=T1*T2; \
-                                        (Value).MSW = Val >> 32; \
-                                        (Value).LSW = (U32)Val; \
-                                        }
+		T1 = (long long)(A).MSW << 32 | (A).LSW; \
+		T2 = (long long)(B).MSW << 32 | (B).LSW; \
+		Val=T1*T2; \
+		(Value).MSW = Val >> 32; \
+		(Value).LSW = (U32)Val; \
+	}
 
 /*Value=A*B, where A is U64 type & B is 32-bit atmost*/
 #define I64_MulLit(A,B,Value)           { register long long T1,Val; \
-                                        T1 = (long long)(A).MSW << 32 | (A).LSW; \
-                                        Val=T1*(B); \
-                                        (Value).MSW = Val >> 32; \
-                                        (Value).LSW = (U32)Val; \
-                                        }
+		T1 = (long long)(A).MSW << 32 | (A).LSW; \
+		Val=T1*(B); \
+		(Value).MSW = Val >> 32; \
+		(Value).LSW = (U32)Val; \
+	}
 
 /*Value=Value<<Shift, where Value is U64 type*/
 #define YWI64_ShiftLeft(Shift,Value)      { register long long T1, T2, Val; \
-                                        T1 = (long long)(Value).MSW << 32 | (Value).LSW; \
-                                        Val=T1 << Shift; \
-                                        (Value).MSW = Val >> 32; \
-                                        (Value).LSW = (U32)Val; \
-                                        }
+		T1 = (long long)(Value).MSW << 32 | (Value).LSW; \
+		Val=T1 << Shift; \
+		(Value).MSW = Val >> 32; \
+		(Value).LSW = (U32)Val; \
+	}
 
 /*Value=Value>>Shift, where Value is U64 type*/
 #define YWI64_ShiftRight(Shift,Value)     { register long long T1, T2, Val; \
-                                        T1 = (long long)(Value).MSW << 32 | (Value).LSW; \
-                                        Val=T1 >> Shift; \
-                                        (Value).MSW = Val >> 32; \
-                                        (Value).LSW = (U32)Val; \
-                                        }
+		T1 = (long long)(Value).MSW << 32 | (Value).LSW; \
+		Val=T1 >> Shift; \
+		(Value).MSW = Val >> 32; \
+		(Value).LSW = (U32)Val; \
+	}
 #endif /*#ifdef ARCHITECTURE_ST40*/
 
 #define YW_HandleValid(Table, Max, Handle) ((Handle) >= (U32)&(Table)[0] \
diff -Naur a/frontcontroller/aotom/Makefile b/frontcontroller/aotom/Makefile
--- a/frontcontroller/aotom/Makefile	2017-05-01 20:31:14.714295282 +0200
+++ b/frontcontroller/aotom/Makefile	2017-05-02 14:21:10.572613549 +0200
@@ -5,6 +5,7 @@
     aotom-objs += aotom_trace.o
     aotom-objs += aotom_i2csoft.o
     aotom-objs += aotom_vfd.o
+    aotom-objs += aotom_procfs.o
     aotom-objs += aotom_main.o
 
     obj-m += aotom.o
diff -Naur a/frontcontroller/aotom/utf.h b/frontcontroller/aotom/utf.h
--- a/frontcontroller/aotom/utf.h	2017-05-01 20:31:14.716295230 +0200
+++ b/frontcontroller/aotom/utf.h	2017-05-02 14:19:36.519095703 +0200
@@ -1,426 +1,426 @@
-
+#if 0
 unsigned char UTF_C2[64][2] =
 {
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0}
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0}
 };
-
 unsigned char UTF_C3[64][2] =
 {
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0}
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0}
 };
+#endif
 
 unsigned char UTF_C4[64][2] =
 {
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0}
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0xF1, 0x38},	//polish CAPITAL LETTER A WITH OGONEK
+	{0xF1, 0x38},	//polish SMALL LETTER A WITH OGONEK
+	{0x01, 0x68},	//polish CAPITAL LETTER C WITH ACUTE
+	{0x01, 0x68},	//polish SMALL LETTER C WITH ACUTE
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0xE1, 0x68},	//polish CAPITAL LETTER E WITH OGONEK
+	{0xE1, 0x68},	//polish SMALL LETTER E WITH OGONEK
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0}
 };
 
 unsigned char UTF_C5[64][2] =
 {
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0}
+	{0x0, 0x0},
+	{0x01, 0x48},   //polish CAPITAL LETTER L WITH STROKE
+	{0x01, 0x48},   //polish SMALL LETTER L WITH STROKE
+	{0x53, 0x19},   //polish CAPITAL LETTER N WITH ACUTE
+	{0x53, 0x19},   //polish SMALL LETTER N WITH ACUTE
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0xF0, 0x68},	//polish CAPITAL LETTER S WITH ACUTE
+	{0xF0, 0x68},	//polish SMALL LETTER S WITH ACUTE
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x48, 0x64},	//polish CAPITAL LETTER Z WITH ACUTE
+	{0x48, 0x64},	//polish SMALL LETTER Z WITH ACUTE
+	{0x48, 0x64},	//polish CAPITAL LETTER Z WITH DOT ABOVE
+	{0x48, 0x64},	//polish SMALL LETTER Z WITH DOT ABOVE
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0}
 };
 
 unsigned char UTF_D0[64][2] =
 {
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0xF1,0x38},//А       Russian start
-        {0xF1,0x68},//Б
-        {0xC3,0x6C},//В
-        {0x01,0x28},//Г
-        {0x54,0x72},//Д
-        {0xE1,0x68},//Е
-        {0x4E,0x07},//Ж
-        {0x42,0x64},//З
-        {0x59,0x1C},//И
-        {0x59,0x1C},//Й
-        {0xC3,0x0C},//К
-        {0x58,0x14},//Л
-        {0x51,0x1D},//М
-        {0xF1,0x18},//Н
-        {0x11,0x78},//О
-        {0x11,0x38},//П
-
-        {0xE1,0x38},//Р
-        {0x01,0x68},//С
-        {0x44,0x22},//Т
-        {0xF0,0x58},//У
-        {0x55,0x7A},//Ф
-        {0x4A,0x05},//Х
-        {0x05,0x4A},//Ц
-        {0xF0,0x18},//Ч
-        {0x55,0x5A},//Ш
-        {0x55,0x5A},//Щ
-        {0x71,0x48},//Ъ
-        {0xD5,0x58},//Ы
-        {0x71,0x48},//Ь
-        {0x70,0x70},//Э
-        {0xD3,0x1C},//Ю
-        {0x78,0x38},//Я
-
-        {0xF1,0x38},//А
-        {0xF1,0x68},//Б
-        {0xC3,0x6C},//В
-        {0x01,0x28},//Г
-        {0x54,0x72},//Д
-        {0xE1,0x68},//Е
-        {0x4E,0x07},//Ж
-        {0x42,0x64},//З
-        {0x59,0x1C},//И
-        {0x59,0x1C},//Й
-        {0xC3,0x0C},//К
-        {0x58,0x14},//Л
-        {0x51,0x1D},//М
-        {0xF1,0x18},//Н
-        {0x11,0x78},//О
-        {0x11,0x38} //П
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0xF1, 0x38}, //А       Russian start
+	{0xF1, 0x68}, //Б
+	{0xC3, 0x6C}, //В
+	{0x01, 0x28}, //Г
+	{0x54, 0x72}, //Д
+	{0xE1, 0x68}, //Е
+	{0x4E, 0x07}, //Ж
+	{0x42, 0x64}, //З
+	{0x59, 0x1C}, //И
+	{0x59, 0x1C}, //Й
+	{0xC3, 0x0C}, //К
+	{0x58, 0x14}, //Л
+	{0x51, 0x1D}, //М
+	{0xF1, 0x18}, //Н
+	{0x11, 0x78}, //О
+	{0x11, 0x38}, //П
+
+	{0xE1, 0x38}, //Р
+	{0x01, 0x68}, //С
+	{0x44, 0x22}, //Т
+	{0xF0, 0x58}, //У
+	{0x55, 0x7A}, //Ф
+	{0x4A, 0x05}, //Х
+	{0x05, 0x4A}, //Ц
+	{0xF0, 0x18}, //Ч
+	{0x55, 0x5A}, //Ш
+	{0x55, 0x5A}, //Щ
+	{0x71, 0x48}, //Ъ
+	{0xD5, 0x58}, //Ы
+	{0x71, 0x48}, //Ь
+	{0x70, 0x70}, //Э
+	{0xD3, 0x1C}, //Ю
+	{0x78, 0x38}, //Я
+
+	{0xF1, 0x38}, //А
+	{0xF1, 0x68}, //Б
+	{0xC3, 0x6C}, //В
+	{0x01, 0x28}, //Г
+	{0x54, 0x72}, //Д
+	{0xE1, 0x68}, //Е
+	{0x4E, 0x07}, //Ж
+	{0x42, 0x64}, //З
+	{0x59, 0x1C}, //И
+	{0x59, 0x1C}, //Й
+	{0xC3, 0x0C}, //К
+	{0x58, 0x14}, //Л
+	{0x51, 0x1D}, //М
+	{0xF1, 0x18}, //Н
+	{0x11, 0x78}, //О
+	{0x11, 0x38} //П
 };
 
 unsigned char UTF_D1[64][2] =
 {
-        {0xE1,0x38},//Р
-        {0x01,0x68},//С
-        {0x44,0x22},//Т
-        {0xF0,0x58},//У
-        {0x55,0x7A},//Ф
-        {0x4A,0x05},//Х
-        {0x05,0x4A},//Ц
-        {0xF0,0x18},//Ч
-        {0x55,0x5A},//Ш
-        {0x55,0x5A},//Щ
-        {0x71,0x48},//Ъ
-        {0xD5,0x58},//Ы
-        {0x71,0x48},//Ь
-        {0x70,0x70},//Э
-        {0xD3,0x1C},//Ю
-        {0x78,0x38},//Я		Russian end
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0},
-        {0x0,0x0}
+	{0xE1, 0x38}, //Р
+	{0x01, 0x68}, //С
+	{0x44, 0x22}, //Т
+	{0xF0, 0x58}, //У
+	{0x55, 0x7A}, //Ф
+	{0x4A, 0x05}, //Х
+	{0x05, 0x4A}, //Ц
+	{0xF0, 0x18}, //Ч
+	{0x55, 0x5A}, //Ш
+	{0x55, 0x5A}, //Щ
+	{0x71, 0x48}, //Ъ
+	{0xD5, 0x58}, //Ы
+	{0x71, 0x48}, //Ь
+	{0x70, 0x70}, //Э
+	{0xD3, 0x1C}, //Ю
+	{0x78, 0x38}, //Я        Russian end
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0},
+	{0x0, 0x0}
 };
